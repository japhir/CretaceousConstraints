#+title: Cretaceous Constraints
#+author: Ilja J. Kocken
#+PROPERTY: header-args:R  :session *R:2023-05-19_cretaceous_constraints* :exports output :results output :eval no-export
#+options: TOC:3 broken-links:ignore H:4
#+startup: overview
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport nolatex
#+visibility: folded

* libraries
#+begin_src R :results none
  library(tidyverse) # data wrangling + plotting
  library(patchwork) # multipane plots
  # I also use `astrochron` and `snvecR` throughout,
  # but always use them like `package::function()`
  library(assertr)   # verify data integrity
  library(profvis)   # find out where my code is slow
  library(future)    # this is for parallel computing
  library(furrr)     # parallel purrr::map functions
  ## devtools::install_github("https://github.com/jrevenaugh/TSAUMN2")
  ## library(TSAUMN)    # for some special spectral analysis tools
  # I also use these functions with TSAUMN::function
  # load the AstronomicalSolutions development package
  devtools::load_all()
  # set ggplot theme
  # very minimalist
  theme_set(theme_bw() +
            theme(legend.key.width = unit(1, "cm"),
                  strip.clip = "off",
                  ## strip.text.x = element_text(size = 7.5),
                  panel.grid = element_blank(),
                  panel.border = element_blank(),
                  axis.line = element_line(linewidth = .2),
                  strip.background = element_blank(),
                  ## strip.placement = "outside"
                  ))
  plan(multisession, workers = 4) # set up 4 cores
#+end_src

# #+results: # commented out because this is pretty slow for some reason
#+begin_example
── Attaching core tidyverse packages ────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.5.0     ✔ tibble    3.2.1
✔ lubridate 1.9.3     ✔ tidyr     1.3.1
✔ purrr     1.0.2
── Conflicts ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
ℹ Loading AstronomicalSolutions
#+end_example

#+begin_src R :results output
  sessionInfo()
#+end_src

#+RESULTS:
#+begin_example
R version 4.3.3 (2024-02-29)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Arch Linux

Matrix products: default
BLAS/LAPACK: /usr/lib/libopenblas.so.0.3;  LAPACK version 3.12.0

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     LC_MONETARY=en_US.UTF-8
 [6] LC_MESSAGES=en_US.UTF-8    LC_PAPER=en_US.UTF-8       LC_NAME=C                  LC_ADDRESS=C               LC_TELEPHONE=C
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C

time zone: Pacific/Honolulu
tzcode source: system (glibc)

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base

other attached packages:
 [1] AstronomicalSolutions_0.0.0.9000 testthat_3.2.1                   furrr_0.3.1                      future_1.33.1
 [5] profvis_0.3.8                    assertr_3.0.1                    patchwork_1.2.0                  lubridate_1.9.3
 [9] forcats_1.0.0                    stringr_1.5.1                    dplyr_1.1.4                      purrr_1.0.2
[13] readr_2.1.5                      tidyr_1.3.1                      tibble_3.2.1                     ggplot2_3.5.0
[17] tidyverse_2.0.0

loaded via a namespace (and not attached):
  [1] gridExtra_2.3        remotes_2.4.2.1      rlang_1.1.3          magrittr_2.0.3       matrixStats_1.2.0    compiler_4.3.3       loo_2.7.0
  [8] vctrs_0.6.5          maps_3.4.2           pkgconfig_2.0.3      shape_1.4.6.1        fastmap_1.1.1        backports_1.4.1      ellipsis_0.3.2
 [15] utf8_1.2.4           cmdstanr_0.6.0       promises_1.2.1       rmarkdown_2.26       sessioninfo_1.2.2    tzdb_0.4.0           ps_1.7.6
 [22] xfun_0.42            cachem_1.0.8         IDPmisc_1.1.21       palinsol_1.0         later_1.3.2          cluster_2.1.6        parallel_4.3.3
 [29] R6_2.5.1             stringi_1.8.3        rpart_4.1.23         parallelly_1.37.1    pkgload_1.3.4        brio_1.1.4           Rcpp_1.0.12
 [36] iterators_1.0.14     knitr_1.45           fields_15.2          usethis_2.2.3        base64enc_0.1-3      nnet_7.3-19          httpuv_1.6.14
 [43] timechange_0.3.0     tidyselect_1.2.1     rstudioapi_0.15.0    abind_1.4-5          doParallel_1.0.17    codetools_0.2-19     rethinking_2.40
 [50] miniUI_0.1.1.1       multitaper_1.0-17    processx_3.8.3       listenv_0.9.1        pkgbuild_1.4.3       lattice_0.22-5       shiny_1.8.0
 [57] withr_3.0.0          posterior_1.5.0      evaluate_0.23        coda_0.19-4.1        foreign_0.8-86       desc_1.4.3           urlchecker_1.0.1
 [64] pillar_1.9.0         tensorA_0.36.2.1     astrochron_1.2       checkmate_2.3.1      foreach_1.5.2        distributional_0.4.0 generics_0.1.3
 [71] rprojroot_2.0.4      hms_1.1.3            munsell_0.5.0        scales_1.3.0         globals_0.16.3       xtable_1.8-4         glue_1.7.0
 [78] Hmisc_5.1-1          tools_4.3.3          data.table_1.15.2    fs_1.6.3             mvtnorm_1.2-4        dotCall64_1.1-1      grid_4.3.3
 [85] devtools_2.4.5       colorspace_2.1-0     htmlTable_2.4.2      Formula_1.2-5        cli_3.6.2            spam_2.10-0          fansi_1.0.6
 [92] viridisLite_0.4.2    gtable_0.3.4         digest_0.6.35        htmlwidgets_1.6.4    memoise_2.0.1        htmltools_0.5.7      lifecycle_1.0.4
 [99] mime_0.12            MASS_7.3-60.0.1
#+end_example

* some shared code                                     :noexport:
:PROPERTIES:
:CREATED:  [2023-11-14 Tue 14:57]
:header-args:R: :session *R:2023-05-19_cretaceous_constraints* :exports code :eval no-export :results output
:CUSTOM_ID: sec:shared-code
:END:
these have mostly migrated to a development package!
** AstronomicalSolutions
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 14:00]
:header-args:R: :session *R:cretaceous-constraints* :exports code :eval no-export :results output
:END:
*** DONE make this into a package for myself
CLOSED: [2024-01-23 Tue 13:35]
:PROPERTIES:
:CREATED:  [2023-12-22 Fri 21:59]
:END:
:LOGBOOK:
- State "DONE"       from "SOME"       [2024-01-23 Tue 13:35]
- State "SOME"       from              [2023-12-22 Fri 21:59]
:END:

#+transclude: [[file:DESCRIPTION]]
*** spectral analysis
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 14:00]
:END:
This does spectral analysis on data within each group in ~nest~ based on parameters ~x~ and ~y~. In ~astrochron~, you have to give it a ~data.frame~ with only 2 columns, which loses all the rich metadata for the data.

#+transclude: [[file:R/spectral_analysis.R]]  :src R

**** SOME add astrochron::periodogram as fft?
:PROPERTIES:
:CREATED:  [2023-11-15 Wed 16:30]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-11-15 Wed 16:30]
:END:
I've done this manually for MS: [[file:~/SurfDrive/Postdoc1/prj/2023-05-19_cretaceous_constraints/cretaceous_constraints.org::*do spectral analysis][do spectral analysis]]
It's not much better, gets a bit messy if plotted on log10 scale.

**** SOME add Blackman--Tukey as well?
:PROPERTIES:
:CREATED:  [2023-11-15 Wed 21:50]
:END:
:LOGBOOK:
- State "SOME"       from "DONE"       [2023-11-15 Wed 21:50]
:END:

**** SOME add MTLS
:LOGBOOK:
- State "SOME"       from              [2023-12-22 Fri 21:52]
:END:

*** plot spectrum
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 16:16]
:END:
This plots the MTM spectrum with a log axis on both x and y.

#+transclude: [[file:R/plot_spectrum.R]]  :src R

*** eha
:PROPERTIES:
:CREATED:  [2023-12-21 Thu 10:15]
:END:

#+transclude: [[file:R/evolutive_analysis.R]]  :src R

*** bandpass filter
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 14:08]
:END:
This filters out all the frequencies in dataframe ~freqs~.

#+transclude: [[file:R/bandpass_filter.R]]  :src R

*** taner_filter
#+transclude: [[file:R/taner_filter.R]]  :src R

*** construct_eccentricity
:PROPERTIES:
:CREATED:  [2023-12-21 Thu 16:35]
:END:

#+transclude: [[file:R/construct_eccentricity.R]]  :src R

*** SOME hilbert transform
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 14:40]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-09-28 Thu 14:48]
:END:
I haven't written clean code for this yet, not sure if it'll be useful. The idea is to filter precession, then do a hilbert transform for it to get the amplitude modulation, which should correspond to the eccentricity signal.

** functions that haven't landed yet
:PROPERTIES:
:CREATED:  [2024-01-23 Tue 13:35]
:END:
*** get_rmcd
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:58]
:END:
This function calculates the (r)mcd from a dataset with mbsf and a splice table.

#+begin_src R
get_rmcd <- function(data, rmcd = "dat/ODP208_1267_rmcd.csv") {
  rmcd <- readr::read_csv(rmcd) |>
    separate(label, into = c("sitehole", "coretype", "Sec"),
               sep = "-", remove = FALSE) |>
    separate(sitehole, into = c("Site", "H"), sep = -1) |>
    separate(coretype, into = c("Core", "T"), sep = -1) |>
    # we do not rename the interval, may not be the same as in the data!
    # rename the CC sections into 7, the naming convention in the MS data
    mutate(Sec = ifelse(Sec == "7", "7", Sec),
           Sec = ifelse(Sec == "cc", "C", Sec)) |>
    mutate(diff = depth_rmcd - depth_mbsf, .after = depth_rmcd) |>
    mutate(diff2 = depth_rmcd2 - depth_mbsf2, .after = depth_rmcd2) |>
    mutate(row = 1:n())

  # the right side of the splice table only
  rmcd2 <- rmcd |>
    select(label, link, label2, interval2, depth_mbsf2, depth_rmcd2, diff2, row) |>
    separate(label2, into = c("sitehole", "coretype", "Sec"),
               sep = "-", remove = FALSE) |>
    separate(sitehole, into = c("Site", "H"), sep = -1) |>
    separate(coretype, into = c("Core", "T"), sep = -1) |>
    # we do not rename the interval, may not be the same as in the data!
    mutate(Sec = ifelse(Sec == "7", "7", Sec),
           Sec = ifelse(Sec == "cc", "C", Sec))

  out <- data |>
    tidylog::left_join(rmcd |>
                     # make the types the same
                     mutate(across(c(Site, Core), parse_double)) |>
                     # do NOT match by section, only by core!
                     rename(section = Sec) |>
                     select(top = label, to = label2,
                            Site, H, Core, T, section, interval,
                            depth_mbsf, depth_rmcd, diff, row)) |>
    # add the right-hand side of the splice table
    tidylog::left_join(rmcd2 |>
                       mutate(across(c(Site, Core), parse_double)) |>
                       rename(section2 = Sec) |>
                       select(from = label, bot = label2,
                              Site, H, Core, T, section2, interval2,
                              depth_mbsf2, depth_rmcd2, diff2, row2 = row)) |>
  mutate(my_rmcd = case_when(
  (Sec <= section) | ((Sec == section) & (`Top (cm)` <= interval)) ~
    `Depth (mbsf)` + diff,
  (Sec >= section2) | ((Sec == section2) & (`Top (cm)` >= interval2)) ~
    `Depth (mbsf)` + diff2,
  TRUE ~ NA_real_)) |>
    mutate(on_splice = (Sec < section | ((Sec == section) &
                                         (`Top (cm)` <= interval))) &
             (Sec > section2 | ((Sec == section2) &
                                `Top (cm)` >= interval2))) |>
    mutate(on_splice = ifelse(is.na(on_splice), FALSE, on_splice))

  return(out)
}
#+end_src

#+RESULTS:

** Astronomical Solutions
:PROPERTIES:
:CREATED:  [2023-09-27 Wed 18:50]
:END:
To compare the record with.
*** COMMENT orbital frequencies to bandpass filter
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 11:15]
:END:
Just 405 kyr and 100 kyr \pm30%.

#+begin_src R
  my_os_freqs <- tribble(
    ~ target, ~ p,
    "405 kyr", 405,
    "100 kyr", 100,
  ) |>
    mutate(f = 1 / p,
           fr = 0.3 * f,
           flow = f - fr,
           fhigh = f + fr) #|>
    ## select(target, p, f, flow, fhigh)
#+end_src

#+RESULTS:
*** targets
:PROPERTIES:
:CREATED:  [2024-01-02 Tue 14:21]
:END:
#+begin_src R
  target_astronomical_solutions <- c("La10b",
                                     "La10c",
                                     "ZB18a",
                                     "ZB20a",
                                     "ZB20b",
                                     "ZB20c",
                                     "ZB20d")
#+end_src

#+RESULTS:

*** get ZB18a
:PROPERTIES:
:CREATED:  [2023-09-26 Tue 16:51]
:END:
I can reuse my ~snvecR~ code here!
#+begin_src R
  # get the first orbital solution in there
  ZB18a <- snvecR::get_solution("ZB18a-300") |>
    ## select(age, ecc = ee) |>
    filter(age >= 56000 & age <= 80000) |>
    mutate(scl = scale(ecc)[, 1]) |>
    mutate(sln = "ZB18a", .before = age)

  sln <- ZB18a
#+end_src


#+RESULTS:
*** get ZB20a
:PROPERTIES:
:CREATED:  [2023-09-27 Wed 17:22]
:END:
Download the solution once from the website, then save to file locally. Similar to how ~snvecR~ does it.
#+begin_src R :eval never
  sln2 <- readr::read_table("http://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro/300Myr/ZB20a.dat",
                            comment = "%",
                            col_names = c("age", "ecc", "inc")) |>
    write_rds("out/ZB20a.rds")
#+end_src

Load the saved file, then process it further.
#+begin_src R
  ZB20a <- read_rds("out/ZB20a.rds") |>
    select(age, ecc) |>
    filter(age >= 56000 & age <= 80000) |>
    mutate(scl = scale(ecc)[, 1]) |>
    mutate(sln = "ZB20a", .before = age)

  sln2 <- ZB20a
#+end_src

#+RESULTS:

*** get ZB20b
:PROPERTIES:
:CREATED:  [2024-01-02 Tue 14:08]
:END:
#+begin_src R :eval never
  sln2b <- readr::read_table("http://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro/300Myr/ZB20b.dat",
                            comment = "%",
                            col_names = c("age", "ecc", "inc")) |>
    write_rds("out/ZB20b.rds")
#+end_src

Load the saved file, then process it further.
#+begin_src R
  ZB20b <- read_rds("out/ZB20b.rds") |>
    select(age, ecc) |>
    filter(age >= 56000 & age <= 80000) |>
    mutate(scl = scale(ecc)[, 1]) |>
    mutate(sln = "ZB20b", .before = age)

  sln2b <- ZB20b
#+end_src

#+RESULTS:
*** get ZB20c
:PROPERTIES:
:CREATED:  [2024-01-02 Tue 14:08]
:END:
#+begin_src R :eval never
  sln2c <- readr::read_table("http://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro/300Myr/ZB20c.dat",
                            comment = "%",
                            col_names = c("age", "ecc", "inc")) |>
    write_rds("out/ZB20c.rds")
#+end_src

Load the saved file, then process it further.
#+begin_src R
  ZB20c <- read_rds("out/ZB20c.rds") |>
    select(age, ecc) |>
    filter(age >= 56000 & age <= 80000) |>
    mutate(scl = scale(ecc)[, 1]) |>
    mutate(sln = "ZB20c", .before = age)

  sln2c <- ZB20c
#+end_src

#+RESULTS:
*** get ZB20d
:PROPERTIES:
:CREATED:  [2024-01-02 Tue 14:09]
:END:
#+begin_src R :eval never
  sln2d <- readr::read_table("http://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro/300Myr/ZB20d.dat",
                            comment = "%",
                            col_names = c("age", "ecc", "inc")) |>
    write_rds("out/ZB20d.rds")
#+end_src

Load the saved file, then process it further.
#+begin_src R
  ZB20d <- read_rds("out/ZB20d.rds") |>
    select(age, ecc) |>
    filter(age >= 56000 & age <= 80000) |>
    mutate(scl = scale(ecc)[, 1]) |>
    mutate(sln = "ZB20d", .before = age)

  sln2d <- ZB20d
#+end_src

#+RESULTS:
*** get La11
:PROPERTIES:
:CREATED:  [2023-10-03 Tue 13:47]
:END:
This solution is *not* available on [[http://vo.imcce.fr/insola/earth/online/earth/earth.html][Laskar's website]], so I get it through ~astrochron~.

#+begin_src R :eval never :results both
  La11 <- astrochron::getLaskar(sol = "la11") |>
    readr::write_rds("out/La11.rds")
#+end_src

#+RESULTS:
#+begin_example
 ,* Downloading Laskar et al. (2011) astronomical solution: La2011

   Please cite: Laskar, J., Fienga, A., Gastineau, M., Manche, H., 2011,
   La2010: A new orbital solution for the long-term motion of the Earth:
   Astron. Astrophys., Volume 532, A89.
  AND:
   Laskar, J., Gastineau, M., Delisle, J.-B., Farres, A., Fienga, A.: 2011,
   Strong chaos induced by close encounters with Ceres and Vesta:
   Astron. Astrophys., Volume 532, L4.
trying URL 'http://www.geology.wisc.edu/~smeyers/astrochron/la11.txt.bz2'
Content type 'application/x-bzip2' length 392736 bytes (383 KB)
==================================================
downloaded 383 KB

 ,* Decompressing solution
#+end_example

#+begin_src R
  La11 <- readr::read_rds("out/La11.rds") |>
    as_tibble() |>
    rename(age = Time_ka, ecc = ecc_LA11) |>
    filter(age >= 56000 & age <= 80000) |>
    mutate(scl = scale(ecc)[, 1]) |>
    mutate(sln = "La11", .before = age)

  sln3 <- La11
#+end_src

#+RESULTS:
*** get La10b
http://vo.imcce.fr/insola/earth/online/earth/earth.html
#+begin_src R :eval never
  La10b <- readr::read_table(
                    "http://vo.imcce.fr/insola/earth/online/earth/La2010/La2010b_ecc3L.dat",
                    col_names = c("age", "ecc")) |>
    write_rds("out/La10b.rds")
#+end_src

#+RESULTS:
:
: ── Column specification ─────────────────────────────────────────────────────────────────────────────────
: cols(
:   age = col_double(),
:   ecc = col_double()
: )

#+begin_src R
  La10b <- read_rds("out/La10b.rds") |>
    select(age, ecc) |>
    mutate(age = -age) |>
    filter(age >= 56000 & age <= 80000) |>
    mutate(scl = scale(ecc)[, 1]) |>
    mutate(sln = "La10b", .before = age)

  sln4 <- La10b
#+end_src

#+RESULTS:

*** get La10c
http://vo.imcce.fr/insola/earth/online/earth/earth.html
#+begin_src R :eval never
  La10c <- readr::read_table(
                    "http://vo.imcce.fr/insola/earth/online/earth/La2010/La2010c_ecc3L.dat",
                    col_names = c("age", "ecc")) |>
    write_rds("out/La10c.rds")
#+end_src

#+RESULTS:
:
: ── Column specification ─────────────────────────────────────────────────────────────────────────────────
: cols(
:   age = col_double(),
:   ecc = col_double()
: )

#+begin_src R
  La10c <- read_rds("out/La10c.rds") |>
    select(age, ecc) |>
    mutate(age = -age) |>
    filter(age >= 56000 & age <= 80000) |>
    mutate(scl = scale(ecc)[, 1]) |>
    mutate(sln = "La10c", .before = age)

  sln5 <- La10c
#+end_src

#+RESULTS:

*** combine all solutions
:PROPERTIES:
:CREATED:  [2023-11-28 Tue 11:12]
:END:
#+begin_src R :eval never
  slns <- sln |>
    bind_rows(sln2) |>
    bind_rows(sln2b) |>
    bind_rows(sln2c) |>
    bind_rows(sln2d) |>
    bind_rows(sln3) |>
    bind_rows(sln4) |>
    bind_rows(sln5) |>
    write_rds("out/slns.rds")
#+end_src

#+RESULTS:

#+begin_src R
  slns <- read_rds("out/slns.rds")
#+end_src

#+RESULTS:

*** use my package to get the solutions
#+begin_src R :eval never
  full_slns <- bind_rows(
    snvecR::get_solution("La10b") |> rename(age = Time_ka, ecc = ecc_LA10b) |> mutate(sol = "La10b"),
    snvecR::get_solution("La10c") |> rename(age = Time_ka, ecc = ecc_LA10c) |> mutate(sol = "La10c"),
    snvecR::get_solution("ZB18a-300") |> mutate(sol = "ZB18a"),
    snvecR::get_solution("ZB20a") |> mutate(sol = "ZB20a"),
    snvecR::get_solution("ZB20b") |> mutate(sol = "ZB20b"),
    snvecR::get_solution("ZB20c") |> mutate(sol = "ZB20c"),
    snvecR::get_solution("ZB20d") |> mutate(sol = "ZB20d"),
  ) |> write_rds("out/full_slns.rds")
#+end_src

#+begin_src R
  full_slns <- read_rds("out/full_slns.rds")
#+end_src

#+RESULTS:

** spectral analysis on astronomical solutions
:PROPERTIES:
:CREATED:  [2023-12-22 Fri 10:56]
:END:
#+begin_src R :eval never
  slns_specs <- nested_spectral_analysis(slns, nest = "sln", x = age, y = ecc)
#+end_src

#+RESULTS:

#+begin_src R
  slns_specs <- readr::read_rds("out/slns_specs.rds")
#+end_src

#+RESULTS:

*** filter ranges in the age domain
:PROPERTIES:
:CREATED:  [2023-12-22 Fri 13:19]
:END:
I'd like to filter out the 405 and 100 kyr eccentricity cycles. I just do those frequencies \pm 25%.
#+begin_src R
  my_filt_age <- tribble(
    ~ target, ~ p,
    "405 kyr", 405,
    "100 kyr", 110,
    "23 kyr", 23
  ) |>
    mutate(f = 1 / p,
           range = 0.25 * f,
           flow = f - range,
           fhigh = f + range,
          ref = "This study")
#+end_src

#+RESULTS:

Just to check, this results in the following periods for filtering the AS:
#+begin_src R
  my_filt_age |>
    mutate(plow = 1 / flow, phigh = 1 / fhigh)
#+end_src

#+RESULTS:
: # A tibble: 3 × 9
:   target      p       f    range    flow   fhigh ref         plow phigh
:   <chr>   <dbl>   <dbl>    <dbl>   <dbl>   <dbl> <chr>      <dbl> <dbl>
: 1 405 kyr   405 0.00247 0.000617 0.00185 0.00309 This study 540   324
: 2 100 kyr   110 0.00909 0.00227  0.00682 0.0114  This study 147.   88
: 3 23 kyr     23 0.0435  0.0109   0.0326  0.0543  This study  30.7  18.4

So 312 kyr to 579 kyr for the 405 kyr peak. This in comparison to [cite:@Batenburg2014], where they filter the La11 solution between 300 and 623 kyr to target the 405 kyr solution.

*** COMMENT test plot_spectrum for a single spectrum
:PROPERTIES:
:CREATED:  [2023-12-22 Fri 11:24]
:END:
#+begin_src R :results graphics file output :file imgs/ZB20a_spectrum.png :width 2400 :height 1900 :res 300 :eval never
  plot_spectrum(slns_specs |> filter(sln == "ZB20a"), ar1 = TRUE) +
  coord_cartesian(xlim = c(0, 0.02))
  ## identify 100 kyr peak components
  ## coord_cartesian(xlim = c(0.0071, 0.011)) +
  ## geom_vline(xintercept = c(1/405, 1/132.5, 1/123.5, 1/99.5, 1/94.5))
#+end_src

#+RESULTS:
[[file:imgs/ZB20a_spectrum.png]]

*** plot_spectrum for all astronomical solutions
#+begin_src R :results graphics file output :file imgs/astronomical_solution_spectrum.png :width 2400 :height 1000 :res 300
  plot_spectrum(slns_specs, group = "sln", domain = "time") +
    ## coord_cartesian(xlim = c(1/3000, 0.06), ylim = c(0, 6e-6)) + # show precession as well
    coord_cartesian(xlim = c(0, 0.012), ylim = c(0, 6e-6)) +
    scale_colour_brewer(type = "qual", palette = 2) +
    scale_fill_brewer(type = "qual", palette = 2) +
    ## coord_cartesian(xlim = c(0.0071, 0.011)) + # zoom on 100 kyr peaks
    ## geom_vline(xintercept = c(1/405, 1/132.5, 1/124, 1/99.7, 1/95))
    geom_rect(aes(xmin = flow, xmax = fhigh, ymin = -Inf, ymax = Inf),
              fill = "yellow", alpha = .1,
              inherit.aes = FALSE, data = my_filt_age) +
    # annotate periods of interest
    geom_vline(xintercept = 1 / c(405, 95, 99.7, 124, 132.5)) +
    geom_vline(xintercept = 1 / c(405, 95, 99, 124, 131), colour = "red", linetype = "dashed")
#+end_src

#+name: fig:astronomical-solutions-spec
#+caption: MTM spectra of astronomical solutions studied here.
#+RESULTS:
[[file:imgs/astronomical_solution_spectrum.png]]

*** plot spectrum for 0--20 Ma
:PROPERTIES:
:CREATED:  [2024-05-06 Mon 13:40]
:END:
#+begin_src R :results graphics file output :file imgs/astronomical_solution_spectrum_0-20Ma.png :width 2400 :height 1000 :res 300
  full_slns |>
    filter(age < 20e3) |>
    nested_spectral_analysis(nest = "sol", method = "MTM", x = "age", y = "ecc") |>
    plot_spectrum(group = "sol", domain = "time") +
    scale_colour_brewer(type = "qual", palette = 2) +
    scale_fill_brewer(type = "qual", palette = 2) +
    coord_cartesian(xlim = c(0, 0.012)) +
    geom_vline(xintercept = 1 / c(405, 95, 99.7, 124, 132.5)) +
    geom_vline(xintercept = 1 / c(405, 95, 99, 124, 131), colour = "red", linetype = "dashed")
#+end_src

#+RESULTS:
[[file:imgs/astronomical_solution_spectrum_0-20Ma.png]]

*** plot spectrum for full solutions in 20 Myr chunks
:PROPERTIES:
:CREATED:  [2024-05-06 Mon 13:41]
:END:
#+begin_src R
  full_spec <- full_slns |>
    tidylog::filter(age <= 100e3) |>
    mutate(age_chunk = cut(age, breaks = seq(-1, 101e3, 20e3))) |> # 10 Myr time slices
    tidylog::filter(!is.na(age_chunk)) |>
    nest(.by = c(sol, age_chunk)) |>
    mutate(spc = map(data, spectral_analysis, x = "age", y = "ecc"))
#+end_src

#+RESULTS:
: filter: removed 923,000 rows (64%), 512,507 rows remaining
: filter: removed 7 rows (<1%), 512,500 rows remaining

#+begin_src R :results output graphics file :file imgs/full_solution_spectra_20-myr_chunks.png :width 2200 :height 2000 :res 300
  full_spec |>
    mutate(N = map_int(data, nrow)) |>
    tidylog::filter(N >= 12.5e3) |> # remove final slices that have too few datapoints for La10b and La10c
    select(-data) |>
    mutate(age_chunk = factor(age_chunk, labels = paste0(seq(0, 80, 20), "–", seq(20, 100, 20), " Ma"))) |>
    unnest(spc) |>
    tidylog::distinct(sol, age_chunk, frequency, power, .keep_all = TRUE) |>
    plot_spectrum(group = "age_chunk", domain = "time") +
    facet_grid(rows = vars(sol)) +
    scale_colour_viridis_d() +
    coord_cartesian(xlim = c(0.006, 0.012), ylim = c(0, 5e-6))
#+end_src

#+RESULTS:
[[file:imgs/full_solution_spectra_20-myr_chunks.png]]

make an interactive copy
#+begin_src R
  plotly::toWebGL(plotly::ggplotly(p = ggplot2::last_plot() + labs(x = "freq", y = "pow")))
#+end_src

#+RESULTS:
: There were 35 warnings (use warnings() to see them)

*** eha on solutions
:PROPERTIES:
:CREATED:  [2024-05-06 Mon 14:55]
:END:
#+begin_src R
  full_ehas <- full_slns |>
    nest(.by = sol) |>
    mutate(eha = map(data, astrochron::eha, step = 1000, win = 20e3, output = 1, genplot = FALSE, verbose = FALSE))

  full_ehas |> write_rds("out/full_slns_eha.rds")
#+end_src

this is too big and crashes R

#+begin_src R
  full_ehas <- read_rds("out/full_slns_eha.rds")

  tidy_eha <- full_ehas |>
    filter(sol == "ZB20a") |>
    select(-data) |>
    unnest(eha) |>
    unnest(eha)

    ## pivot_longer(cols = X10000:X290000, names_to = c("x", "slice"), names_pattern = "(X)(.*)") |>
    ## select(-x) |>
    ## mutate(slice = str_replace(slice, "e.0", "e")) |>
    ## mutate(slice = parse_double(slice))

  ggplot() +
    geom_raster(data = tidy_eha,
                aes(x = freq, y = ))
    ggplot(aes(x = freq, y = slice, fill = value)) +
    geom_raster() +
    scale_fill_viridis_c()
#+end_src
** bandpass filters on astronomical solutions
:PROPERTIES:
:CREATED:  [2023-11-14 Tue 16:31]
:END:
#+begin_src R :eval never
  ## source("R/functions.R") # this is just to make debugging easier
  # test individual bp
  slns[slns$sln == "ZB18a", ] |>
    bandpass_filter(frequencies = my_filt_age |> filter(target != "prec"),
                    x = age, y = ecc)
#+end_src

#+begin_src R :eval never
  sln_filters <- slns |>
      nested_bandpass_filter(frequencies = my_filt_age |> filter(target != "prec"),
                      x = age, y = ecc,
                      nest = "sln")
#+end_src

#+RESULTS:

#+begin_src R
  sln_filters <- read_rds("out/sln_filters.rds")
#+end_src

#+RESULTS:

#+begin_src R :eval never
  sln_filters_vln <- full_slns |>
    nested_bandpass_filter(frequencies = tibble(target = "2 Myr", p = 2000, f = 1 / p, range = 0.6 * f, flow = f - range, fhigh = f + range, ref = "This study"),
                           x = age, y = ecc, nest = "sol") |>
    write_rds("out/sln_filters_vln.rds")
#+end_src

#+begin_src R
  sln_filters_vln <- read_rds("out/sln_filters_vln.rds")
#+end_src

#+RESULTS:

** taner filter on astronomical solutions
:PROPERTIES:
:CREATED:  [2024-03-20 Wed 14:48]
:END:
#+begin_src R :eval never
  sln_taner_filters <- slns |>
    nested_taner_filter(frequencies = my_filt_age |> filter(target != "23 kyr"),
                        x = age, y = ecc,
                        padfac = 5,
                        roll = 1e10,
                        xmax = 0.03,
                        genplot = FALSE, verbose = FALSE,
                        nest = "sln") |>
    write_rds("out/sln_taner_filters.rds")
#+end_src

#+begin_src R
  sln_taner_filters <- read_rds("out/sln_taner_filters.rds")
#+end_src

#+RESULTS:

#+begin_src R :eval never
  sln_taner_filters_vln <- full_slns |>
    nested_taner_filter(frequencies = tibble(target = "2 Myr",
                                             p = 2000,
                                             f = 1 / p,
                                             range = 0.6 * f,
                                             flow = f - range,
                                             fhigh = f + range,
                                             ref = "This study"),
                        x = age, y = ecc,
                        roll = 1e12,
                        genplot = FALSE, verbose = FALSE,
                        nest = "sol") |>
    write_rds("out/sln_taner_filters_vln.rds")
#+end_src

#+begin_src R
  sln_taner_filters_vln <-   read_rds("out/sln_taner_filters_vln.rds")
#+end_src

** COMMENT geom_area slow
:PROPERTIES:
:CREATED:  [2024-03-20 Wed 15:29]
:END:
#+begin_src R
  library(ggplot2)
  library(tibble)

  dat <- tibble(
    x = 1:1e4,
    y = rnorm(seq_along(x)) + 5
  )

  dat |>
    ggplot() +
    geom_area(aes(x = x, y = y), position = "identity")

  dat |>
    ggplot() +
    geom_ribbon(aes(x = x, ymin = 0, ymax = y))

  # they seem identical
  res <- bench::mark(
    area = dat |>
      ggplot() +
      geom_area(aes(x = x, y = y)),
    ribbon = dat |>
      ggplot() +
      geom_ribbon(aes(x = x, ymin = 0, ymax = y)),
    check = FALSE)

  # until you actually print them!
  res <- bench::mark(
    area = dat |>
      ggplot() +
      geom_area(aes(x = x, y = y)) |> print(), # sloooww
    ribbon = dat |>
      ggplot() +
      geom_ribbon(aes(x = x, ymin = 0, ymax = y)) |> print(), # fast
    check = FALSE)

  # geom_area seems to get many more gc/sec?
  res
#+end_src
** get 405 kyr minima ages for each solution
:PROPERTIES:
:CREATED:  [2023-11-14 Tue 16:36]
:END:
I use these as tie-points for the tuning of the 405 kyr cycle.
#+begin_src R :results output
  sln_peaks <- sln_taner_filters |>
    tidylog::filter(target == "405 kyr") |>
    mutate(filter = -filter) |> # we want MINIMA rather than maxima
    nest(.by = sln) |>
    mutate(pk = map(data, ~ .x |>
                            select(age, filter) |>
                            astrochron::peak(level = -.030, genplot = FALSE) |>
                            as_tibble() |>
                            select(age = Location, peak_value = Peak_Value))) |>
    unnest(pk) |>
    select(-data)
#+end_src

#+RESULTS:
#+begin_example
filter: removed 192,007 rows (50%), 192,007 rows remaining

----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
 ,* Number of data points= 60000
 ,* Number of columns= 2
 ,* Identifying maxima of peaks
 ,* Number of peaks identified= 60
 ,* Filtering peaks at threshold of -0.03
 ,* Number of peaks >= -0.03 : 60

----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
 ,* Number of data points= 15001
 ,* Number of columns= 2
 ,* Identifying maxima of peaks
 ,* Number of peaks identified= 60
 ,* Filtering peaks at threshold of -0.03
 ,* Number of peaks >= -0.03 : 60

----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
 ,* Number of data points= 15001
 ,* Number of columns= 2
 ,* Identifying maxima of peaks
 ,* Number of peaks identified= 60
 ,* Filtering peaks at threshold of -0.03
 ,* Number of peaks >= -0.03 : 60

----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
 ,* Number of data points= 15001
 ,* Number of columns= 2
 ,* Identifying maxima of peaks
 ,* Number of peaks identified= 60
 ,* Filtering peaks at threshold of -0.03
 ,* Number of peaks >= -0.03 : 60

----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
 ,* Number of data points= 15001
 ,* Number of columns= 2
 ,* Identifying maxima of peaks
 ,* Number of peaks identified= 60
 ,* Filtering peaks at threshold of -0.03
 ,* Number of peaks >= -0.03 : 60

----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
 ,* Number of data points= 24001
 ,* Number of columns= 2
 ,* Identifying maxima of peaks
 ,* Number of peaks identified= 59
 ,* Filtering peaks at threshold of -0.03
 ,* Number of peaks >= -0.03 : 59

----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
 ,* Number of data points= 24001
 ,* Number of columns= 2
 ,* Identifying maxima of peaks
 ,* Number of peaks identified= 59
 ,* Filtering peaks at threshold of -0.03
 ,* Number of peaks >= -0.03 : 59

----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
 ,* Number of data points= 24001
 ,* Number of columns= 2
 ,* Identifying maxima of peaks
 ,* Number of peaks identified= 59
 ,* Filtering peaks at threshold of -0.03
 ,* Number of peaks >= -0.03 : 59
#+end_example

** get 2 Myr minima ages for each solution
#+begin_src R :results output
  sln_peaks_vln <- sln_filters_vln |>
    mutate(filter = -filter) |> # we want MINIMA rather than maxima
    nest(.by = sol) |>
    mutate(pk = map(data, ~ .x |>
                            select(age, filter) |>
                            astrochron::peak(genplot = FALSE, verbose = FALSE) |>
                            as_tibble() |>
                            select(age = Location, peak_value = Peak_Value))) |>
    unnest(pk) |>
    select(-data)
#+end_src


#+begin_src R
  sln_taner_peaks_vln <- sln_taner_filters_vln |>
    mutate(filter = -ecc) |> # we want MINIMA rather than maxima
    nest(.by = sol) |>
    mutate(pk = map(data, ~ .x |>
                            select(age, filter) |>
                            astrochron::peak(genplot = FALSE, verbose = FALSE) |>
                            as_tibble() |>
                            select(age = Location, peak_value = Peak_Value))) |>
    unnest(pk) |>
    select(-data)
#+end_src

#+RESULTS:

** SOME filter g3 g2 and combine?
:LOGBOOK:
- State "SOME"       from              [2024-02-29 Thu 15:52]
:END:

** SOME do wavelet on h directly, like Fig 2 of [cite:@ZeebeLourens2019]
:LOGBOOK:
- State "SOME"       from              [2024-02-29 Thu 15:52]
:END:

** K/Pg (K/T) boundary ages
:PROPERTIES:
:CREATED:  [2023-11-10 Fri 13:40]
:END:
These depend on the AS you choose! Got these from table 4 of [cite:@ZeebeLourens2022EPSL].

#+begin_src R
  kpg_ages <- tribble(
    ~ sln, ~ age1, ~ age2,
    ## "La10a", 65.96, 65.96
    "La10b", 65.95, 65.96,
    "La10c", 65.95, 65.96,
    ## "La10d", 66.01, 66.01
    "La11", 66.01, 66.02,

    "ZB18a", 65.94, 65.96,
    "ZB20a", 65.92, 65.92,
    # currently don't need the others yet
    "ZB20b", 65.92, 65.92,
    "ZB20c", 65.92, 65.93,
    "ZB20d", 65.95, 65.96,
  )
#+end_src

#+RESULTS:

* plot astronomical solutions
:PROPERTIES:
:CREATED:  [2023-10-03 Tue 14:51]
:END:
In this study we focus on those astronomical solutions that showed the best compatibility with the Walvis Ridge datasets for the Paleocene [cite:@ZeebeLourens2022EPSL].. This includes La10b, La10c, ZB18a, and ZB20a (cref:fig:astronomical-solutions).

# #+begin_src R :results output graphics file :file imgs/orbital_solutions.png :width 2400 :height 1200 :res 300 :exports both

#+begin_src R :results output graphics file :file imgs/orbital_solutions.pdf :width 20 :height 2
  sln_taner_filters |>
    ## filter(sln != "La11") |>
    ## filter(target != "23 kyr") |>
    filter(target == "405 kyr") |>
    ## filter(sln == "ZB18a") |>
    ggplot(aes(x = -age * 1e-3, y = ecc)) +
    labs(x = "Time (Myr)", y = "Eccentricity (-)") +
    ## facet_grid(rows = vars(sln)) +
    ## scale_x_continuous(breaks = seq(65, 66 + 13 * .405, 1)) +
    ## coord_cartesian(xlim = c(66 + 13*.405, 65)) +
    # double-check that linear interpolation went ok
    ## geom_line(linewidth = 1.2, alpha = .3, data = slns) +
    ## scale_colour_manual(values = c("100 kyr" = "orange",
    ##                                "405 kyr" = "navyblue",
    ##                                "2 Myr" = "darkgreen",
    ##                                "ecc_construct" = "purple")) +
    ## geom_line(aes(group = sln), alpha = .3, colour = "black") +
    geom_line(aes(y = filter, colour = sln, group = paste(sln, target)),
              alpha = .6,
              linewidth = 1) +
    scale_colour_brewer(type = "qual", palette = 3) +
    ## geom_line(aes(colour = sln), alpha = .6, linewidth = 1,
    ##           data = sln_taner_filters |>
    ##             filter(sln != "La11") |>
    ##             # we don't use construct_eccentricity here because we don't want to scale
    ##             pivot_wider(id_cols = c("sln", "age"), names_from = "target", values_from = "filter") |>
    ##             mutate(ecc = `405 kyr` + `100 kyr`, target = "ecc_construct"))
    ## geom_line(aes(y = filter, colour = target),
    ##           alpha = .6,
    ##           linewidth = 2,
    ##           data = sln_filters_vln |>
    ##             filter(sln != "La11")) #+
    ## contrast to taner filter
    ## geom_line(aes(y = ecc, group = target),
    ##           linewidth = .1,
    ##           data = sln_taner_filters |> filter (sln != "La11"))
    #
    geom_point(aes(x = -age * 1e-3, y = 0, colour = sln),
               data = sln_peaks ## |> filter(sln != "La11")
               )
    ## geom_point(aes(x = age / 1000, y = 0), colour = "gold", size = 3,
    ##            data = sln_peaks_vln |> filter(sln != "La11")) +
    ## geom_vline(aes(xintercept = age1),
    ##            data = kpg_ages |> filter(sln != "La11")) +
    ## geom_vline(aes(xintercept = age2),
    ##            data = kpg_ages |> filter(sln != "La11"))
    # add agem_sol points, if they're available!
    ## geom_point(aes(y = 0), colour = "black", data = agem_sol |> rename(sln = sol)) +
#+end_src

#+name: fig:astronomical-solutions
#+caption: Example time slice of the different astronomical solutions with 405 kyr and 100 kyr filters (frequencies \pm40%, e.g. 0.6 * 1/405 to 1.4 * 1/405).
#+RESULTS:
[[file:imgs/orbital_solutions.pdf]]

* what are the differences between 405-kyr minima?
:PROPERTIES:
:CREATED:  [2024-04-18 Thu 12:45]
:END:
#+begin_src R
  sln_peaks |>
    ## filter(sln != "La11") |>
    # make sure to select proper boundaries!
    ## filter(age > 65.8e3 & age < 66e3) |>
    filter(age > 71e3 & age < 71.5e3) |>
    filter(age == max(age) | age == min(age)) |>
    mutate(diff(age))
#+end_src

#+RESULTS:
: # A tibble: 2 × 4
:   sln      age peak_value `diff(age)`
:   <chr>  <dbl>      <dbl>       <dbl>
: 1 ZB20a 71125.    -0.0169        85.2
: 2 La10c 71210     -0.0144        85.2

* plot the difference between VLN ages
:PROPERTIES:
:CREATED:  [2024-02-27 Tue 16:47]
:END:
#+begin_src R :results output graphics file :file imgs/VLN_ages.png :width 4600 :height 1200 :res 300
  ## sln_peaks_vln |>
  sln_taner_peaks_vln |>
    mutate(diffs = (age - lag(age)) * 1e-3, .by = sol) |>
    ggplot(aes(x = -age * 1e-3, y = diffs, colour = sol)) +
    scale_x_continuous(breaks = seq(-300, 0, 20),
                    minor_breaks = seq(-300, 0, 10)) +
    scale_colour_brewer(type = "qual", palette = 3) +
    ## facet_grid(rows = vars(sol)) +
    labs(x = "Simulated Time (Myr)",
         y = "Interval between min in 2-Myr ecc filter (Myr)",
         colour = "Astronomical Solution") +
    geom_line() +
    # how you filter has quite the influence
    ## geom_line(data = sln_peaks_vln |>
    ##             mutate(diffs = (age - lag(age)) * 1e-3, .by = sol)) +
    geom_point()
#+end_src

#+RESULTS:
[[file:imgs/VLN_ages.png]]

* COMMENT reproduce Ma et al., 2017 steps
:PROPERTIES:
:CREATED:  [2023-08-28 Mon 10:52]
:END:
[cite:@Ma2017] .
Load the R package Astrochron
This analysis uses version 0.6.6. Please use versions >= 0.6.6.

#+begin_src R
  library(astrochron)
#+end_src

#+RESULTS:
: Welcome to astrochron v1.2 (2023-08-25)
:  Type ?astrochron to learn more

** read in data
Read the Libsack FMI data from Locklair & Sageman (2008)
This should be a comma-separated-value file (.csv), with first column as depth
    (meters) and second column as FMI.

#+begin_src R
  FMI <- read("dat/Ma2017/data.csv")
#+end_src

** interpolate to median sampling interval
This data set has a sampling interval
that ranges from 0.030478 to 0.030479 m. Interpolate the data to a sampling interval of 0.03 m.

#+begin_src R
  FMI_0.03 <- linterp(FMI, dt = 0.03)
#+end_src

** Tune the FMI record using the long-eccentricity cycle
*** bandpass filter long eccentricity
Extract Locklair & Sageman’s (2008) long-eccentricity cycle using bandpass filtering.

#+begin_src R
  longEcc <- bandpass(FMI_0.03, flow = 0.14, fhigh = 0.26, xmax = 0.5, padfac = 5, win = 2, p = 0.66)
#+end_src

*** find the peak
Find the peak associated with each long eccentricity cycle.

#+begin_src R
  eccMax <- peak(longEcc)
#+end_src

*** construct floating time
Construct the floating time (elapsed time) vs. core depth map for tuning.

#+begin_src R
  timeControl <- cb(eccMax[, 2], (0:18) * 405)

  plot(timeControl, type = "l", lwd = 2, xlab = "Depth (m)", ylab = "Elapsed Time (ka)")
#+end_src

*** tune
Tune (the original FMI data) using the time vs. core depth map.

#+begin_src R
  tuned <- tune(FMI, timeControl, extrapolate = TRUE)
#+end_src

** interpolate
This tuned data set has a sampling interval that ranges from 1.714387 to
3.774922 ka. Interpolate the tuned data to the median sampling interval of ~2.5
ka.

#+begin_src R
  tuned_2.5 <- linterp(tuned, dt = 2.5)
#+end_src

** anchor to radioisotopic age
Convert result from floating (elapsed) time to radioisotopically-anchored
time, using the nominal radioisotopic anchoring (S.p. ammonite biozone). The
radioisotopic age, and its depth in the Libsack core, come from Table 1.

#+begin_src R
  anchorAt <- resample(timeControl, xout = 2147.62, genplot=FALSE)[, 2]
  anchored <- anchorTime(tuned_2.5, time = anchorAt, age = 89370, timeDir = 2)
#+end_src

*** plot
Now create a plot of radioisotopically-anchored time vs. depth.
#+begin_src R
  timeDepth <- tuned
  timeDepth[2] <- FMI[1]
  anchoredTimeDepth <- anchorTime(timeDepth, time = anchorAt, age = 89370, timeDir = 2, genplot = FALSE)

  pl(1);
  plot(anchoredTimeDepth,
       type = "l", lwd = 2, col = "red",
       ylim = c(max(FMI[1]), min(FMI[1])),
       xlab = "Time (ka)", ylab = "Depth (m)",
       cex.lab = 1.2)
#+end_src

*** create basic plot using ggplot
#+begin_src R
  library(ggplot2)
  library(patchwork)
  library(dplyr)

  pl_FMI <- FMI |>
    tibble::as_tibble() |>
    ggplot(aes(x = Depth_m, y = FMI_ohm.m)) +
    geom_line() +
    labs(x="Depth (m)",
         y = "FMI"~Ohm~"(m)")
  pl_anchored <- anchored |>
    tibble::as_tibble() |>
    rename(Time_ka = X1, FMI_ohm.m = X2) |>
    ggplot(aes(x = Time_ka/1e3, y = FMI_ohm.m)) +
    geom_line() +
    scale_x_continuous(
      breaks = 80:92,
      minor_breaks = seq(80, 92, 0.1)) +
    labs(x = "Age (Ma)",
         y = "FMI Ohm (m)") # not sure if this is what it is.
  pl_FMI/pl_anchored
#+end_src

** EPSA/EHA
Conduct evolutive power spectral analysis (EPSA) and evolutive harmonic analysis (EHA)
for the tuned & anchored FMI data using a 500-ka moving window (with linear trend
removal), and three 2pi prolate tapers. Plot amplitude normalized to unity
(for each window) to reveal changes in relative strength.

#+begin_src R
  pwr <- eha(anchored, win = 500, fmax = .1, output = 2, pl = 1,
             pad = 5000, genplot = 3, ydir = -1,
             xlab = "Frequency (cycles/ka)", ylab = "Age (ka)")
#+end_src

** power modulation of obliquity
Determine power modulation of obliquity terms using EPSA results. Integrate
the obliquity power from 0.018 to 0.037 cycles/ka.

#+begin_src R
  integrate_obl <- integratePower(pwr, flow = 0.018, fhigh = 0.037,
                                  npts = 201, pad = 5000, ln = TRUE,
                                  ydir = -1)
#+end_src

** power modulation of short ecc
Determine power modulation of short eccentricity terms.
Integrate the short eccentricity power from 0.007 to 0.012 cycles/ka.

#+begin_src R
  integrate_ecc <- integratePower(pwr, flow = 0.007, fhigh = 0.012,
                                  npts = 201, pad = 5000, ln = TRUE,
                                  ydir = -1)
#+end_src

** amplitude modulation of long ecc
Evaluate amplitude modulation of the long eccentricity term (405 ka), following
removal of bias associated with long-term (>1 Myr) variance, using Lowess.

# note: win = 2 means a cosine-tapered (Tukey) window
#+begin_src R
  longEcc2 <- bandpass(noLow(anchored, 0.1, genplot = FALSE),
                       flow = .002, fhigh = .0035,
                       win = 2, p = 0.66, padfac = 5, xmax = .02)

  hilEcc2 <- hilbert(longEcc2, addmean=TRUE)
#+end_src

** plot summary
Plot summary figures.
#+begin_src R
  xlim1 <- c(82707.41, 89932.41)
  pl(r = 3, c = 1)
  plot(cb(integrate_obl, c(1, 2)),
       type = "l", lwd = 2, col = "red",
       ylab = "Obliquity Band Power", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  plot(cb(integrate_ecc, c(1, 2)),
       type = "l", lwd = 2, col = "red",
       ylab = "Short-Eccentricity Band Power", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  plot(longEcc2, type = "l", lwd = 2, col = "red",
       ylab = "Long-Eccentricity Bandpass", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  lines(hilEcc2)
  pl(r = 3, c = 1)
  plot(cb(integrate_obl, c(1, 4)),
       type = "l", lwd = 2, col = "red",
       ylab = "Obliquity/Total Power", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  plot(cb(integrate_ecc, c(1, 4)),
       type = "l", lwd = 2, col = "red",
       ylab = "Short-Eccentricity/Total Power", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  plot(longEcc2, type = "l", lwd = 2, col = "red",
       ylab = "Long-Eccentricity Bandpass", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  lines(hilEcc2)
  pl(r = 3, c = 1)
  plot(cb(integrate_ecc, c(1, 2)),
       type = "l", lwd = 2, col = "red",
       ylab = "Short-Eccentricity Band Power", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  plot(cb(integrate_ecc, c(1, 4)),
       type = "l",lwd = 2, col = "red",
       ylab = "Short-Eccentricity/Total Power", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  plot(longEcc2,
       type = "l", lwd = 2, col = "red",
       ylab = "Long-Eccentricity Bandpass", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  lines(hilEcc2)
#+end_src

* COMMENT read ZL2019 and ZL2023EPSL to reproduce their approach
:PROPERTIES:
:CREATED:  [2023-08-28 Mon 11:56]
:END:
:LOGBOOK:
CLOCK: [2023-08-28 Mon 17:02]--[2023-08-28 Mon 17:10] =>  0:08
CLOCK: [2023-08-28 Mon 14:55]--[2023-08-28 Mon 17:02] =>  2:07
- try to reproduce, cannot figureit out?
CLOCK: [2023-08-28 Mon 14:10]--[2023-08-28 Mon 14:55] =>  0:45
- do 2.4 Myr analysis on ZB18a
CLOCK: [2023-08-28 Mon 11:20]--[2023-08-28 Mon 12:08] =>  0:48
:END:
[cite:@ZeebeLourens2019;@ZeebeLourens2022EPSL].

Richard's code
#+begin_src matlab
f  = 1./2000;
df = 0.6;

yf{i} = gaussfilter(t{i},y{i},f,df*f,2*df*f,0.0);

[~,ix{i}] = findpeaks(-yf{i});
kv = ix{i};
dt{i} = diff(t{i}(kv));
#+end_src


#+begin_src R
  library(tidyverse)

  # get orbital solution sol
  sol <- snvecR::get_ZB18a() |>
    select(age, ee)

  # Do the same as Zeebe and Lourens 2022:
  # filter 2 Myr ± 60% Gaussian
  # 2 Myr = 2000 kyr period = 1 / 2000 period
  x11(type = "cairo")

  bp2000 <- sol |>
    astrochron::bandpass(
                  padfac = 10, # 10x the number of data points
                  # parameterized as I understand Richard's matlab code
                  # this doesn't make any sense to me
                  ## flow = 0.6 * 1 / 2000,
                  ## fhigh = 2 * 0.6 * 1 / 2000,
                  flow = 1 / 2000 - 0.6 * 1 / 2000,
                  fhigh = 1 / 2000 + 0.6 * 1 / 2000,
                  win = 1, # Gaussian window
                  ## win: Window type for bandpass filter: 0 = rectangular , 1=
                  ## Gaussian, 2= Cosine-tapered window (a.k.a. Tukey window).
                  demean = TRUE, detrend = TRUE,
                  addmean = FALSE,
                  xmax = .02)

  grDevices::savePlot("imgs/2023-08-28_0_2Myr_bandpass_filter.png")

  # get the peak maxima
  pk2000 <- bp2000 |>
    astrochron::peak()

  grDevices::savePlot("imgs/2023-08-28_1_peak.png")

  # but in the paper they do peak minima, we just flip the input
  pk2000_flip <- bp2000 |>
    mutate(ee = -ee) |>
    astrochron::peak(genplot = TRUE)

  grDevices::savePlot("imgs/2023-08-28_2_peak.png")

  # calculate deltas between peaks
  pk2000_tidy <- pk2000 |>
    as_tibble() |>
    # different ways to calculate the delta
    mutate(delta_vln_lag = Location - lag(Location)) |> # this one minus previous one
    mutate(delta_vln = lead(Location) - Location) # next one minus this one
  pk2000_flip_tidy <- pk2000_flip |>
    as_tibble() |>
    mutate(delta_vln_lag = Location - lag(Location)) |>
    mutate(delta_vln = lead(Location) - Location)

  # check that peak id has gone well
  bp2000 |>
    ggplot(aes(x = age, y = ee)) +
    geom_line() +
    geom_point(aes(x = Location, y = Peak_Value, colour = "maxima"), data = pk2000_tidy) +
    geom_point(aes(x = Location, y = -Peak_Value, colour = "minima"), data = pk2000_flip_tidy)

  ggsave("~/SurfDrive/Postdoc1/prj/2023-05-19_cretaceous/imgs/2023-08-28_3_check_peaks.png")

  # create a plot similar to Zeebe and Lourens 2022 EPSL figure 6a
  pk2000_tidy |>
    ggplot(aes(x = Location / 1000, y = delta_vln / 1000)) +
    ## geom_point(aes(colour = "maxima lead")) +
    ## geom_line(aes(colour = "maxima lead")) +
    geom_point(aes(colour = "minima lead"), data = pk2000_flip_tidy) +
    geom_line(aes(colour = "minima lead"), data = pk2000_flip_tidy) +
    # did they use the half-distance? nope
    ## geom_point(aes(x = (Location + .5 * (lead(Location) - Location)) / 1000, colour = "minima lead"), data = pk2000_flip_tidy) +
    ## geom_line(aes(x = (Location + .5 * (lead(Location) - Location)) / 1000, colour = "minima lead"), data = pk2000_flip_tidy) +
    ## geom_point(aes(y = delta_vln_lag / 1000, colour = "maxima lag")) +
    ## geom_line(aes(y = delta_vln_lag / 1000, colour = "maxima lag")) +
    ## geom_point(aes(y = delta_vln_lag / 1000, colour = "minima lag"), data = pk2000_flip_tidy) +
    ## geom_line(aes(y = delta_vln_lag / 1000, colour = "minima lag"), data = pk2000_flip_tidy) +
    labs(x = "Age (Ma)",
         y = Delta[VLN] ~ "Interval between min/max in 2-Myr ecc filter (Myr)") +
    scale_x_continuous(breaks = seq(40, 80, 5)) +
    coord_cartesian(xlim = c(44, 70), ylim = c(0, 3))

  ggsave("imgs/2023-08-28_4_Dvln.png", width = 8, height = 3)
  ## ggsave("~/SurfDrive/Postdoc1/prj/2023-05-19_cretaceous/imgs/2023-08-28_4_Dvln.png")
#+end_src

#+RESULTS:
#+begin_example

----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----
 ,* Number of data points= 250001
 ,* Sample interval= 0.4
 ,* Mean value removed= 0.02683078
 ,* Center of bandpass filter = 5e-04
 ,* 600 pos/neg frequency pairs will be bandpassed

----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
 ,* Number of data points= 250001
 ,* Number of columns= 2
 ,* Identifying maxima of peaks
 ,* Number of peaks identified= 50

 ,* No filtering of peaks applied.

----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
 ,* Number of data points= 250001
 ,* Number of columns= 2
 ,* Identifying maxima of peaks
 ,* Number of peaks identified= 51

 ,* No filtering of peaks applied.
Saving 7 x 6.99 in image
Warning messages:
1: Removed 1 rows containing missing values (`geom_point()`).
2: Removed 1 row containing missing values (`geom_line()`).
Warning messages:
1: Removed 1 rows containing missing values (`geom_point()`).
2: Removed 1 row containing missing values (`geom_line()`).
#+end_example

** filter orbital solutions
#+begin_src R
  # test whether filtering is the same for comparison with Zeebe and Lourens 2022 EPSL fig B2
  ## ZB20a <- readr::read_table("http://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro/300Myr/ZB20a.dat",
  ##                            col_names = c("time", "ecc", "inc"), skip = 1) |>
  ##   readr::write_rds("out/ZB20a.rds")
  ZB20a <- readr::read_rds("out/ZB20a.rds")

  ZB20a |>
    ggplot(aes(x = time / 1000, y = ecc)) +
    geom_line() +
    coord_cartesian(xlim = c(63, 66))


  ZB20a_bp100 <- ZB20a |>
    astrochron::bandpass(flow = 1 / 100 - 0.0016 * 1 / 100,
                         fhigh = 1 / 100 + 0.0016 * 1 / 100,
                         padfac = 1000,
                         win = 1,
                         demean = TRUE, detrend = TRUE)

  # this is how Richard filters the 405 kyr cycle in his solution
  ZB20a_bp405 <- ZB20a |>
    select(time, ecc) |>
    astrochron::bandpass(flow = 1 / 405 - 0.0004,
                         fhigh = 1 / 405 + 0.0004,
                         padfac = 10,
                         win = 1, # gaussian window
                         demean = TRUE, detrend = TRUE,
                         xmax = 0.005) |>
    as_tibble()

  ZB20a_bp405_narrower <- ZB20a |>
    select(time, ecc) |>
    astrochron::bandpass(flow = 1 / 405 - 0.0001,
                         fhigh = 1 / 405 + 0.0001,
                         padfac = 10,
                         win = 1, # gaussian window
                         demean = TRUE, detrend = TRUE,
                         xmax = 0.005) |>
    as_tibble()

  ZB20a_bp405_wider <- ZB20a |>
    select(time, ecc) |>
    astrochron::bandpass(flow = 1 / 405 - 0.001,
                         fhigh = 1 / 405 + 0.001,
                         padfac = 10,
                         win = 1, # gaussian window
                         demean = TRUE, detrend = TRUE,
                         xmax = 0.005) |>
    as_tibble()

  ZB20a_bp405_widest <- ZB20a |>
    select(time, ecc) |>
    astrochron::bandpass(flow = 1 / 405 - 0.0024,
                         fhigh = 1 / 405 + 0.0024,
                         padfac = 10,
                         win = 1, # gaussian window
                         demean = TRUE, detrend = TRUE,
                         xmax = 0.005) |>
    as_tibble()

  ZB20a_bp405 |>
    mutate(filt="default") |>
    bind_rows(
      ZB20a_bp405_narrower |>
      mutate(filt="narrower")) |>
    bind_rows(
      ZB20a_bp405_wider |>
      mutate(filt="wider")) |>
    bind_rows(
      ZB20a_bp405_widest |>
      mutate(filt = "widest")) |>
    ggplot(aes(x=time,y=ecc, colour = filt)) +
    geom_line() +
    geom_line(aes(colour="ZB18a default"), data = bp405 |> rename(time = age, ecc = ee)) +
    geom_line(aes(colour = "ZB20a raw"), alpha = .3, data = ZB20a) +
    geom_line(aes(colour = "ZB18a raw"), alpha = .3, data = snvecR::get_ZB18a() |> select(time = age, ecc = ee)) +
    coord_cartesian(xlim=c(65400, 74200))
#+end_src

#+begin_src R
  # everything below is a big hot mess!

  bp405 <- sol |>
    ## filter(age < 50e3) |>
    astrochron::bandpass(flow = 1 / 405 - .0004,
                         fhigh = 1 / 405 + .0004,
                         padfac = 10,
                         win = 1,
                         demean = TRUE, detrend = TRUE,
                         xmax = .02)

  ## eha405 <- snvecR::get_ZB18a() |>
  ##   select(age, ee) |>
  ##   astrochron::eha(fmax = .1, pl = 1, output = 2, pad = 5000, genplot = 3, ydir = -1)

  ## integrate_ecc <- eha405 |>
  ##   astrochron::integratePower(flow = 0.007, fhigh = 0.012,
  ##                              npts = 201, pad = 5000, ln = TRUE,
  ##                              ydir = -1)

  ## bp405_2 <- sol |>
  ##   noLow(smooth = 1000, genplot = TRUE) |>
  ##   bandpass(flow = .002, fhigh = .0035,
  ##            win = 2, p = 0.66, padfac = 5, xmax = .02)

  ## hb405_2 <- bp405_2 |>
  ##   astrochron::hilbert()

  hb405 <- bp405 |>
    astrochron::hilbert()

  # this doesn't work well on the hilbert transform, finds many peaks because of noise?
  pk405 <- hb405 |>
    astrochron::peak()

  pkf405 <- pk405 |>
    as_tibble() |>
    tidylog::mutate(diff = Location - lag(Location)) |>
    ## ggplot(aes(x = Location, y = diff)) + geom_point()
    tidylog::filter(diff > 500) #|>
    ## tidylog::filter(Location > 4000) |> # filter out youngest weird few
    ## tidylog::filter(Location < 93e3)
    ## tidylog::filter(!ID %in% c(142107, 17355, 174355, 203304, 225749))

  pkf405 |>
    ggplot(aes(x = Location, y = diff)) + geom_point() + geom_line()

  pkf405 |>
    ggplot(aes(x = Location, y = Peak_Value, ID = ID)) +
    geom_point() +
    geom_line(aes(x = age, y = ee - mean(ee), ID = NULL), data = bp405)
    ## geom_line(aes(x = age, y = envelope, ID = NULL), data = hb405_2)

  pkf405 |>
    ggplot(aes(x = diff)) +
    ## geom_histogram(binwidth = 1000) +
    geom_density()
#+end_src

** how can I calculate the average spectral misfit?
:PROPERTIES:
:CREATED:  [2023-08-28 Mon 17:14]
:END:

* Datasets from the Literature
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 12:48]
:END:
Sorted from young to older, longest records at the end.

Might need to filter/reorder when I'm writing the paper

** [#C] IODP Leg 208 Site 1262
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 16:37]
:END:
Colour reflectance a* used in [cite:@ZeebeLourens2019].

d13C/d18O available in https://doi.pangaea.de/10.1594/PANGAEA.854816
53 Ma to 58 Ma
[[https://web.iodp.tamu.edu/janusweb/imaging/photo.cgi][section photo's]]

Colour reflectance a*/b* used in [cite:@ZeebeLourens2022EPSL]
in combination with site 1209, Zumaia
56 Ma to 66 Ma

[[http://www-odp.tamu.edu/publications/208_IR/chap_03/chap_03.htm][initial reports]]

http://web.iodp.tamu.edu/OVERVIEW/
ah here it is:
https://web.iodp.tamu.edu/janusweb/physprops/colordat.cgi?leg=208&site=1262

or search for it via https://web.iodp.tamu.edu/janusweb/physprops/colordat.shtml
figure from initial reports: http://www-odp.tamu.edu/publications/208_IR/chap_03/c3_f9.htm

get conversion between MBSF and MCD here http://web.iodp.tamu.edu/OVERVIEW/?&exp=208&site=1263

figure of conversion between MBSF and MCD, 3 linear fits for different holes

http://www-odp.tamu.edu/publications/208_IR/chap_03/c3_f5.htm

I'm not going to put too much effort in, Richard should have this analysis according to Luc.

K/T depth @ 216.7 mcd

#+begin_src R :results output graphics file :file imgs/208-1262_color_ZeebeLourens2019-2022.png :width 900 :height 500
  ODP208_1262_col <- readr::read_tsv("dat/ODP208_1262_color_reflectance.dat",
                                     guess_max = 3000)
  # add MCD
  spl <- readr::read_tsv("dat/ODP208_1262_splice.dat")
  spl_tie <- readr::read_tsv("dat/ODP208_1262_splice_tie.dat")

  # add preliminary age model
  wr_agem <- readxl::read_excel("dat/ZeebeLourens2022EPSL/agem.xlsx",
                             range = "A3:K29")

  ODP208_1262_col |>
    ggplot(aes(x = `Depth (mbsf)`, y = scale(`a*` / `b*`)[, 1])) +
    geom_line() +
    geom_vline(xintercept = 216.7) +
    coord_cartesian(xlim = c(140, 220))
#+end_src

#+caption: *Colour reflectance data from ODP 208 Site 1262*. used in [cite:@ZeebeLourens2019].
#+RESULTS:
[[file:imgs/208-1262_color_ZeebeLourens2019-2022.png]]
** [#A] Hendaye
:PROPERTIES:
:CREATED:  [2023-09-18 Mon 16:42]
:END:
via [[id:107d5e85-9f0d-4193-941d-7b8887fa4d28][Frits Hilgen]]
[[mu4e:msgid:AS8PR05MB10601D055071F8CD08F7C0153DBFBA@AS8PR05MB10601.eurprd05.prod.outlook.com][RE: Paper: Earth beyond six of nine planetary boundaries]]
66 Ma until 64 Ma

Multi-proxy study of the interval from the K/T boundary up to cycle 20 of [cite:@Dinares-Turell2003].

Only photos for now.
Linked to Zumaia, but no turbidites

#+caption: Hendaye tuning options with 200 kyr pattern (sent to me by Frits Hilgen, unpublished). He's now playing this visual game with the ZB18 and ZB20 solutions!
[[file:imgs/Hendaye_tuning_Frits-Hilgen.pdf::3]]

Shows expression of weak 200 kyr eccentricity cycle and oldest node of 2-Myr cycle
Frits thinks this wasn't taken into account in ZL2022 b/c Luc didn't believe in the 200 kyr cycle.

Frits will send me a new Fish-Canyon paper draft, which argues that the ZB20a solution best matches the 200 kyr cycles just prior to the K/Pg boundary.

** [#C] IODP Leg 198 Site 1209
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 17:29]
:END:
56 Ma to 66 Ma

#+begin_src R :results output graphics file :file imgs/198-1209_color_ZeebeLourens2019-2022.png :width 900 :height 500
  ODP198_1209_col <- readr::read_tsv("dat/ODP198_1209_color_reflectance.dat")
  ## spl <- readr::read_tsv("dat/ODP198_1209_splice.dat")
  ## spl_tie <- readr::read_tsv("dat/ODP198_1209_splice_tie.dat")
  ODP198_1209_col |>
    ggplot(aes(x = `Depth (mbsf)`, y = `a*`)) +
    geom_line() +
    coord_cartesian(xlim = c(252.5, 261.6), ylim = c(1, 3))
#+end_src

#+caption: ODP 198 Site 1209 Colour reflectance used in [cite:@ZeebeLourens2022EPSL].
#+RESULTS:
[[file:imgs/198-1209_color_ZeebeLourens2019-2022.png]]

** Contessa highway section
:PROPERTIES:
:CREATED:  [2023-09-05 Tue 15:59]
:END:
[cite:@Sinnesael2016] https://doi.pangaea.de/10.1594/PANGAEA.864450

MS, CaCO3, d13C, d18O

uppermost Maastrichtian to lower Danian

62.5 Ma to 67 Ma

Combined with Bottaccione
#+begin_src R :results output graphics file :file imgs/Contessa_MS_Sinnesael2016.png :width 900 :height 500
  Contessa <- pangaear::pg_data("10.1594/PANGAEA.864450")[[1]]

  dat <- Contessa$data

  dat |>
    ggplot(aes(x = `Section [m]`, y = `chi [10**-9 m**3/kg]`)) +
    geom_line()
#+end_src

#+caption: Contessa Highway Magnetic Susceptibility from [cite:@Sinnesael2016].
#+RESULTS:
[[file:imgs/Contessa_MS_Sinnesael2016.png]]
** [#A] ODP Leg 208 Site 1267
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 12:49]
:END:
via [cite:@Husson2011] figure 3 and 4

Ma_{405}1 to Ma_{405}6 or 7

66 Ma to ~68.6

Raw magsus data from [cite:@Blum2005] https://doi.pangaea.de/10.1594/PANGAEA.266605

also related: [cite:@Zachos2004]

see also this nice paper, but it focuses on a too-young interval for our purposes! [cite:@Westerhold2017] 56--46 Ma

*** Magsus data
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 11:22]
:END:
analyzed similarly to [cite:@Husson2011]
- depth sed [m] from 0.05 to 329 m
- depth comp [mcd] from 0.05 to 368 m

208-1267B-1H-1,5 to 208-1267B-36X-7,37.5

#+begin_src R :results output :eval never
  # get hole A directly from Janus database:
  ODP208_1267_MS_A <- readr::read_tsv("https://web.iodp.tamu.edu/janusweb/physprops/msldat.cgi?leg=208&site=1267&hole=A",
                                      comment = "<",
                                      guess_max = 25000) |> # this comment gets rid of all the html headers
    filter(str_detect(Leg, "^208")) |> # this gets rid of some stuff at the bottom of the page
    readr::write_rds("out/ODP208_1267_MS_A.rds")

  ODP208_1267_MS_B <- readr::read_tsv("https://web.iodp.tamu.edu/janusweb/physprops/msldat.cgi?leg=208&site=1267&hole=B",
                                      comment = "<",
                                      guess_max = 25000) |> # this comment gets rid of all the html headers
    filter(str_detect(Leg, "^208")) |> # this gets rid of some stuff at the bottom of the page
    readr::write_rds("out/ODP208_1267_MS_B.rds")
   # so we have Depth (mbsf) and would like to convert it to the new rmcd
#+end_src

#+RESULTS:

#+begin_src R
  ODP208_1267_MS_A <- readr::read_rds("out/ODP208_1267_MS_A.rds")
  ODP208_1267_MS_B <- readr::read_rds("out/ODP208_1267_MS_B.rds")
#+end_src

#+RESULTS:

**** reproduce Husson Fig. 4
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 13:17]
:END:
[cite:@Husson2011] figure 4
#+begin_src R :results output graphics file :file imgs/208-1267B_MS_Husson-fig4.png :width 900 :height 500
  # somehow they also put these data on PANGAEA (I found this one first)
  # this is for hole B
  ODP208_1267_MS_B_pg <- pangaear::pg_data("10.1594/PANGAEA.266605")[[1]]

  ## ODP208_1267_MS$data |>
  ##   select(`Sample label`) |>
  ##   separate(`Sample label`, into = c("leg", "sitehole", "coretype", "sectioninterval"),
  ##            sep = "-") |>
  ##   separate(sectioninterval, into = c("section", "interval"), sep = ",") |>
  ##   separate(sitehole, into = c("site", "hole"), sep = 4) |>
  ##   separate(coretype, into = c("core", "type"), sep = -1) |>
  ##   write_csv("out/ODP208_1267_MS.csv")

  dat <- ODP208_1267_MS_B_pg$data |>
    select(
      depth = `Depth sed [m]`, # they use mbsf in Husson et al., 2011!!
      ## depth = `Depth comp [mcd]`,
      MS = `Suscept corr`) |>
    filter(depth >= 285.9)

  mtm <- dat |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::mtm(xmax = 10, pl = 1) |> # basically only ~40 cm cycles
    ## astrochron::lowspec(xmax = 10, pl = 1) |>
    as_tibble()
  abline(v = c(1.4, 1.6))

  f100_2 <- dat |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::bandpass(flow = 1.4, fhigh = 1.6, win = 1, padfac = 10)

  f100 <- dat |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::taner(flow = 0, fhigh = 0.9, xmax = 3) |>
    as_tibble()


  f405 <- dat |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::taner(flow = 0, fhigh = 0.25, xmax = 1) |>
    as_tibble()

  dat |>
    ggplot(aes(x = depth, y = MS)) +
    annotate("rect", xmin = 285.9, xmax = 286.5, ymin = -Inf, ymax = Inf,
             fill = "yellow", alpha = .6) + # the K/T boundary
    geom_line(colour = "darkblue") +
    geom_line(aes(y = MS + 50), data = f100, colour = "skyblue") +
    geom_line(aes(y = MS + 70), data = f405, colour = "black") +
    coord_cartesian(xlim = c(287.4, 330), ylim = c(0, 300)) +
    labs(x = "Depth (mbsf)", y = MS ~ "(10"^{-8} ~ "kgm"^{-3} * ")")

  ## dat <- ODP208_1267_MS_B_pg$data |>
    ## select(depth = `Depth comp [mcd]`, MS = `Suscept corr`) #|>
    ## filter(depth >= 285.9)

  ## dat |>
  ##   ggplot(aes(x = depth, y = MS)) +
  ##   geom_line()
#+end_src

#+caption: *ODP 208 Site 1267 MS* Reproduction of [cite:@Husson2011] Fig. 4.
#+RESULTS:
[[file:imgs/208-1267B_MS_Husson-fig4.png]]

*** [#B] convert from mbsf and mcd to rmcd
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 11:29]
:END:
see also [[file:~/SurfDrive/Postdoc1/prj/2023-05-19_cretaceous_constraints/cretaceous_constraints.org::*get_rmcd][get_rmcd]].

**** COMMENT 1267 rmcd to 1262 rmcd
#+begin_src R
  # https://doi.pangaea.de/10.1594/PANGAEA.666132
  # NO! This is 1267 rmcd vs 1262 mcd!!!
  rmcd <- pangaear::pg_data("10.1594/pangaea.666132")[[1]]$data
  # this only covers mcd 104--236
  # but I care only about depths in mbsf > ~285.9
  ## ODP208_1267_MS$data |>
  ##   filter(`Depth sed [m]` > 285)
  # so that's roughly 320 rmcd

  # I have Depth comp [mcd] in my original MS dataset

  ## # add rmcd depth
  dat <- dat |>
    astrochron::tune(controlPts = rmcd, genplot = FALSE)
    mutate(rmcd = approx(x = rmcd$`Depth comp [mcd]`,
                         y = rmcd$`Depth comp r [rmcd]`,
                         xout = dat$`Depth comp [mcd]`)$y)
#+end_src
why do we need this? It would allow me to apply the agemodel of others' to our record to check, what else?
I need to integrate hole A and B into a single splice.

**** COMMENT original shipboard report
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 09:34]
:END:
simple conversion between mbsf and mcd table:
http://www-odp.tamu.edu/publications/208_IR/chap_08/c8_t2.htm#563154

single splice table
http://www-odp.tamu.edu/publications/208_IR/chap_08/c8_t3.htm#564205

table also available in ASCII: http://www-odp.tamu.edu/publications/208_IR/VOLUME/TABLES/IR208_08/08_T03.TXT
**** COMMENT shipboard section mbsf/mcd
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:20]
:END:
#+begin_src R
  mbsf <- readr::read_tsv("dat/ODP208_1267_core-section-summary.dat")
  mcd <- readr::read_tsv("dat/ODP208_1267_splice-mcd.dat") |>
    mutate(length = `MCD Bot` - `MCD Top`)
#+end_src

#+RESULTS:
#+begin_example
indexing ODP208_1267_core-section-summary.dat [====================================] 509.52MB/s, eta:  0s                                                                                                                                            Rows: 267 Columns: 10
── Column specification ─────────────────────────────────────────────────────────────────────────────────
Delimiter: "\t"
chr (4): H, T, Sc, Comment
dbl (6): Leg, Site, Cor, LL(m), CL(m), Top(mbsf)

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Warning message:
One or more parsing issues, call `problems()` on your data frame for details, e.g.:
  dat <- vroom(...)
  problems(dat)
indexing ODP208_1267_splice-mcd.dat [==============================================] 132.44MB/s, eta:  0s                                                                                                                                            Rows: 68 Columns: 5
── Column specification ─────────────────────────────────────────────────────────────────────────────────
Delimiter: "\t"
chr (1): H
dbl (4): Leg, Site, MCD Top, MCD Bot

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
#+end_example

**** CANC janus web tool
CLOSED: [2023-09-20 Wed 11:32]
does this do what I want?
https://web.iodp.tamu.edu/janusweb/general/splice.cgi
doesn't work anymore

**** COMMENT splice table from Röhl 2007
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 11:19]
:END:
https://doi.pangaea.de/10.1594/PANGAEA.667174?format=html#download
this has depth from 202.78 m(bsf?) to 209 m
from 227.08 to 235.24 rmcd

**** splice table
from [cite:@Westerhold2008] PDF
https://doi.pangaea.de/10.1594/PANGAEA.592301

another PDF :S
#+caption: Splice table for ODP 208 Site 1267 by [cite:@Westerhold2008].
[[file:~/Downloads/208-1267_TabS7_tie_points.pdf]]

This has hole core section interval depth_mbsf depth_rmcd
tie to / append to / end of splice
new mbsf / rmcd

Manually converted to csv again (using tabula/copy-paste) (this one was a bit easier than the one with many sites).

This links hole A to hole B and vice-versa
depth_mbsf from 25.2 m to 329
depth_rmcd from 28.6 m to 367 m

Same as shipboard MCD above 180.25 MCD, adjusted below.

#+begin_src R :results none
  # the full splice table
  rmcd <- readr::read_csv("dat/ODP208_1267_rmcd.csv") |>
    separate(label, into = c("sitehole", "coretype", "Sec"),
               sep = "-", remove = FALSE) |>
    separate(sitehole, into = c("Site", "H"), sep = -1) |>
    separate(coretype, into = c("Core", "T"), sep = -1) |>
    # we do not rename the interval, may not be the same as in the data!
    # rename the CC sections into 7, the naming convention in the MS data
    mutate(#Sec = ifelse(Sec == "7", "7", Sec),
           Sec = ifelse(Sec == "cc" | Sec == "C", "CC", Sec)) |>
    mutate(diff = depth_rmcd - depth_mbsf, .after = depth_rmcd) |>
    mutate(diff2 = depth_rmcd2 - depth_mbsf2, .after = depth_rmcd2) |>
    mutate(row = 1:n())

  # the right side of the splice table only
  rmcd2 <- rmcd |>
    select(label, link, label2, interval2, depth_mbsf2, depth_rmcd2, diff2, row) |>
    separate(label2, into = c("sitehole", "coretype", "Sec"),
               sep = "-", remove = FALSE) |>
    separate(sitehole, into = c("Site", "H"), sep = -1) |>
    separate(coretype, into = c("Core", "T"), sep = -1) |>
    # we do not rename the interval, may not be the same as in the data!
    mutate(Sec = ifelse(Sec == "cc" | Sec == "C", "CC", Sec))
#+end_src

***** plots to try to understand the splice table      :noexport:
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 17:15]
:END:
#+begin_src R
  rmcd |>
    ggplot(aes(x = depth_mbsf, y = depth_rmcd, colour = H)) +
    geom_point(alpha = .5) +
    geom_segment(aes(xend = depth_mbsf, yend = depth_rmcd2),
                 arrow = arrow(angle = 20, length = unit(2, "mm"), type = "closed")) +
    geom_line(aes(y = depth_rmcd), linetype = "dashed") +
    ## geom_line(aes(x = depth_mbsf2, y = depth_rmcd2))
    geom_line(aes(y = depth_rmcd2))
    ## geom_line(linetype = "dashed") #+
    ## geom_line(aes(x = depth_mbsf2))

  rmcd |>
    ggplot(aes(x = depth_rmcd, y = row)) +
    geom_point(alpha = .2) +
    geom_point(aes(x = depth_rmcd2), colour = "red", alpha = .2) +
    geom_segment(aes(xend = depth_rmcd2, yend = row),
                 arrow = arrow(angle = 20, length = unit(2, "mm"), type = "closed"))

  # i'm confused by how to work with this splice table
  rmcd |>
    ggplot(aes(x = 1, y = depth_rmcd, colour = H)) +
    geom_point() +
    geom_point(aes(x = 2, y = depth_rmcd2)) +
    geom_segment(aes(xend = 2, yend = depth_rmcd2), colour = "black") +
    ## facet_grid(cols = vars(hole)) +
    scale_y_reverse() +
    coord_cartesian(xlim = c(-4, 6))
#+end_src

#+RESULTS:
: Warning messages:
: 1: Removed 1 rows containing missing values (`geom_segment()`).
: 2: Removed 1 row containing missing values (`geom_line()`).
: Warning messages:
: 1: Removed 1 rows containing missing values (`geom_point()`).
: 2: Removed 1 rows containing missing values (`geom_segment()`).
: Warning messages:
: 1: Removed 1 rows containing missing values (`geom_point()`).
: 2: Removed 1 rows containing missing values (`geom_segment()`).

understand the splice table
#+begin_src R
  ODP208_1267_MS_A |>
    mutate(Sec = as.character(Sec)) |>
    ggplot(aes(x = `Depth (mbsf)`,
               y = `Corrected Suscept.`,
               colour = H, group = H,
               Site = Site, Core = Core, T = T, Sec = Sec)) +
    geom_line() +
    geom_line(aes(y = `Corrected Suscept.` + 100), data = ODP208_1267_MS_B) +
    # this shows how the holes line up from XRF data and MS data
    geom_segment(aes(x = depth_mbsf, xend = depth_mbsf2, y = -200, yend = -10,
                     lab2 = label2),
                 data = rmcd |> filter(H == "A")) +
    geom_segment(aes(x = depth_mbsf, xend = depth_mbsf2, y = -10, yend = -200,
                     lab2 = label2),
                 data = rmcd |> filter(H == "B")) #+
    # this shows the stretching they applied after
    ## geom_segment(aes(xend = depth_rmcd2, y = 0, yend = 500), data = rmcd)
#+end_src

**** apply the splice table to the magsus data
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 10:43]
:END:
#+begin_src R
  # add Magsus from hole A and B to the same dataframe
  MS <- ODP208_1267_MS_A |>
    mutate(Sec = as.character(Sec)) |>
    bind_rows(ODP208_1267_MS_B) |>
    # add the rcmd splice table
    tidylog::left_join(rmcd |>
                       # make the types teh same
                       mutate(across(c(Site, Core), parse_double)) |>
                       # do NOT match by section, only by core!
                       rename(section = Sec) |>
                       select(top = label, to = label2,
                              Site, H, Core, T, section, interval, depth_mbsf, depth_rmcd, diff, row)) |>
    # add the right-hand side of the splice table
    tidylog::left_join(rmcd2 |>
                       mutate(across(c(Site, Core), parse_double)) |>
                       rename(section2 = Sec) |>
                       select(from = label, bot = label2,
                              Site, H, Core, T, section2, interval2, depth_mbsf2, depth_rmcd2, diff2, row2 = row)) |>
    # I tried the full_joins for both, which adds
    #> 1267A-26H-7	1267B-27X-4	7	10	244.7	275.3	30.6	46
    # and
    #> 1267B-36X-C							61
    # the ties represent jumps to another depth, anything above the jump should be included
    ## mutate(seclsec = Sec < section,
    ##        secesec = Sec == section,
    ##        secgsec = Sec > section,
    ##        topleint = `Top (cm)` <= interval,
    ##        my_rmcd =
    mutate(my_rmcd = case_when(
    (Sec <= section) | ((Sec == section) & (`Top (cm)` <= interval)) ~ `Depth (mbsf)` + diff,
    (Sec >= section2) | ((Sec == section2) & (`Top (cm)` >= interval2)) ~ `Depth (mbsf)` + diff2,
    TRUE ~ NA_real_)) |>
    mutate(on_splice = (Sec < section | ((Sec == section) & (`Top (cm)` <= interval))) &
           (Sec > section2 | ((Sec == section2) & `Top (cm)` >= interval2))) |>
    mutate(on_splice = ifelse(is.na(on_splice), FALSE, on_splice)) |>
    ## print(width = Inf)
    readr::write_csv("out/ODP208_1267_MS.csv")
#+end_src

#+RESULTS:
#+begin_example
Joining with `by = join_by(Site, H, Core, T)`
left_join: added 8 columns (top, to, section, interval, depth_mbsf, …)
rows only in x    2,494
rows only in y  (     1)
matched rows     20,745
                ========
rows total       23,239
Joining with `by = join_by(Site, H, Core, T)`
left_join: added 8 columns (from, bot, section2, interval2, depth_mbsf2, …)
rows only in x    2,510
rows only in y  (     1)
matched rows     20,729
                ========
#+end_example

**** read in the processed ODP208 1267 MS
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 10:53]
:END:
#+begin_src R :exports none
  MS <- readr::read_csv("out/ODP208_1267_MS.csv",
                        guess_max = 23000)
#+end_src

#+RESULTS:
: indexing ODP208_1267_MS.csv [=======================================================----------------------------------------------------] 120.29GB/s, eta:  0sindexing ODP208_1267_MS.csv [===========================================================================================================] 680.00MB/s, eta:  0s                                                                                                                                                                                                 Rows: 23239 Columns: 28
: ── Column specification ──────────────────────────────────────────────────────
: Delimiter: ","
: chr  (8): H, T, Sec, top, to, section, from, bot
: dbl (19): Leg, Site, Core, Top (cm), Depth (mbsf), Magnetic Suscept., Corrected Suscept., interval, depth_mbsf, depth_rmcd, diff, row, section2, interval2...
: lgl  (1): on_splice
:
: ℹ Use `spec()` to retrieve the full column specification for this data.
: ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

**** COMMENT apply splice table using linear interpolation/extrapolation
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 13:01]
:END:
The rmcd splice table goes down to 311 mbsf for hole A, the MS data goes down to 312 mbsf.
Trying it with approx/approxExtrap.
This is wrong, they shouldn't be stretched!

#+begin_src R
  ## MS <- ODP208_1267_MS_A |>
  ##   mutate(Sec = as.character(Sec)) |>
  ##   mutate(depth_rmcd = Hmisc::approxExtrap(x = rmcd[rmcd$H == "A", ]$`Depth (mbsf)`,
  ##                              y = rmcd[rmcd$H == "A", ]$depth_rmcd,
  ##                              xout = `Depth (mbsf)`)$y) |>
  ##   ## tail() |>
  ##   ## print(width = Inf)
  ##   bind_rows(
  ##     # the rmcd splice table goes down to 329 mbsf for hole B, the MS data goes down to 329 mbsf
  ##     ODP208_1267_MS_B |>
  ##     mutate(Sec = as.character(Sec)) |>
  ##     mutate(depth_rmcd = Hmisc::approxExtrap(x = rmcd[rmcd$H == "B", ]$`Depth (mbsf)`,
  ##                                             y = rmcd[rmcd$H == "B", ]$depth_rmcd,
  ##                                             xout = `Depth (mbsf)`)$y)
  ##   )
#+end_src

**** plot the splice MS record vs rmcd
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 13:02]
:END:
#+begin_src R :results output graphics file :file imgs/ODP208_1267_MS_rcmd.png :width 900
  MS |>
    # I'd like to NOT plot the lines between the core gaps, so I group by Core
    ggplot(aes(x = my_rmcd, y = `Corrected Suscept.`, colour = H, group = paste(H, Core, T, Sec),
               Sec = Sec)) +
    geom_line(aes(alpha = on_splice)) +
    coord_cartesian(xlim = c(320.25, NA), ylim = c(0, 300)) +
    scale_alpha_manual(values = c(0.5, 1))

  ## MS |>
  ##   ggplot(aes(x = `Depth (mbsf)`, y = `Corrected Suscept.`, colour = H, group = paste(H, Core, T))) +
  ##   geom_line(aes(alpha = on_splice))
#+end_src

#+caption: ODP 208 1267 MS with the splice table applied.
#+RESULTS:
[[file:imgs/ODP208_1267_MS_rcmd.png]]

I think that did it! I checked with Luc if the rmcd would have stretching applied, it doesn't.

**** SOME currently some issue with A26X1-6 /B27X1-4 but I'm not interested in that interval anyway
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 17:32]
:END:
:LOGBOOK:
- State "SOME"       from "NEXT"       [2023-09-20 Wed 17:32]
:END:

**** SOME double-check with the excel file
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 09:22]
:END:
:LOGBOOK:
- State "SOME"       from "NEXT"       [2023-09-29 Fri 12:55]
:END:
I'd like to double-check that my function is general enough that it works for all the little niche cases.
**** NEXT fix issue with overlapping depth in A31-4 and B32-5
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 17:32]
:END:
very very small overlapping region, what's going on here?
I'm following the splice table accurately, but maybe there are some errors in the splice table? I see some similar regions in MS here that are not fully aligned (but again, the off-splice isn't aligned correctly I think?).

*** analyze MS data in depth domain (rmcd)
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 16:42]
:END:

**** COMMENT create a shiny interface
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 08:42]
:END:
:LOGBOOK:
CLOCK: [2023-09-22 Fri 08:42]--[2023-09-22 Fri 09:30] =>  0:48
:END:
this is to inspect how the moving average affects the outcome
#+begin_src R
  library(shiny)
  library(bslib)
  library(plotly)

  cleandat <- MS |>
    tidylog::filter(
               !is.na(my_rmcd),
               ## my_rmcd > 319.46,
               my_rmcd > 320.25, # K/T boundary
               on_splice) |>
    mutate(var = scale(`Corrected Suscept.`)[, 1]) |>
    select(my_rmcd, var)

  rawmtm <- cleandat |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::mtm(detrend = TRUE, demean = TRUE, xmax = 5,
                    output = 1,
                    verbose = FALSE,
                    genplot = FALSE) |>
    as_tibble()

  rawfreq <- cleandat |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::mtm(detrend = TRUE, demean = TRUE, xmax = 5,
                    output = 3,
                    verbose = FALSE,
                    genplot = FALSE) |>
    as_tibble()


  ui <- page_sidebar(
    theme = bs_theme(bootswatch = "minty"),
    sidebar = sidebar(
      sliderInput(inputId = "width",
                  label = "Width of the moving average",
                  min = 1,
                  max = 200,
                  value = 200)
    ),
    plotOutput("raw"),
    plotOutput("mtm"),
    plotOutput("wavelet")
  )

  server <- function(input, output, session) {
    filt <- reactive(MS |>
      tidylog::filter(
                 !is.na(my_rmcd),
                 my_rmcd > 320.25, # K/T
                 on_splice) |>
      mutate(var = scale(`Corrected Suscept.`)[, 1]) |> # or `L*`
      mutate(scl_ma = scale(var - slider::slide_mean(var,
                                                     before = input$width,
                                                     after = input$width))[, 1]))
    freqs <- reactive(filt() |>
                      select(my_rmcd, scl_ma) |>
                      astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                      astrochron::mtm(detrend = TRUE, demean = TRUE, xmax = 5,
                                      output = 3,
                                      verbose = FALSE,
                                      genplot = FALSE) |>
                      as_tibble())

    output$raw <- renderPlot({
      ## pl_raw <-
        filt() |>
        ggplot(aes(x = my_rmcd, y = var)) +
        geom_line(aes(colour = "scale(MS)")) +
        geom_line(aes(y = scl_ma, colour = glue::glue("moving average")))
      ## plotly::toWebGL(plotly::ggplotly(p = pl_raw, dynamicTicks = TRUE))
    })

    output$mtm <- renderPlot({
      ## plmtm <-
        filt() |>
        select(my_rmcd,
           ## var
           scl_ma
           ## scl_gam
           ## scl_loess
           ) |>
        astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
        astrochron::mtm(detrend = TRUE, demean = TRUE, xmax = 5, verbose = FALSE, output = 1,
                        genplot = FALSE) |>
        ggplot(aes(x = Frequency, y = Power)) +
        geom_segment(aes(xend = Frequency, y = 0, yend = Harmonic_CL),
                     colour = "lightgray",
                     data = rawfreq) +
        geom_line(data = rawmtm, colour = "darkgray") +
        geom_segment(aes(xend = Frequency, y = 0, yend = Harmonic_CL),
                     colour = "darkgray", linetype = "dotted",
                     data = freqs()) +
        geom_line() +
        scale_y_log10() +
        ## scale_x_continuous(
        ##   sec.axis = sec_axis(trans = ~ 1 / .x,
        ##                       name = "Period",
        ##                       breaks = c(.01, .5, .1, 1, 10))) +
        geom_line(aes(y = AR1_fit), colour = "red") +
        geom_line(aes(y = AR1_90_power), colour = "red") +
        geom_line(aes(y = AR1_95_power), colour = "red") +
        geom_line(aes(y = AR1_99_power), colour = "red") +
        coord_cartesian(xlim = c(0, 10))
        ## coord_cartesian(xlim = c(0.050, 1 / 10))
      ## plotly::toWebGL(plotly::ggplotly(p = plmtm, dynamicTicks = TRUE))
    })

    output$wavelet <- renderPlot({
      filt() |>
        select(my_rmcd, scl_ma) |>
        WaverideR::analyze_wavelet(lowerPeriod = .3,
                                   upperPeriod = 20,
                                   omega_nr = 8) |>
        WaverideR::plot_wavelet(palette_name = "inferno",
                                siglvl = .95,
                                dev_new = FALSE,
                                add_data = FALSE,
                                add_MTM = FALSE, # NOT WORKING!
                                add_MTM_peaks = FALSE,
                                )
    })
  }

  shinyApp(ui, server)
#+end_src
**** filter out desired depth interval and get rid of long-term trends
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 16:44]
:END:
#+begin_src R :results graphics file :file imgs/ODP208_1267_MS_detrend.png :width 900
  MS_ <- MS |>
    tidylog::filter(
               !is.na(my_rmcd),
               my_rmcd > 320.25, # K/T
               on_splice) |>
    mutate(var = scale(`Corrected Suscept.`)[, 1],
           ma = slider::slide_mean(var, before = 2, after = 2), # 5pt ma
           scl_ma = scale(ma)[, 1])

  fit_loess_MS <- loess(var ~ my_rmcd, data = MS_, span = .75)
  fit_gam_MS <- mgcv::gam(var ~ s(my_rmcd, bs = "cs"),
                          method = "REML",
                          data = MS_)

  MS_ <- MS_ |>
    mutate(
      gam = predict(fit_gam_MS) |> as.vector(),
      loess = predict(fit_loess_MS),
      scl_gam = scale(var - gam)[, 1],
      scl_loess = scale(var - loess)[, 1])

  MS_ |>
    ggplot(aes(x = my_rmcd, y = var)) +
    geom_line(aes(group = paste(Core, H, Sec)), alpha = .2) +
    geom_line(aes(y = ma, colour = "5pt moving average")) +
    ## geom_line(aes(y = scl_ma, colour = "moving average ± 200")) +
    ## geom_line(aes(y = scl_gam, colour = "generalized additive model (GAM)"))
    geom_line(aes(y = gam, colour = "generalized additive model (GAM)")) +
    ## geom_line(aes(y = scl_loess, colour = "LOESS"))
    geom_line(aes(y = loess, colour = "LOESS"))
#+end_src

#+caption: ODP 208 Site 1267 MS long-term trend removal strategies.
#+RESULTS:
[[file:imgs/ODP208_1267_MS_detrend.png]]

**** [#B] redo analysis with RMCD
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 13:05]
:END:
from [cite:@Husson2011] but now with rmcd
#+begin_src R :results output graphics file :file imgs/208-1267B_MS_Husson-fig4_rmcd.png :width 900 :height 500
  f100 <- MS_ |>
    select(my_rmcd, var) |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::taner(flow = 0, fhigh = 0.9, xmax = 3) |>
    as_tibble()


  f405 <- MS_ |>
    select(my_rmcd, var) |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::taner(flow = 0, fhigh = 0.25, xmax = 1) |>
    as_tibble()

  MS_ |>
    ggplot(aes(x = my_rmcd, y = var)) +
    annotate("rect", xmin = 320.275 - 1, xmax = 320.275, ymin = -Inf, ymax = Inf,
             fill = "yellow", alpha = .6) + # the K/T boundary
    ## geom_line(colour = "gray", data = MS_ |> select(my_rmcd, var) |> astrochron::linterp(genplot = FALSE)) +
    geom_line(aes(group = paste(H, Core, Sec), depth_mbsf = `Depth (mbsf)`), colour = "darkblue") +
    geom_line(aes(y = var + 2), data = f100, colour = "skyblue") +
    geom_line(aes(y = var + 4), data = f405, colour = "black") +
    ## coord_cartesian(xlim = c(287.4, 330), ylim = c(0, 300)) +
    labs(x = "Depth (rmcd)", y = MS ~ "(10"^{-8} ~ "kgm"^{-3} * ")",
         title = "ODP Leg 208 Site 1267")
#+end_src

#+caption: *ODP 208 Site 1267 MS* Taner filters as in [cite:@Husson2011] redone on rmcd depth scale.
#+RESULTS:
[[file:imgs/208-1267B_MS_Husson-fig4_rmcd.png]]

**** do spectral analysis
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 16:52]
:END:
#+begin_src R :results graphics file :file imgs/ODP208_1267_MS_mtm.png :width 800
  hus_filters <- tribble(
    ~ target, ~ flow, ~ fhigh,
    "100 kyr", 0, 0.09,
    "405 kyr", 0, 0.25,
    ) |>
    mutate(ref = "Husson et al., 2011")

  my_1267_filters <- tribble(
    ~ target, ~ f,
    ## "405 kyr", 0.08,
    "405 kyr", 0.16,
    ## "100 kyr", 0.65, # this is NOT based on the spectrum!
    "100 kyr", 0.57, # these are the two nice non-significant peaks
    "prec", 2.42,
    ) |>
    mutate(fr = 0.2 * f,
           flow = f - fr,
           fhigh = f + fr) |>
    mutate(ref = "This study")

  MS_fft <- MS_ |>
     pivot_longer(c(var, scl_ma, scl_gam, scl_loess),
                 names_to = "smooth_type") |>
    nest(.by = "smooth_type") |>
    mutate(
      fft = map(data,
                ~ . |>
                  select(my_rmcd, value) |>
                  astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                  astrochron::periodogram(output = 1, genplot = FALSE, verbose = FALSE))
        ) |>
        select(-data) |>
        unnest(fft) |>
    # I don't think we'll need to make it longer still
        ## pivot_longer(c(Amplitude, Power, Phase),
        ##              names_to = c("AR1", ".width"),
        ##              values_to = "power") |>
        rename(freq = Frequency, power = Power, amp = Amplitude, phase = Phase)

  MS_ |>
    pivot_longer(c(var, scl_ma, scl_gam, scl_loess),
                 names_to = "smooth_type") |>
    nested_spectral_analysis(nest = c("smooth_type"), x = my_rmcd, y = value) |>
    ## filter(smooth_type == "var") |>
    ## select(-smooth_type) |>
    ## plot_spectrum() #+ # I don't know how to do this with another, unpredictable mapping
    ggplot(aes(x = freq, y = power, colour = smooth_type)) +
    geom_ribbon(aes(ymin = AR1_fit, ymax = AR1_power,
                    linetype = NA, fill = smooth_type,
                    group = paste(smooth_type, .width)),
                alpha = .1) +
    geom_line() +
    # add the FFT/periodogram
    ## geom_line(alpha = .2, data = MS_fft) +
    annotation_logticks(sides = "l") +
    scale_y_log10() +
    scale_x_log10(sec.axis = sec_axis(trans = ~ 1 / .x, name = "Period (m)")) +
    labs(x = "Frequency (cycles/m)", y = "Spectral power (-)") +
    coord_cartesian(xlim = c(1e-4, 0.0625) * 100, ylim = c(1e-5, .15)) +
    scale_x_log10(
    ## scale_x_continuous(
      sec.axis = sec_axis(trans = ~ 1 / .x,
                          name = "Period (m)",
                          breaks = c(100, 50, 10, 5, 3, 2, 1, .5, .3, .2, .1))) +
    ggnewscale::new_scale_fill() +
    # annotate the Husson 2011 filters
    geom_rect(aes(xmin = flow, xmax = fhigh, ymin = 1e-5, ymax = 1, fill = ref),
              inherit.aes = FALSE,
              alpha = .1, data = hus_filters) +
    geom_rect(aes(xmin = flow, xmax = fhigh, ymin = 1e-5, ymax = 1, fill = ref),
              inherit.aes = FALSE,
              alpha = .4, data = my_1267_filters) +
    scale_fill_brewer(type = "qual") +
    labs(fill = "Filter intervals from study")
#+end_src

#+caption: ODP 208 Site 1267 spectra.
#+RESULTS:
[[file:imgs/ODP208_1267_MS_mtm.png]]

There are no significant spectral peaks in the range that they filter (green rectangles, they use a Taner filter between 0 and 0.9 and 0 and 0.25 cycle/m).
I've tried various ways of detrending the record first (raw value = var, scl_ma is moving average, scl_loess minus loess filter, scl_gam minus gam) but it's not coming out too clearly.

However, I do see a nice bump around what could be the 405 kyr and two bumps that could be the 100 kyr? In relation to the main precession curve this could make sense?
The purple regions show how I decide to filter the record based on the spectral analysis.

#+begin_src R
  # can I do anything useful with the harmonic_cl or the AR1_CL?
  MS_ |>
    pivot_longer(c(var, scl_ma, scl_gam, scl_loess),
                 names_to = "smooth_type") |>
    nested_spectral_analysis(nest = c("smooth_type"), x = my_rmcd, y = value) |>
    filter(smooth_type == "var") |>
    select(-smooth_type) |>
    ggplot(aes(x = freq, y = AR1_CL)) +
    geom_line() +
    geom_ribbon(aes(ymin = 0, ymax = AR1_CL), alpha = .2) #+
    ## geom_ribbon(aes(ymin = 0, ymax = harmonic_cl))

#+end_src

**** do wavelet analysis
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 16:45]
:END:
I haven't really looked at this in too much detail so far.

#+begin_src R :results graphics file :file imgs/ODP208_1267_MS_wavelet.png :width 800
  MS |>
    select(my_rmcd,
           var
           ## scl_ma
           ## scl_gam
           ## scl_loess
           ) |>
    filter(my_rmcd <= 355.350) |> # there's a coregap after this
    ## filter(my_rmcd >= 356.950) |> # there's a coregap before this
    WaverideR::analyze_wavelet(lowerPeriod = .3,
                               upperPeriod = 20,
                               omega_nr = 8,
                               ## verbose = TRUE
                               ) |>
    WaverideR::plot_wavelet(palette_name = "inferno",
                            siglvl = .95,
                            dev_new = FALSE,
                            ## add_avg = TRUE,
                            add_MTM = TRUE, # NOT WORKING!
                            add_MTM_peaks = TRUE,
                            ## add_abline_h = c(11)
                            )
#+end_src

#+caption: ODP 208 Site 1267 wavelet analysis.
#+RESULTS:
[[file:imgs/ODP208_1267_MS_wavelet.png]]

**** do bandpass filtering in the rmcd domain
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 11:18]
:END:
Based on the filter intervals I picked based on the spectrum.

This time using a rectangular filter. What happens if I switch to a Gaussian filter? This narrows the filters by quite a bit, resulting in far smaller amplitude in the signal, but obviously a more sinusoidal filter. For now I prefer the rectangular filter.

#+begin_src R :exports none
  MS_filts <-
    MS_ |>
    pivot_longer(c(var, scl_ma, scl_gam, scl_loess),
                 names_to = "smooth_type") |>
    nest(.by = c(smooth_type)) |>
    mutate(filt = list(my_1267_filters)) |>
    unnest(filt) |>
    mutate(
      bp = pmap(list(data, flow, fhigh),
               \(d, l, h) d |>
                 select(my_rmcd, value) |>
                 astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                 astrochron::bandpass(flow = l, fhigh = h, win = 0,
                                      genplot = FALSE, verbose = FALSE)
               )
    ) |>
    select(-data) |>
    unnest(cols = bp) |>
    rename(filt = value)
#+end_src

#+RESULTS:
: Warning message:
: There were 12 warnings in `mutate()`.
: The first warning was:
: ℹ In argument: `bp = pmap(...)`.
: Caused by warning in `regularize.values()`:
: ! collapsing to unique 'x' values
: ℹ Run `dplyr::last_dplyr_warnings()` to see the 11 remaining warnings.

**** plot the filters
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 16:43]
:END:
Note that the 100 kyr is NOT significantly present in the MTM spectrum.

#+begin_src R :results graphics file output :file imgs/ODP208_1267_MS_my-filters.png :width 800
  MS_filts |>
    ggplot(aes(x = my_rmcd, y = filt)) +
    facet_grid(rows = vars(target)) +
    geom_line(aes(colour = smooth_type, group = paste(target, smooth_type))) +
    geom_line(aes(y = scl_gam), data = MS_, alpha = .3) +
    coord_cartesian(ylim = c(-2.5, 2.5))
#+end_src

#+attr_latex: :width \linewidth
#+caption: ODP 208 Site 1267 Bandpass filters. Note: 100 kyr is not significant in spectrum!
#+RESULTS:
[[file:imgs/ODP208_1267_MS_my-filters.png]]

**** do Hilbert transform of precession filter
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 12:03]
:END:
:LOGBOOK:
- Note taken on [2023-10-02 Mon 13:34] \\
  just did this now
- State "SOME"       from              [2023-09-28 Thu 12:03]
:END:

#+begin_src R
  MS_filt_hb <- MS_filts |>
    filter(target == "prec") |>
    nest(.by = c(smooth_type, target, ref)) |>
    mutate(hb = map(data, \(d) d |>
                               select(my_rmcd, filt) |>
                               astrochron::hilbert(genplot = FALSE,
                                                   verbose = FALSE,
                                                   output = TRUE))) |>
    select(-data, -target) |>
    unnest(cols = c(hb))
#+end_src

#+RESULTS:

**** plot the bandpass filters
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 11:33]
:END:
This is the same plot as before, but now overplotting everything. Furthermore, I now add the Hilbert transform of the precession filter as well as the two Taner filters from [cite:@Husson2011] for comparison.

#+caption: ODP 208 Site 1267 bandpass filters, Taner filters, and Hilbert transform of precession filter.
#+begin_src R :results output graphics file :file imgs/ODP208_1267_bandpass_filters.png :width 900
  MS_filts |>
    ## filter(target != "prec")|>
    ggplot(aes(x = my_rmcd, y = filt)) +
    # plot gam-detrended record
    geom_line(aes(y = scl_gam), data = MS_, alpha = .3) +
    geom_line(aes(y = envelope, colour = smooth_type),
              data = MS_filt_hb, alpha = .3) +
    # plot Husson 2011 taner filters
    geom_line(aes(y = var + 2), data = f100, colour = "skyblue") +
    geom_line(aes(y = var + 3), data = f405, colour = "black") +
    # plot my filters
    geom_line(aes(colour = smooth_type, linetype = target)) +
    labs(x = "Depth (rmcd)",
         y = "Normalized smoothed/filtered record",
         colour = "Type of smoothing")
#+end_src

#+RESULTS:
[[file:imgs/ODP208_1267_bandpass_filters.png]]

*** agemodels
**** shipboard agemodel
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 09:46]
:END:
From [cite:@Zachos2004].
http://www-odp.tamu.edu/publications/208_IR/chap_08/c8_f28.htm#554657
from 1 Ma to 66 Ma
#+begin_src R :exports none
  agem_sb <- readr::read_tsv("http://www-odp.tamu.edu/publications/208_IR/VOLUME/TABLES/IR208_08/08_T14.TXT",
                             comment = "#", skip = 4)
#+end_src

#+RESULTS:
#+begin_example
indexed 218.00B in  0s, 8.71MB/s                                                                                                       indexed 1.00TB in  0s, 1.78PB/s                                                                                                       New names:
• `` -> `...11`
• `` -> `...12`
• `` -> `...13`
• `` -> `...14`
• `` -> `...15`
• `` -> `...16`
• `` -> `...17`
• `` -> `...18`
• `` -> `...19`
Rows: 66 Columns: 19
── Column specification ─────────────────────────────────────────────────────────────────────────────────
Delimiter: "\t"
dbl (10): Age (Ma), Depth (mcd), LSR, Growth factor, Corrected LSR, Dry density (g/cm3), CaCO3 (wt%),...
lgl  (9): ...11, ...12, ...13, ...14, ...15, ...16, ...17, ...18, ...19

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Warning message:
One or more parsing issues, call `problems()` on your data frame for details, e.g.:
  dat <- vroom(...)
  problems(dat)
#+end_example

**** agemodel from Neptune database
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 09:43]
:END:
From [cite:@Renaudie2020] (only hole B).
#+begin_src R :exports none
  agem3 <- readr::read_tsv("dat/Renaudie2020/agem.csv")

  agem3 |>
    ggplot(aes(x = `Depth (mbsf)`, y = `Age (Ma)`)) +
    geom_line() +
    geom_line(aes(x = `Depth (mcd)`), data = agem_sb, colour = "red")
#+end_src

#+RESULTS:
: indexing agem.csv [=================================================================] 82.89MB/s, eta:  0s                                                                                                                                            Rows: 22 Columns: 4
: ── Column specification ─────────────────────────────────────────────────────────────────────────────────
: Delimiter: "\t"
: chr (2): Hole, Comment
: dbl (2): Age (Ma), Depth (mbsf)
:
: ℹ Use `spec()` to retrieve the full column specification for this data.
: ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
: Error: object 'agem_sb' not found

**** agemodels
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 11:22]
:END:
From [cite:@Westerhold2008].
site 1267 range or rmcd = 311.39 m to 336.1 m

#+begin_src R :results output graphics file :file imgs/agem_Westerhold2008.png :width 900 :height 500
  # add age model. This links raw mcd and armcd scale to 100 kyr maxima
  ## agem <- pangaear::pg_data("10.1594/PANGAEA.666282")
  # but it's a PDF :S
  # used tabula --pages=all to convert to text
  # then manually converted it to CSV

  agem <- readr::read_csv("dat/Westerhold2008/agemodel_clean.csv",
                          comment = "#",
                          na = c("", "end of splice", "condensed"))
  # see if I got the formatting of the CSV correct
  ## agem |>
  ##   print(n = Inf, width = Inf)

  agem |>
    pivot_longer(c(site1262_mcd:site1001_rmcd, Zumaia_depth),
                 names_to = "site", values_to = "depth") |>
    pivot_longer(c(age_La2004_1, age_La2004_2), names_to = "option", values_to = "age") |>
    ggplot(aes(x = depth, y = age, colour = site,
               linetype = option, shape = option)) +
    geom_point() +
    geom_line()
#+end_src

#+caption: ODP 208 Site 1267 age model from [cite:@Westerhold2008].
#+RESULTS:
[[file:imgs/agem_Westerhold2008.png]]
**** [#B] agemodel
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 09:14]
:END:
From [cite:@Batenburg2018a].
depth rmcd from 232 m to 366 m
age from 56 Ma to 69.1 Ma

#+begin_src R :exports none
  agem2 <- readr::read_csv("dat/Batenburg2018/site_1267_agemodel.csv") #|>
  ## summarize(d = range(depth_rmcd), a = range(age_ma))
#+end_src

#+RESULTS:
**** plot agem
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:25]
:END:
#+begin_src R :results output graphics file :file imgs/208-1267B_agem.png :width 900 :height 500
  agem |>
    ggplot() +
    geom_line(aes(x = `Depth (mcd)`, y = `Age (Ma)`,
                  colour = "Shipboard Scientific Party 2004"), data = agem_sb) +
    geom_line(aes(x = `Depth (mbsf)`, y = `Age (Ma)`,
                  colour = "Renaudi 2020 Neptune db (mbsf!)"), data = agem3) +
    geom_line(aes(x = site1267_rmcd, y = age_La2004_1 / 1000,
                  colour = "Westerhold et al., 2008 option 1")) +
    geom_line(aes(x = site1267_rmcd, y = age_La2004_2 / 1000,
                  colour = "Westerhold et al., 2008 option 2")) +
    geom_line(aes(x = depth_rmcd, y = age_ma,
                  colour = "Batenburg et al., 2018"), data = agem2) +
    geom_point(aes(x = depth_rmcd, y = age_ma,
                  colour = "Batenburg et al., 2018"), data = agem2) +
    annotate("rect", xmin = -Inf, xmax = Inf, ymin = 66, ymax = 80, fill = "yellow", alpha = .3) +
    annotate("text", x = 50, y = 73, label = "Target interval")
#+end_src

#+caption: Overview of age models for ODP 208 Site 1267.
#+RESULTS:
[[file:imgs/208-1267B_agem.png]]
*** plot the taner age model on top of the depth MS data
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 09:32]
:END:
#+begin_src R :exports none
  MS |>
    ggplot(aes(x = my_rmcd, y = `Corrected Suscept.`, colour = H, group = paste(H, Core, T, Sec),
               Sec = Sec)) +
    geom_line(aes(alpha = on_splice)) +
    geom_point(aes(x = depth_rmcd, y = 0, age = age_ma, strat_event = strat_event),
               inherit.aes = FALSE, data = agem2)
#+end_src

#+RESULTS:
: Warning messages:
: 1: In geom_point(aes(x = depth_rmcd, y = 0, age = age_ma, strat_event = strat_event),  :
:   Ignoring unknown aesthetics: age and strat_event
: 2: Using alpha for a discrete variable is not advised.
: 3: Removed 2230 rows containing missing values (`geom_line()`).

*** apply the agemodel to the MS data
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 15:49]
:END:
#+begin_src R
  MS |>
    mutate(age = approx(agem2$depth_rmcd, agem2$age_ma,
                        xout = my_rmcd)$y) |>
    ggplot(aes(x = age, y = `Corrected Suscept.`,
               ## alpha = on_splice,
               Sec = Sec)) +
    geom_line(aes(colour = H, group = paste(H, Core))) #+
    ## geom_smooth(aes(group = "all"))
#+end_src

#+RESULTS:

*** analyze MS data in the time domain
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 10:00]
:END:
#+begin_src R :exports none
  MS_ |>
    mutate(age = approx(agem2$depth_rmcd, agem2$age_ma,
                        xout = my_rmcd)$y) |>
    ## filter(my_rmcd <= 355.350) |> # there's a coregap after this
    ## filter(my_rmcd >= 356.950) |> # there's a coregap before this
    select(age,
           ## var
           scl_gam
           ) |>
    WaverideR::analyze_wavelet(lowerPeriod = .01,
                               upperPeriod = 1.5,
                               omega_nr = 8,
                               ## verbose = TRUE
                               ) |>
    WaverideR::plot_wavelet(palette_name = "inferno",
                            siglvl = .95,
                            dev_new = FALSE,
                            ## add_avg = TRUE,
                            add_MTM = TRUE, # NOT WORKING!
                            add_MTM_peaks = TRUE,
                            add_abline_h = c(0.405, 0.125, 0.027)
                            )
#+end_src

#+RESULTS:
: Warning message:
: In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
:   collapsing to unique 'x' values

**** filter MS in time
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 10:19]
:END:
#+begin_src R
  MS_f405 <- MS |>
      mutate(age = approx(agem2$depth_rmcd, agem2$age_ma,
                          xout = my_rmcd)$y) |>
      filter(my_rmcd <= 355.350) |> # there's a coregap after this
      ## filter(my_rmcd >= 356.950) |> # there's a coregap before this
      select(age,
             ## var
             scl_gam
             ) |>
    astrochron::linterp(verbose = F, genplot = F) |>
    astrochron::bandpass(flow = 1 / .405 - .15 * 1 / .405,
                         fhigh = 1 / .405 + .15 * 1 / .405,
                         xmax = 15,
                         padfac = 5, win = 1, detrend = T, addmean = F) |>
    as_tibble()

  MS_f100 <- MS |>
      mutate(age = approx(agem2$depth_rmcd, agem2$age_ma,
                          xout = my_rmcd)$y) |>
      filter(my_rmcd <= 355.350) |> # there's a coregap after this
      ## filter(my_rmcd >= 356.950) |> # there's a coregap before this
      select(age,
             ## var
             scl_gam
             ) |>
    astrochron::linterp(verbose = F, genplot = F) |>
    astrochron::bandpass(flow = 1 / .125 - .15 * 1 / .125,
                         fhigh = 1 / .125 + .15 * 1 / .125,
                         xmax = 15,
                         padfac = 5, win = 1, detrend = T, addmean = F) |>
    as_tibble()

  MS |>
    mutate(age = approx(agem2$depth_rmcd, agem2$age_ma,
                        xout = my_rmcd)$y) |>
    filter(my_rmcd <= 355.350) |> # there's a coregap after this
    ggplot(aes(x = age, y = scl_gam)) +
    geom_line() +
    geom_line(data = MS_f100) +
    geom_line(data = MS_f405)

  MS_f100 |>
    rename(f100 = scl_gam) |>
    full_join(MS_f405 |> rename(f405 = scl_gam)) |>
    mutate(fake_ecc = scale(f100 + f405)[, 1]) |>
    ggplot(aes(x = age, y = fake_ecc)) +
    geom_line(colour = "red") +
    geom_line(aes(x = age, y = ecc),
              data = snvecR::get_ZB18a() |>
                mutate(age = age / 1e3) |>
                filter(age > 66 & age < 68.5) |>
                mutate(ecc = scale(ee)[, 1]))
#+end_src
*** colour reflectance data from Janus database
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 11:23]
:END:
I've added this myself, may be nicer than just MS?
https://web.iodp.tamu.edu/janusweb/physprops/colordat.cgi?leg=208&site=1267

They did this analysis also in [cite:@Westerhold2007] and extended it in [cite:@Batenburg2018a] (56.042 Ma to 69.070 Ma).

**** [#B] read in the data and calculate normalized a*/b*
#+begin_src R :exports none
  ## ODP208_1267_color_A <- readr::read_tsv("dat/ODP208_1267_color-reflectance.dat")
  ## ODP208_1267_color_B <- readr::read_tsv("dat/ODP208_1267_color-reflectance_B.dat")

  # downloaded this again with all the relevant columns!
  dat <- read_csv("dat/colordat208-1267.csv")
  # dat is only hole B for now

  dat |>
    ggplot(aes(x = `Depth (mbsf)`,
               y = `L*`,
               ## y = `a*`,
               ## y = `b*`,
               ## y = `a*` / `b*`,
               )) +
    scale_x_reverse() +
    geom_vline(xintercept = 287) + # approximately the K/T (in mbsf)
    geom_line()
#+end_src

#+RESULTS:
: indexing colordat208-1267.csv [===------------------------] 7.30GB/s, eta:  0sindexing colordat208-1267.csv [=========================] 432.90MB/s, eta:  0s                                                                                                                 Rows: 25316 Columns: 55
: ── Column specification ──────────────────────────────────────────────────────
: Delimiter: ","
: chr  (5): H, T, Sec, Run Date/Time, Munsell_HVC
: dbl (50): Leg, Site, Core, Top (cm), Depth (mbsf), Depth (mcd), Run Number...
:
: ℹ Use `spec()` to retrieve the full column specification for this data.
: ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

**** prep data
:PROPERTIES:
:CREATED:  [2024-02-02 Fri 09:37]
:END:
***** rename some columns, limit to depth of interest
:PROPERTIES:
:CREATED:  [2024-02-02 Fri 10:38]
:END:
#+begin_src R
  dat <- dat |>
    rename(depth = `Depth (mbsf)`,
           Lstar = `L*`,
           astar = `a*`,
           bstar = `b*`) |>
    filter(depth >= 285.9) |>
    mutate(aob = scale(astar / bstar)[, 1]) |>
    select(depth, aob, everything())
#+end_src
***** remove long-term trends in the depth domain
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:39]
:END:
#+begin_src R :exports none
  fit_loess <- loess(aob ~ depth, data = dat, span = .75)
  fit_gam <- mgcv::gam(aob ~ s(depth, bs = "cs"), data = dat)

  lp <- dat |>
    select(depth, aob## Lstar_scl
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::lowpass(fcut = 1 / 15) # how do you decide which frequency to cull?
  # this is linearly interpolated so it can't go into the other df

  # let's see how sensitive it is to the span or to size of the rolling mean
  dat <- dat |>
    mutate(
      # there are several methods of calculating a rolling average
      ## ma = roll::roll_mean() # that's left-aligned
      ## ma = zoo::rollmean(Lstar, k = 33, align = "center", na.pad = TRUE),
      # I prefer the slider implementation, it's FAAAST
      # I've played around with the size of the window. If I make it larger,
      # more low-frequency peaks are preserved.
      ma = slider::slide_mean(aob,
                              before = 39, after = 39),
      ## loess = predict(fit_loess),
      ## gam = predict(fit_gam),
      scl = scale(aob)[, 1],
      ## loess_scl = scale(aob - loess)[, 1],
      ## gam_scl = scale(aob - loess)[, 1],
      ma_scl = scale(aob - ma)[, 1],
      .by = c(Leg, Site, H))

  dat |>
    ggplot(aes(x = depth, y = aob, group = paste(Leg, Site, H, Core, Sec))) +
    geom_line(aes(colour = H), alpha = .3) +
    ## geom_line(aes(y = loess), colour = "orange") +
    ## geom_line(aes(y = gam), colour = "red") +
    geom_line(aes(y = ma), colour = "indianred")

  dat |>
    ggplot(aes(x = depth, y = aob, group = paste(Leg, Site, H, Core, Sec))) +
    geom_line() +
    ## geom_line(aes(y = loess_scl + 3), colour = "orange") +
    ## geom_line(aes(y = gam_scl + 6), colour = "red") +
    geom_line(aes(y = ma_scl + 9), colour = "indianred")
#+end_src

#+RESULTS:
#+begin_example

----- LOWPASS FILTERING STRATIGRAPHIC SERIES-----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 2794
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 0.025
 ,* New number of samples= 1733
 ,* Number of data points= 1733
 ,* Sample interval= 0.025
 ,* Mean value removed= 0.0958775
 ,* 5 pos/neg frequency pairs and f(0) will be bandpassed
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
#+end_example

**** do analysis in the depth domain
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 12:42]
:END:
***** do spectral analysis
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 12:14]
:END:
#+begin_src R :results output graphics file :file imgs/208-1267B_color_mtm.png :width 900 :height 500
  dat |>
    nested_spectral_analysis(x = depth, y = scl,
                             nest = "H",
                      ## method = "MTM"
                      method = "LOWSPEC"
                      ) |>
    plot_spectrum(group = "H",
                  confidence = TRUE,
                  periods = c(0.4, 0.47, 1.7, 4)) +
    facet_grid(cols = vars(H)) +
    coord_cartesian(xlim = c(0, 5),
                    ylim = c(0,
                             ## 0.01
                             0.002
                             ## 0.0005
                             ))
#+end_src

#+RESULTS:
[[file:imgs/208-1267B_color_mtm.png]]

old code before I had turned this into a package :)
#+begin_src R :eval never
  mtm <- dat |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::mtm(xmax = 6, pl = 1, output = 1) |>
    as_tibble()

  # plot the mtm
  mtm |>
    ggplot(aes(x = Frequency, y = Power)) +
    geom_line() +
    scale_y_log10() +
    scale_x_continuous(
      sec.axis = sec_axis(trans = ~ 1 / .x,
                          name = "Period",
                          breaks = c(.01, .5, .1, 1, 10))) +
    geom_line(aes(y = AR1_fit), colour = "red") +
    geom_line(aes(y = AR1_90_power), colour = "red") +
    geom_line(aes(y = AR1_95_power), colour = "red") +
    geom_line(aes(y = AR1_99_power), colour = "red") +
    # highlight what filters are being used by Husson 2011
    annotate("rect", xmin = 0., xmax = .25, ymin = 1e-5, ymax = 1e-1, alpha = .3, fill = "red") +
    annotate("rect", xmin = 0., xmax = .9, ymin = 1e-5, ymax = 1e-1, alpha = .3, fill = "red") +
#+end_src

***** use taner filters
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 12:16]
:END:
#+begin_src R :exports none
  f100 <- dat |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::taner(flow = .07, fhigh = 0.9, xmax = 3) |>
    as_tibble()

  f405 <- dat |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::taner(flow = .07, fhigh = 0.25, xmax = 1) |>
    as_tibble()

  ## f100_2 <- dat |>
  ##   astrochron::linterp(genplot = FALSE) |>
  ##   astrochron::bandpass(flow = .1, fhigh = .5, win = 1, xmax = 5)
#+end_src

#+RESULTS:
#+begin_example
----- TANER BANDPASS FILTERING STRATIGRAPHIC SERIES-----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 0.025
 ,* New number of samples= 1733
 ,* Number of data points= 1733
 ,* Sample interval= 0.025
 ,* Mean value removed= 0.01953956
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
#+end_example

***** plot the filters and the record
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 12:16]
:END:
#+begin_src R :results output graphics file :file imgs/208-1267B_color.png :width 900 :height 500
  dat |>
    ggplot(aes(x = depth, y = aob)) +
    geom_line(colour = "darkblue") +
    geom_line(data = f100, colour = "skyblue") +
    geom_line(data = f405, colour = "black") +
    # same as MS from Husson 2011 from above
    annotate("rect", xmin = 285.9, xmax = 286.5, ymin = -Inf, ymax = Inf,
             fill = "yellow", alpha = .6) + # the K/T boundary
    coord_cartesian(xlim = c(287.4, NA)) +
    labs(x = "Depth (mbsf)", y = "Norm. a*/b*")
#+end_src

#+caption: Taner filters of ODP208 Site 1267 colour reflectance data.
#+RESULTS:
[[file:imgs/208-1267B_color.png]]

***** get the maxima of the 405 kyr filter
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 12:17]
:END:
#+begin_src R :exports none
  pk405 <- f405 |>
    astrochron::peak() |>
    as_tibble() |>
    mutate(
      n_cyc = 1:n(),
      age_405 = 65940 + n_cyc * 405) # ZB18a eq 2 or 66.96 for eq 3

  pk405 |>
    ggplot(aes(x = Location, y = age_405)) +
    geom_line() + geom_point()

  dat <- dat |>
    mutate(
      age = astrochron::tune(dat,
                   controlPts = pk405 |>
                     select(depth = Location, age_405),
                   extrapolate = TRUE,
                   genplot = FALSE)$X1)

  dat |>
    ggplot(aes(x = age, y = aob)) +
    geom_line()

  dat |>
    select(age, aob) |>
    mutate(aob = aob - slider::slide_mean(aob, before = 200, after = 200)) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::mtm(xmax = .06)
#+end_src

#+RESULTS:
#+begin_example
----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
 ,* Number of data points= 1733
 ,* Number of columns= 2
 ,* Identifying maxima of peaks
 ,* Number of peaks identified= 9

 ,* No filtering of peaks applied.
+ + + +
----- TUNING STRATIGRAPHIC SERIES -----
 ,* Number of data points= 1840
 ,* Number of time control points= 9
 ,* Sorting datasets into ensure increasing order, removing empty entries

,**** WARNING: duplicate depth/height datum found in dat

 ,* Mean sampling interval= 2.096929
 ,* Median sampling interval= 2.154255
 ,* Maximum sampling interval= 7.941176
 ,* Minimum sampling interval= 0
----- PERFORMING Multitaper Spectral Analysis -----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 2.154255
 ,* New number of samples= 1791
 ,* Number of data points in stratigraphic series: 1791
 ,* Stratigraphic series length (space or time): 3856.117
 ,* Sampling interval (space or time): 2.154255
 ,* Will use default setting of 5 DPSS tapers
 ,* Mean value subtracted= 0.00882429
 ,* Linear trend NOT subtracted
 ,* Nyquist frequency: 0.2320988
 ,* Rayleigh frequency: 0.0002591834
 ,* MTM Power spectrum bandwidth resolution (halfwidth): 0.0007775503
 ,* Padded to 8956 points

 ,* Searching for significant spectral peaks that satisfy 90 % CL
     requirements outlined in Meyers (2012):
 ,* Number of significant F-test peaks identified = 33
ID  / Frequency / Period / Harmonic_CL / Rednoise_CL
1   0.002798869   357.2872   90.68548   98.53344
2   0.003835487   260.7231   96.06114   96.35961
3   0.007256326   137.8108   97.68282   82.70286
4   0.02752221   36.33429   97.5   80.64475
5   0.02829967   35.3361   93.87141   79.03028
6   0.02933629   34.08747   99.54662   93.66677
7   0.0411019   24.32977   98.98623   84.84235
8   0.0531785   18.80459   95.4257   74.80281
9   0.05447427   18.35729   99.89771   95.87553
10   0.06287088   15.90561   95.22755   97.11556
11   0.06395933   15.63494   93.02414   89.89813
12   0.06696552   14.93306   91.90037   73.29973
13   0.0681058   14.68304   98.00992   82.16992
14   0.07474016   13.37969   99.96271   91.50175
15   0.07852381   12.73499   97.43281   65.44862
16   0.09231083   10.83296   95.61134   89.70635
17   0.09422857   10.61249   99.31377   99.89063
18   0.1000855   9.991461   93.88109   76.57064
19   0.1010184   9.899185   98.41569   72.34155
20   0.102677   9.739278   90.12556   94.56918
21   0.1049576   9.52766   97.28039   85.37081
22   0.1077564   9.280188   91.26549   72.50968
23   0.1085339   9.213711   97.25827   90.16475
24   0.1096224   9.122227   94.33675   77.94989
25   0.112784   8.866503   96.57953   69.30783
26   0.1211806   8.252143   96.03697   56.31232
27   0.1220099   8.196054   98.88495   84.78227
28   0.1249643   8.002286   99.84032   79.34508
29   0.1367817   7.310917   91.50361   88.80223
30   0.1441936   6.935122   90.96567   94.40426
31   0.1635265   6.115217   95.39002   85.09184
32   0.167051   5.986196   95.01506   91.9216
33   0.1933293   5.172523   94.30443   84.0192
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
#+end_example

***** do mtm analysis  in the depth domain
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:55]
:END:
#+begin_src R :exports none
  dat |>
    drop_na() |>
    select(depth,
           ## aob
           ## Lstar,
           ## loess_scl
           ## gam_scl
           ma_scl
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::mtm(output = 1, xmax = 10) |>
    as_tibble()
#+end_src

#+RESULTS:
#+begin_example
----- PERFORMING Multitaper Spectral Analysis -----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 0.025
 ,* New number of samples= 1733
 ,* Number of data points in stratigraphic series: 1733
 ,* Stratigraphic series length (space or time): 43.3
 ,* Sampling interval (space or time): 0.025
 ,* Will use default setting of 5 DPSS tapers
 ,* Mean value subtracted= -0.007338007
 ,* Linear trend NOT subtracted
 ,* Nyquist frequency: 20
 ,* Rayleigh frequency: 0.02308136
 ,* MTM Power spectrum bandwidth resolution (halfwidth): 0.06924409
 ,* Padded to 8666 points

 ,* Searching for significant spectral peaks that satisfy 90 % CL
     requirements outlined in Meyers (2012):
 ,* Number of significant F-test peaks identified = 46
ID  / Frequency / Period / Harmonic_CL / Rednoise_CL
1   0.1477037   6.770312   97.81888   70.95153
2   0.3507962   2.850658   96.15821   99.83479
3   0.549273   1.820588   99.93298   95.71491
4   0.6600508   1.515035   91.60759   59.35608
5   2.506347   0.3989871   99.90005   97.14331
6   2.594046   0.3854982   92.58703   84.48891
7   4.264943   0.2344697   92.27711   88.87931
8   5.67736   0.1761382   96.11432   89.04281
9   6.106624   0.1637566   99.97548   64.3143
10   7.957535   0.1256671   98.05545   84.35803
11   8.156012   0.1226089   99.56947   93.36902
12   8.636049   0.1157937   93.82859   89.15123
13   9.162243   0.1091436   94.41139   94.81218
14   9.254558   0.1080549   97.05078   90.86573
15   9.780752   0.1022416   99.25119   89.55859
16   10.58389   0.09448321   97.63315   95.10522
17   11.0547   0.09045929   95.32547   71.18952
18   11.17009   0.08952479   93.37106   94.26625
19   11.23933   0.08897331   94.40806   69.16598
20   11.34549   0.08814076   97.58416   82.10638
21   11.65474   0.08580198   96.48069   92.10786
22   12.3748   0.0808094   95.1167   97.58248
23   12.6379   0.0791271   93.62709   93.73139
24   12.91946   0.07740264   93.56098   98.65819
25   13.021   0.07679901   99.36458   62.45722
26   13.99954   0.07143093   93.03784   69.10545
27   14.09647   0.07093975   99.06973   99.20623
28   14.3688   0.06959525   98.68524   64.65251
29   14.43803   0.06926151   98.14767   87.79034
30   14.62266   0.06838699   93.01484   71.31289
31   14.81652   0.06749221   93.2065   96.91767
32   14.92269   0.06701206   98.81679   88.57128
33   15.26425   0.06551255   90.33441   64.59363
34   15.31964   0.06527569   90.22784   91.29449
35   15.62428   0.06400295   97.42037   85.11671
36   16.00277   0.06248918   97.92532   68.65022
37   17.09208   0.05850662   94.69208   88.55884
38   17.56751   0.05692328   94.97037   98.45663
39   17.70598   0.0564781   95.89307   66.52896
40   17.7706   0.05627273   94.15521   82.41941
41   17.80291   0.0561706   94.19327   72.928
42   17.91369   0.05582324   99.42919   89.47333
43   18.30141   0.05464061   90.11566   73.50925
44   18.47681   0.05412191   99.35983   57.57737
45   18.5645   0.05386624   99.42766   59.69106
46   19.87076   0.0503252   99.85037   87.35517
# A tibble: 4,332 × 8
   Frequency   Power Harmonic_CL AR1_CL AR1_fit AR1_90_power AR1_95_power AR1_99_power
       <dbl>   <dbl>       <dbl>  <dbl>   <dbl>        <dbl>        <dbl>        <dbl>
 1   0.00462 0.00286        13.7   56.8 0.00283      0.00452      0.00518      0.00656
 2   0.00923 0.00276        10.4   53.9 0.00283      0.00452      0.00518      0.00656
 3   0.0138  0.00263        11.0   49.5 0.00283      0.00452      0.00518      0.00656
 4   0.0185  0.00248        25.8   44.7 0.00283      0.00452      0.00518      0.00656
 5   0.0231  0.00232        57.8   39.0 0.00283      0.00452      0.00518      0.00656
 6   0.0277  0.00214        87.9   33.0 0.00283      0.00452      0.00518      0.00656
 7   0.0323  0.00201        98.8   28.5 0.00283      0.00452      0.00518      0.00656
 8   0.0369  0.00193       100.    25.8 0.00283      0.00452      0.00518      0.00656
 9   0.0415  0.00186       100.    23.4 0.00283      0.00452      0.00518      0.00656
10   0.0462  0.00175        99.1   20.0 0.00283      0.00452      0.00518      0.00656
# ℹ 4,322 more rows
# ℹ Use `print(n = ...)` to see more rows
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
#+end_example

***** bandpass filtering in the depth domain
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:56]
:END:
#+begin_src R :exports none
  # I like gam I think?
  filt_bp_2.4 <- dat |>
    drop_na() |>
    select(depth, gam_scl) |>
    astrochron::linterp(genplot = FALSE) |>
    # this is peak no 1
    astrochron::bandpass(flow = 0.042 - .15 * .042, fhigh = 0.042 + .15 * .042, win = 1, xmax = 1) |> # gaussian window
    ## astrochron::taner(flow = 0, fhigh = .3, xmax = 1) |> # taner window
    as_tibble()

  filt_bp_405 <- dat |>
    drop_na() |>
    select(depth,
           ## gam_scl
           ma_scl
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    ## astrochron::bandpass(flow = 0, fhigh = .3, win = 0, xmax = 1) |> # uniform window
    # this is peak no 2, no 3 = 0.5 (based on gam_scl)
    ## astrochron::bandpass(flow = 0.35 - .15 * .35, fhigh = 0.35 + .15 * .35, win = 1, xmax = 1) |> # gaussian window
    # this is based on the ma_scl, peak number 1 appears: 0.1477
    astrochron::bandpass(flow = 0.148 - .15 * .148, fhigh = 0.148 + .15 * .148, win = 1, xmax = 1) |> # gaussian window
    ## astrochron::taner(flow = 0, fhigh = .3, xmax = 1) |> # taner window
    as_tibble()

  filt_bp_100 <- dat |>
    drop_na() |>
    select(depth,
           ## gam_scl
           ma_scl
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    ## astrochron::bandpass(flow = 0, fhigh = .3, win = 0, xmax = 1) |> # uniform window
    # this is peak no. 5/6
    ## astrochron::bandpass(flow = 2.51 - .15 * 2.51, fhigh = 2.51 + .15 * 2.51, win = 1, xmax = 10) |> # gaussian window
    # this is ma_scl peak no. 3
    astrochron::bandpass(flow = 0.55 - .15 * .55, fhigh = .55 + .15 * .55, win = 1, xmax = 10) |> # gaussian window
    ## astrochron::taner(flow = 0, fhigh = .3, xmax = 1) |> # taner window
    as_tibble()

  filt_bp_prec <- dat |>
    drop_na() |>
    select(depth,
           ## gam_scl
           ma_scl
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    ## astrochron::bandpass(flow = 0, fhigh = .3, win = 0, xmax = 1) |> # uniform window
    # this is peak no. 9
    ## astrochron::bandpass(flow = 7.96 - .15 * 7.69, fhigh = 7.96 + .15 * 7.96, win = 1, xmax = 10) |> # gaussian window
    # this is ma_scl peak no. 5/6
    astrochron::bandpass(flow = 2.55 - .15 * 2.55, fhigh = 2.55 + .15 * 2.55, win = 1, xmax = 10) |> # gaussian window
    ## astrochron::taner(flow = 0, fhigh = .3, xmax = 1) |> # taner window
    as_tibble()

  filt_hb <- filt_bp_prec |>
    astrochron::hilbert(genplot = TRUE, output = TRUE) |>
    ## astrochron::peak() |>
    as_tibble()
#+end_src

#+RESULTS:
#+begin_example
----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 0.025
 ,* New number of samples= 1733
 ,* Number of data points= 1733
 ,* Sample interval= 0.025
 ,* Mean value removed= -0.01233601
 ,* Center of bandpass filter = 0.042
 ,* 1 pos/neg frequency pairs will be bandpassed
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 0.025
 ,* New number of samples= 1733
 ,* Number of data points= 1733
 ,* Sample interval= 0.025
 ,* Mean value removed= -0.007338007
 ,* Center of bandpass filter = 0.148
 ,* 4 pos/neg frequency pairs will be bandpassed
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 0.025
 ,* New number of samples= 1733
 ,* Number of data points= 1733
 ,* Sample interval= 0.025
 ,* Mean value removed= -0.007338007
 ,* Center of bandpass filter = 0.55
 ,* 14 pos/neg frequency pairs will be bandpassed
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 0.025
 ,* New number of samples= 1733
 ,* Number of data points= 1733
 ,* Sample interval= 0.025
 ,* Mean value removed= -0.007338007
 ,* Center of bandpass filter = 2.55
 ,* 67 pos/neg frequency pairs will be bandpassed
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
----- PERFORMING HILBERT TRANSFORM ON STRATIGRAPHIC SERIES -----
 ,* Number of data points= 1733
 ,* Sample interval= 0.025
 ,* Mean value removed= -0.007241137
#+end_example

***** plot the filters
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:56]
:END:
#+begin_src R :exports none
  dat |>
    ggplot(aes(x = depth, y = ma_scl)) +
    geom_line(alpha = .3) +
    ## geom_line(aes(colour = "precession?"), data = filt_bp_prec) +
    geom_line(aes(colour = "100 kyr"), data = filt_bp_100) +
    geom_line(aes(colour = "405 kyr"), data = filt_bp_405) #+
    ## geom_line(aes(colour = "2.4 Myr"), data = filt_bp_2.4) #+
    ## geom_line(aes(colour = "Hilbert transform of prec", x = depth, y = envelope), data = filt_hb)
#+end_src

#+RESULTS:

***** get the peaks of the 405 kyr filter
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 13:51]
:END:
#+begin_src R :exports none
  agem_405 <- filt_bp_405 |>
    astrochron::peak() |>
    as_tibble() |>
    mutate(
      n_cyc = 1:n(),
      age_405 = 65940 + n_cyc * 405) # ZB18a eq 2 or 66.96 for eq 3


  dat |>
    mutate(age_405 = Hmisc::approxExtrap(agem_405$Location, agem_405$age_405,
                                         xout = depth)$y) |>
    ggplot(aes(x = age_405, y = aob)) +
    geom_line()
#+end_src

#+RESULTS:
: ----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
:  * Number of data points= 1733
:  * Number of columns= 2
:  * Identifying maxima of peaks
:  * Number of peaks identified= 7
:
:  * No filtering of peaks applied.

***** combine the filters into an eccentricity curve
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 13:15]
:END:
#+begin_src R :exports none
  filt_bp_405 |>
    rename(f405 = ma_scl) |>
    mutate(f100 = filt_bp_100$ma_scl) |>
    mutate(f405s = scale(f405)[, 1],
           f100s = scale(f100)[, 1],
           ecc = f405s + f100s, # with arbitrary scaling
           ecc2 = f405 + f100,
           ) |> # just the raw spectral output
    ggplot(aes(x = depth, y = ecc)) +
    geom_line()
#+end_src

#+RESULTS:
***** what if we look at EHA, do we see sed changes?
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 14:30]
:END:
#+begin_src R :exports none
  dat |>
    select(
      depth,
      ## aob
      ## scl
      ## gam_scl
      ## loess_scl
      ma_scl
    ) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::eha(fmax = 10, ydir = -1, pad = 1000, pl = 1)
#+end_src

#+RESULTS:
#+begin_example
----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 0.025
 ,* New number of samples= 1733

 ----- PERFORMING EVOLUTIVE HARMONIC ANALYSIS -----
 ,* Number of data points in stratigraphic series: 1733
 ,* Stratigraphic series length (space or time): 43.3
 ,* Sampling interval (space or time): 0.025
 ,* Number of data points per window: 101
 ,* Moving window size (space or time): 2.5
 ,* Window step points: 10
 ,* Window step (space or time): 0.25
 ,* Number of windows: 164
 ,* Mean value for each window will be subtracted
 ,* Linear trend for each window will be subtracted
 ,* Nyquist frequency: 20
 ,* Rayleigh frequency: 0.3960396
 ,* MTM Power spectrum bandwidth resolution (halfwidth): 0.7920792
 ,* Will use 3 DPSS tapers
 ,* Padded to 1000 points
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
#+end_example

**** add rmcd depth and create splice for colour data
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:39]
:END:
#+begin_src R :exports none
  col <- ODP208_1267_color_A |>
    mutate(Sec = as.character(Sec)) |>
    bind_rows(ODP208_1267_color_B) |>
    get_rmcd() |>
    # this CC isn't included correctly
    mutate(on_splice = if_else(H == "B" & Core == 33 & Sec == "CC", TRUE, on_splice))
#+end_src

#+RESULTS:
#+begin_example
indexing ODP208_1267_rmcd.csv [====================================================] 477.38MB/s, eta:  0s                                                                                                                                            Rows: 61 Columns: 9
── Column specification ─────────────────────────────────────────────────────────────────────────────────
Delimiter: ","
chr (3): label, link, label2
dbl (6): interval, depth_mbsf, depth_rmcd, interval2, depth_mbsf2, depth_rmcd2

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Joining with `by = join_by(Site, H, Core, T)`
left_join: added 8 columns (top, to, section, interval, depth_mbsf, …)
rows only in x    3,908
rows only in y  (     1)
matched rows     34,671
                ========
rows total       38,579
Joining with `by = join_by(Site, H, Core, T)`
left_join: added 8 columns (from, bot, section2, interval2, depth_mbsf2, …)
rows only in x    3,975
rows only in y  (     1)
matched rows     34,604
                ========
rows total       38,579
#+end_example

**** plot the colour data vs rmcd
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 15:00]
:END:

#+begin_src R :results output graphics file :file imgs/ODP208_1267_colour_rmcd.png :width 900
  col |>
    ggplot(aes(x = my_rmcd,
               ## y = `L*`,
               y = `a*` / `b*`,
               colour = H, group = paste(H, Core, T, Sec),
               Sec = Sec)) +
    geom_line(aes(alpha = on_splice)) +
    coord_cartesian(xlim = c(320., NA), ylim = c(0.2, .9))
#+end_src

#+caption: Colour reflecatance data for ODP 208 Site 1267 on the rmcd.
#+RESULTS:
[[file:imgs/ODP208_1267_colour_rmcd.png]]

**** clean up colour data
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 13:43]
:END:
#+begin_src R :exports none
  col_w <- col |>
    tidylog::filter(
               !is.na(my_rmcd),
               ## my_rmcd > 319.46,
               my_rmcd > 320.35, # the depth of the K/T massive shift in MS and colour
               on_splice) |>
    ## mutate(var = `a*`) |>
    ## mutate(var = `b*`) |> # or `L*`
    ## mutate(var = `a*` / `b*`) |> # or `L*`
    mutate(var = `L*`) |> # or `L*`
    mutate(scl_ma = scale(var - slider::slide_mean(var,
                                                   before = 200,
                                                   after = 200)))
#+end_src

#+RESULTS:
: filter: removed 35,321 rows (92%), 3,258 rows remaining

**** create wavelet with rmcd vs L*
#+begin_src R :results graphics file :file imgs/ODP208_1267_color_wavelet.png :width 800
  ## library(biwavelet)
  library(WaverideR)

  ## par(oma = c(0, 0, 0, 1), mar = c(5, 4, 4, 5) + .1)
  col_w |>
    select(depth = my_rmcd, scl_ma) |>
    ## astrochron::linterp(genplot = FALSE) |>
    ## biwavelet::wt(sig.level = .95) |>
    ## plot(plot.cb = TRUE,
    ##      plot.phase = FALSE,
    ##      xlab = "Depth (rmcd)",
    ##      main = "L*",
    ##      fill.cols = viridis::inferno(n = 64))
    # let's try waverider!
    WaverideR::analyze_wavelet(lowerPeriod = .3,
                               upperPeriod = 20,
                               omega_nr = 8,
                               ## verbose = TRUE
                               ) |>
    WaverideR::plot_wavelet(palette_name = "inferno",
                            siglvl = .95,
                            dev_new = FALSE,
                            ## add_avg = TRUE,
                            add_MTM = TRUE, # NOT WORKING!
                            add_MTM_peaks = TRUE)

#+end_src

#+caption: Wavelet of ODP 208 Site 1267 in the rmcd domain.
#+RESULTS:
[[file:imgs/ODP208_1267_color_wavelet.png]]

**** apply agemodel to colour data
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 12:09]
:END:
#+begin_src R :exports none
  col <- col |>
    mutate(age = approx(agem2$depth_rmcd, agem2$age_ma,
                        xout = my_rmcd)$y,
           age_Neptune = if_else(H == "B",
                                 approx(agem3$`Depth (mbsf)`, agem3$`Age (Ma)`,
                                        xout = `Depth (mbsf)`)$y,
                                 NA_real_))



  col |>
    ggplot(aes(x = age, y = `L*`,
               group = paste(H, Core, Sec),
               Sec = Sec)) +
    geom_line(aes(colour = H, alpha = on_splice)) #+
    ## geom_line(aes(x = age_Neptune, y = `L*`))
#+end_src

#+RESULTS:

**** do spectral analysis of the splice in the time domain
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 12:44]
:END:
interesting! There's almost no 405 kyr cyclicity in there, probably b/c it was tuned to 100 kyr cycles exactly?

#+begin_src R :exports none
  col_ <- col |>
    filter(!is.na(age),
           age > 66,
           on_splice) |>
    mutate(aob = `a*` / `b*`,
           scl = scale(aob)[, 1])

  col_N <- col |>
    filter(!is.na(age_Neptune),
           age_Neptune > 66) |>
    mutate(aob = `a*` / `b*`,
           scl = scale(aob)[, 1])

  col_ |>
    ggplot(aes(x = age, y = scl, colour = H, group = paste(H, Core, Sec))) +
    geom_line() +
    geom_smooth(aes(group = "all"))
    ## geom_line(linetype = "dashed")

  col_N |>
    ggplot(aes(x = age, y = scl, colour = H, group = paste(H, Core, Sec))) +
    geom_line() +
    geom_smooth(aes(group = "all"))

  fit_gam_col <- mgcv::gam(scl ~ s(age, bs = "cs"), data = col_)
  fit_gam_col_N <- mgcv::gam(scl ~ s(age, bs = "cs"), data = col_N)

  col_ |>
    mutate(gam = predict(fit_gam_col) |> as.vector()) |>
    mutate(scl_gam = scl - gam) |>
    mutate(scl_ma = slider::slide_mean(scl, before = 2, after = 2)) |>
    mutate(age = age * 1e3) |>
    ## ggplot(aes(x = scl_gam)) + geom_density()
    select(age,
           ## scl #> gives 2.975 Myr cycle
           ## scl_gam #> 316
           scl_ma #> 2.975 Myr + 125 kyr + 106 kyr, if I increase the size it's just 125 kyr and 106 kyr
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::mtm(xmax = 0.06)
  # I keep getting a 316 kyr cycle and a 188 and a 125 kyr
  # but maybe this was tuned to 100 kyr equidistant?

  col_N |>
    mutate(gam = predict(fit_gam_col_N) |> as.vector()) |>
    mutate(scl_gam = scl - gam) |>
    mutate(scl_ma = slider::slide_mean(scl, before = 1, after = 1)) |>
    mutate(age = age * 1e3) |>
    ## ggplot(aes(x = scl_gam)) + geom_density()
    select(age,
           ## scl #> 2.712 Myr + 27 kyr ...
           scl_gam #> 301 kyr + 188 kyr + 124 kyr + 106 kyr + 27 kyr
           ## scl_ma #> size 2: 2.712 Myr + 124 kyr + 107 kyr + 78 + 70 ... kyr
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    ## astrochron::mtm(xmax = 0.06)
    astrochron::mtm(xmax = 0.06)
  # I keep getting a 300 kyr cycle and a 188 and a 124 and 106
  # even though this one was NOT tuned to 100 kyr cycle

  col_ |>
    mutate(scl_ma = slider::slide_mean(scl, before = 2, after = 2)) |>
    mutate(age = age * 1e3) |>
    ## ggplot(aes(x = scl_gam)) + geom_density()
    select(age, scl_ma) |>
    astrochron::linterp(genplot = FALSE) |>
    # this is 124 kyr
    astrochron::bandpass(flow = 0.008 - .15 * 0.008, fhigh = .008 + .15 * .008, xmax = .006)

  col_N |>
    mutate(scl_ma = slider::slide_mean(scl, before = 2, after = 2)) |>
    mutate(age = age * 1e3) |>
    ## ggplot(aes(x = scl_gam)) + geom_density()
    select(age, scl_ma) |>
    astrochron::linterp(genplot = FALSE) |>
    # this is 106 kyr
    astrochron::bandpass(flow = 0.0094 - .15 * 0.0094, fhigh = .0094 + .15 * .0094, xmax = .006)

  # try and get the 405 kyr even though it isn't really there in the mtm
  col_N |>
    mutate(scl_ma = slider::slide_mean(scl, before = 2, after = 2)) |>
    mutate(age = age * 1e3) |>
    ## ggplot(aes(x = scl_gam)) + geom_density()
    select(age, scl_ma) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::bandpass(flow = 0.0094 - .15 * 0.0094, fhigh = .0094 + .15 * .0094, xmax = .006)
#+end_src


*** Fe count
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 21:14]
:END:
From [cite:@Westerhold2008].

overview of all supplementary data on PANGAEA
https://doi.pangaea.de/10.1594/PANGAEA.667122

Title says "astronomical calibration of the Paleocene time".

- depth sed [m] from 234 m to 295 m
- depth revised [m] from 265 m to 330 m

#+begin_src R :results graphics file :file imgs/ODP208_1267_Fe.png :width 800
  ODP208_1267_Fe <- pangaear::pg_data("10.1594/PANGAEA.666120")

  ## ODP208_1267_magstrat <- pangaear::pg_data("10.1594/PANGAEA.666515")

  dat <- ODP208_1267_Fe[[1]]$data |>
    tidylog::filter(`Depth revised [m]` > 319.46) |>
    mutate(var = scale(`Fe count [#]`)[, 1], #log(`Fe count [#]`),
           scl_ma = scale(var -
                          slider::slide_mean(var,
                                             before = 5, after = 5))[, 1])

  dat |>
    ggplot(aes(x = `Depth revised [m]`, y = var)) +
    geom_line() #+
    ## geom_line(aes(y = scl_ma))
#+end_src

#+caption: ODP 208 Site 1267 Fe data from [cite:@Westerhold2008].
#+RESULTS:
[[file:imgs/ODP208_1267_Fe.png]]

#+begin_src R :results graphics file :file imgs/ODP208_1267_Fe_wavelet.png :width 800
  par(oma = c(0, 0, 0, 1), mar = c(5, 4, 4, 5) + .1)
  dat |>
    select(depth = `Depth revised [m]`,
           ## scl_ma
           var
           ) |>
    ## filter(depth <= 324.59) |>
    ## filter(depth >= 324.59 & depth <= 328.96) |>
    astrochron::linterp(genplot = FALSE) |>
    biwavelet::wt(sig.level = .95) |>
    plot(plot.cb = TRUE,
         plot.phase = FALSE,
         xlab = "Depth (rmcd)",
         main = "Fe [#]",
         fill.cols = viridis::inferno(n = 64))
#+end_src

#+RESULTS:
[[file:imgs/ODP208_1267_Fe_wavelet.png]]

*** CaCO3 dataset
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 09:06]
:END:
From [cite:@Sexton2011].

Too young!

- depth sed [m] from 154 m to 163 m.
- depth comp [mcd] from to 168 m to 180 m
- age [ka BP] from 47800 ka to 50002 ka.

#+begin_src R :exports none
  ODP208_1267_CaCO3 <- pangaear::pg_data("10.1594/PANGAEA.763155")
  ODP208_1267_CaCO3[[1]]$data |>
    ggplot(aes(x = `Depth comp [mcd]`, y = `CaCO3 [%]`)) +
    geom_line()
#+end_src

#+RESULTS:
: Downloading 1 datasets from 10.1594/PANGAEA.763155
: Processing 1 files

** [#B] IODP Exp 342 Site U1403A,B
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 15:29]
:END:
:LOGBOOK:
- Note taken on [2024-01-18 Thu 16:32] \\
  just found this again, seems pretty nice actually?
:END:
[cite:@Batenburg2018]
- d18O data between 66 Ma and 68.8 Ma
- XRF ln(Fe/Ca) data between 66.0 Ma and 68.8 Ma

That corresponds to Ma_{405}1 to Ma_{405}7

+I haven't looked at this beyond getting the data and creating below two plots!+
I've now quickly created the spectra for both, but haven't looked at it in more detail! Once I've developed my functions well this should be quick to try as well!

Very low sedimentation rate however, about 1 cm/kyr.
*** d13C and d18O
:PROPERTIES:
:CREATED:  [2023-10-02 Mon 13:49]
:END:
#+begin_src R :results output graphics file :file imgs/342-U1403A_d18O_Batenburg2018-fig7.png :width 900 :height 500
  IODP342_U1403A <- pangaear::pg_data("10.1594/PANGAEA.875741")[[1]]
  dat <- IODP342_U1403A$data

  dat |>
    ggplot(aes(x = `Depth comp r [rmcd]`, y = `δ18O carb [‰ PDB]`)) +
    geom_line()
#+end_src

#+caption: IODP 343 Site U1403B d18O data (d13C also available!) from [cite:@Batenburg2018].
#+RESULTS:
[[file:imgs/342-U1403A_d18O_Batenburg2018-fig7.png]]

**** spectral analysis of the d18O data
:PROPERTIES:
:CREATED:  [2023-10-02 Mon 13:52]
:END:
#+begin_src R :results output graphics file :file imgs/IODP342_U1403_d18O_spec.png :width 800
  dat |>
    mutate(ref = "Batenburg et al., 2018") |>
    nested_spectral_analysis(nest = "ref",
                      x = `Depth comp r [rmcd]`,
                      y = `δ18O carb [‰ PDB]`) |>
    plot_spectrum(logy = TRUE) +
    labs(title = "IODP 342 U1403 δ18O")
#+end_src

#+caption: Spectral analysis of d18O data.
#+RESULTS:
[[file:imgs/IODP342_U1403_d18O_spec.png]]

*** XRF data
:PROPERTIES:
:CREATED:  [2023-10-02 Mon 13:49]
:END:
#+begin_src R :results output graphics file :file imgs/342-U1403A_FeCa_Batenburg2018-fig6.png :width 900 :height 500
  IODP342_U1403A_XRF <- pangaear::pg_data("10.1594/PANGAEA.875742")[[1]]

  dat <- IODP342_U1403A_XRF$data

  bp <- dat |>
    mutate(FeCa = log(`Fe count [#]` / `Ca count [#]`)) |>
    select(depth = `Depth comp r [rmcd]`, FeCa) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::bandpass(flow = 1 / 3.4, fhigh = 1 / 6.8)

  # copied from [cite:@Batenburg2018] table 2
  agem <- tibble::tribble(
                     ~ `Depth comp r [rmcd]`, ~ age_ma, ~ sed_rate,
                     247.700, 66.04, NA_real_,
                     251.040, 66.374, 1.00,
                     254.960, 66.782, 0.96,
                     259.205, 67.192, 1.04,
                     263.695, 67.585, 1.14,
                     268.365, 67.986, 1.16,
                     271.680, 68.383, 0.84,
                     274.635, 68.787, 0.73,
                     275.000, 68.837, 0.73
                   )

  dat |>
    ggplot(aes(x = `Depth comp r [rmcd]`, y = log(`Fe count [#]` / `Ca count [#]`))) +
    geom_line() +
    geom_line(aes(x = depth, y = FeCa), data = bp, colour = "red") +
    ## annotate("text", x = 247.7, y = 2, label = "about 66 Ma") +
    ## annotate("text", x = 275, y = 2, label = "about 68.5 Ma") +
    geom_label(aes(label = age_ma, y = 1.9), data = agem) +
    labs(title = "IODP342 U1403A XRF")
#+end_src

#+caption: IODP 342 Site U1403 XRF data from [cite:@Batenburg2018].
#+RESULTS:
[[file:imgs/342-U1403A_FeCa_Batenburg2018-fig6.png]]

**** Fe/Ca spec
:PROPERTIES:
:CREATED:  [2023-10-02 Mon 13:55]
:END:
#+begin_src R :results output graphics file :file imgs/IODP342_U1403_logFeCa_spec.png :width 800
  dat |>
    mutate(ref = "Batenburg et al., 2018") |>
    mutate(FeCa = log(`Fe count [#]` / `Ca count [#]`)) |>
    nested_spectral_analysis(nest = "ref",
                      x = `Depth comp r [rmcd]`,
                      y = FeCa) |>
    plot_spectrum() +
    labs(title = "IODP 342 U1403 log(Fe/Ca)")
#+end_src

#+RESULTS:
[[file:imgs/IODP342_U1403_logFeCa_spec.png]]

** [#A] Zumaia and Sopelana
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 15:37]
:VISIBILITY: children
:CUSTOM_ID: sec:Zumaia-Sopelana
:END:
[cite:@Batenburg2012]
Ma_{405}1 to Ma_{405}9
66 Ma to ~70 Ma

Has some turbidites according to [[id:107d5e85-9f0d-4193-941d-7b8887fa4d28][Frits Hilgen]].

[cite:@Batenburg2014] has Sopelana expansion downwards.

*** Read the data
From the supplementary info of [cite:@Batenburg2012;@Batenburg2014].
**** MS, L*, d13C: Batenburg 2012, 2014
:PROPERTIES:
:CREATED:  [2024-01-18 Thu 16:47]
:END:
[cite:@Batenburg2012;@Batenburg2014].

#+begin_src R :exports code
  # Batenburg et al., 2012
  Zumaia <- readxl::read_excel("dat/Batenburg2012/1-s2.0-S0012821X12005742-mmc2.xls") |>
    rename(depth = Depth,
           MS = `Magentic susceptibility (SI)`, # notice typo! XD
           Lstar = `Reflectance, L* (%)`,
           d13C = `δ13C (‰VPDB) outliers in italics`) |>
    mutate(depth = depth / 100) # convert from cm to m?

  # Batenburg et. al., 2014
  Sopelana <- readr::read_csv("dat/Batenburg2014/18696_2.csv",
                                 skip = 2,
                                 col_names = c("depth", "MS", "", "depth_comp_mm", "Lstar"),
                                 col_select = c(1, 2, 5))
  # I have double-checked that the depth_comp_m and depth_comp_mm are identical throughout
  ## Sopelana |>
  ## mutate(same = depth_comp_m == depth_comp_mm) |>
  ## filter(!same)

  # assemble them all in a single df
  comp <- Zumaia |>
    pivot_longer(MS:d13C, names_to = "proxy") |>
    mutate(comment = if_else(proxy == "d13C", comment, NA_character_)) |>
    tidylog::filter(is.na(comment) | comment != "outlier") |>
    tidylog::filter(!is.na(value)) |>
    mutate(site = "Zumaia", .before = depth) |>
    bind_rows(
      Sopelana |>
      pivot_longer(MS:Lstar, names_to = "proxy") |>
      mutate(site = "Sopelana")
    ) |>
    tidylog::select(site, proxy, depth, value, comment)
#+end_src

#+RESULTS:
#+begin_example
-/                                                                                                                                                            /                                                                                                                                                            -                                                                                                                                                            > > > . + indexing 18696_2.csv [====================================================================================================================] 1.99GB/s, eta:  0s                                                                                                                                                                                                 New names:
• `` -> `...3`
Rows: 629 Columns: 3
── Column specification ──────────────────────────────────────────────────────
Delimiter: ","
dbl (3): depth, MS, Lstar

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
filter: removed 5 rows (<1%), 4,159 rows remaining
filter: removed 1,045 rows (25%), 3,114 rows remaining
select: columns reordered (site, proxy, depth, value, comment)
#+end_example

**** Age Model
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 11:01]
:END:
Load the identified 405-kyr minima from the field of [cite:@Batenburg2012;@Batenburg2014].

Note that I had to read the minima for Sopelana from the figure, so they may be a bit less accurate.

#+begin_src R :exports both
  agem <- read_csv("dat/Batenburg2012/405_minima.csv")

  # NOTE: original is only the age model for Zumaia! We add the Sopelana
  # age model by reading some values from their figure.
  agem_simple <- agem |>
    mutate(n = 0:(n() - 1), .before = comment, .by = minmax) |>
    filter(minmax == "minimum") |>
    select(-strat_top, -minmax, -desc) |>
    mutate(site = "Zumaia") |>
    # let's add the age model for Sopelana
    # copied manually by reading figure 3 in Batenburg et al., 2014!
    bind_rows(
      tribble(
        ~ n, ~ strat_bot,
        10, 149,
        11, 160,
        12, 171,
        13, 183) |>
      mutate(site = "Sopelana")
    ) #|>

  agem_indep <- agem_simple |>
    mutate(age_floating = n * 405) # in kyr

  agem_sol <- agem_simple |>
    ## mutate(age = n * 405)
    mutate(sol = list(target_astronomical_solutions)) |>
    unnest(cols = c(sol)) |>
    nest(.by = sol) |>
    # TODO: this is still wrong, strat = 0 = K/Pg boundary but in Batenburg
    # et al., 2012 they list 0 as "close to" the first 405 kyr minimum.
    mutate(age = case_when(sol == "ZB18a" ~
                             sln_peaks |>
                             filter(sln == "ZB18a", age >= 65.9 * 1e3 - 200) |>
                             arrange(age) |>
                             slice(1:14) |>
                             pull(age) |> list(),
                           sol == "ZB20a" ~
                             sln_peaks |>
                             filter(sln == "ZB20a", age >= 65.9 * 1e3 - 200) |>
                             arrange(age) |>
                             slice(1:14) |>
                             pull(age) |> list(),
                           sol == "ZB20b" ~
                             sln_peaks |>
                             filter(sln == "ZB20b", age >= 65.9 * 1e3 - 200) |>
                             arrange(age) |>
                             slice(1:14) |>
                             pull(age) |> list(),
                           sol == "ZB20c" ~
                             sln_peaks |>
                             filter(sln == "ZB20c", age >= 65.9 * 1e3 - 200) |>
                             arrange(age) |>
                             slice(1:14) |>
                             pull(age) |> list(),
                           sol == "ZB20d" ~
                             sln_peaks |>
                             filter(sln == "ZB20d", age >= 65.9 * 1e3 - 200) |>
                             arrange(age) |>
                             slice(1:14) |>
                             pull(age) |> list(),
                           sol == "La10b" ~
                             sln_peaks |>
                             filter(sln == "La10b", age >= 65.9 * 1e3 - 200) |>
                             arrange(age) |>
                             slice(1:14) |>
                             pull(age) |> list(),
                           sol == "La10c" ~
                             sln_peaks |>
                             filter(sln == "La10c", age >= 65.9 * 1e3 - 200) |>
                             arrange(age) |>
                             slice(1:14) |>
                             pull(age) |> list(),
                           TRUE ~ list(NA_real_))) |>
    unnest(cols = c(data, age)) |>
    arrange(sol, n) |>
    mutate(depth_diff = abs(strat_bot - lead(strat_bot)),
           age_diff = abs(age - lead(age)), .by = sol)

  tiepoint_uncertainty <- seq(-4, 4, .5)

  agem_tie <- agem_sol |>
    mutate(tie_err = list(tiepoint_uncertainty)) |>
    unnest(tie_err) |>
    mutate(depth = strat_bot + tie_err)
    ## filter(!(strat_bot == 0 & tie_err != 0))
  # prepend -1 cycle based on very rough estimate so that d13C data can be interpolated
  ## agem_simple <- bind_rows(
  ##   tibble(n = -1, comment = NA_character_, strat_bot = -16, site = "Zumaia", age = -405),
  ##   agem_simple
  ## )
  # I no longer do this, just use Hmisc::approxExtrap in stead.
#+end_src

#+RESULTS:
: indexing 405_minima.csv [===============================] 378.81MB/s, eta:  0s                                                                                                                 Rows: 20 Columns: 5
: ── Column specification ──────────────────────────────────────────────────────
: Delimiter: ","
: chr (3): comment, minmax, desc
: dbl (2): strat_bot, strat_top
:
: ℹ Use `spec()` to retrieve the full column specification for this data.
: ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

**** CaCO3: ten Kate and Sprenger 1993
:PROPERTIES:
:CREATED:  [2024-01-18 Thu 16:16]
:END:
:LOGBOOK:
- State "NEXT"       from "SOME"       [2024-01-19 Fri 11:47]
- Note taken on [2024-01-19 Fri 11:19] \\
  ok just read in the data and did some linear detrending and spectral analysis
- Note taken on [2024-01-18 Thu 16:49] \\
  Martin told me about this but I'm not sure I can find their raw data
- State "SOME"       from "NEXT"       [2024-01-18 Thu 16:49]
:END:
[cite:@tenKateSprenger1993]
very short record, Ma405_{-3} to Ma405_{4} and a bit

***** read the data
:PROPERTIES:
:CREATED:  [2024-01-23 Tue 14:08]
:END:
#+begin_src R
  Zumaia_CaCO3 <- readxl::read_excel("dat/tenKateSprenger1993/Zumaya-Kate-Sprenger.xls",
                     sheet = 2,
                     skip = 1) |>
    select(-...6, -...8)

  Zumaia_CaCO3 <- Zumaia_CaCO3 |>
    mutate(grp = findInterval(`dist from K/T (m)`, rev(c(0, -6.5, -12.5, -41.8)))) |>
    ## filter(`dist from K/T (m)` < 0) |> # normalizing using the stuff above makes the values very small
    nest(.by = grp) |>
    mutate(lin = map(data, \(x) lm(carbonate ~ `dist from K/T (m)`, data = x))) |>
    mutate(lin_pred = map(lin, predict)) |>
    unnest(c(data, lin_pred)) |>
    mutate(detrended = carbonate - lin_pred) |>
    mutate(lin_scl = scale(detrended)[, 1]) |>
    select(-lin)

  agem_CaCO3 <- tribble(
    ~ chron, ~ age, ~ depth,
    "C28R/C29N", -63.6, 12.53,
    "C29N/C29R", -64.27, 4.37,
    "K/Pg boundary", -64.5, 0.0,
    "C29R/C30N", -64.84, NA_real_,
    "C30R/C31N", -66.62, -74.75,
    ) |>
    filter(!is.na(depth))

  Zumaia_CaCO3 <- Zumaia_CaCO3 |>
    mutate(depth = -`dist from K/T (m)`) |>
    ## mutate(age = -approx(agem_CaCO3$depth, y = agem_CaCO3$age,
    ##                     xout = `dist from K/T (m)`)$y) |>
    ## mutate(age = age * 1e3) # from Ma to ka
    # instead, apply the age model from Batenburg!
    mutate(age = Hmisc::approxExtrap(agem_simple$strat_bot,
                         y = agem_sol$age[agem_sol$sol == "ZB20b"],
                         xout = .data$depth)$y)

#+end_src

#+RESULTS:
: -/                                                                            /                                                                            -                                                                            New names:
: • `` -> `...6`
: • `` -> `...8`

***** overview plot of detrending and spectral analysis
:PROPERTIES:
:CREATED:  [2024-01-23 Tue 14:09]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_CaCO3_detrend_and_spectra.png :width 2400 :height 2300 :res 300
  # depth domain + detrending
  (
    Zumaia_CaCO3 |>
    ggplot(aes(x = `dist from K/T (m)`,
               y = carbonate)) +
    labs(x = "Depth (m)",
         y = "Ca" * CO[3] ~ "(%)") +
    ## scale_x_reverse() +
    ## geom_smooth(aes(group = grp), method = "lm") +
    geom_line(aes(y = lin_pred, colour = factor(grp)), linewidth = 2) +
    geom_line() +
   geom_line(aes(y = lin_scl))
  ) / (
    Zumaia_CaCO3 |>
    spectral_analysis(x = `dist from K/T (m)`, y = lin_scl) |>
    # they say analyisis in the depth domain doesn't make sense due to changing
    # sedrates
    plot_spectrum(ar1 = TRUE, periods = c(10, 1, .5, .4, .3, .2))
  ) / (
  Zumaia_CaCO3 |>
    nested_spectral_analysis(nest = "grp",
                             x = `dist from K/T (m)`,
                             y = lin_scl) |>
    mutate(grp = as.character(grp)) |>
    plot_spectrum(group = "grp", periods = c(10, 1, .5, .4, .3, .2)) +
    # SOME: add AR1 spectra to each facet?
    facet_grid(cols = vars(grp)) +
    coord_cartesian(xlim = c(0, 5))
  )
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_CaCO3_detrend_and_spectra.png]]

***** plot of record and bandpass filters
:PROPERTIES:
:CREATED:  [2024-01-23 Tue 14:09]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_CaCO3_bandpass_filters.png :width 2400 :height 1000 :res 300
  Zumaia_CaCO3 |>
    # full record?
    # or just everything older than the K/Pg?
    ## filter(age > -1e3 * agem_CaCO3$age[agem_CaCO3$chron == "K/Pg boundary"]) |>
    # or just omitting the interval around the K/Pg?
    ## filter(age < 64.5e3 + 50e3 | age > 64.5e3 - 50e3) |>
    bandpass_filter(frequencies = my_filt_age |> filter(target != "23 kyr"),
                    x = age, y = lin_scl,
                    add_depth = TRUE) |>
    construct_eccentricity(id_cols = c("depth", "age", "lin_scl")) |>
    ggplot(aes(x = age * 1e-3, y = ecc)) +
    labs(x = "Age (Ma) but for ZB20b",
         y = "Norm. scaled record and filter",
         colour = "") +
    scale_x_reverse() +
    ## geom_vline(xintercept = -agem_CaCO3$age[agem_CaCO3$chron == "K/Pg boundary"]) +
    geom_vline(xintercept = kpg_ages$age1[kpg_ages$sln=="ZB20b"]) +
    geom_line(aes(y = lin_scl, colour = "CaCO3")) +
    geom_line(aes(y = `405 kyr`, colour = "405 kyr filter")) +
    geom_line(aes(y = `100 kyr`, colour = "100 kyr filter")) +
    geom_line(aes(y = ecc, colour = "Norm. Eccentricity construct"))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_CaCO3_bandpass_filters.png]]

**** COMMENT d13C Dinares-Turell 2014
:PROPERTIES:
:CREATED:  [2024-04-18 Thu 10:52]
:END:
this is only the younger part, even though they also describe the upper Maastrichtian in the paper
#+begin_src R
  DT14 <- pangaear::pg_data("10.1594/PANGAEA.835396")[[1]]$data
#+end_src

#+begin_src R :results output graphics file :file imgs/Dinares-Turell2014_Zumaia_stable-isotopes.png :width 800
  (
  DT14 |>
  ggplot(aes(
    ## x = `Section [m]`,
    x = `Age [ka BP]` * 1e-3,
    y = `δ13C carb [‰ PDB]`)) +
    geom_line() +
    scale_x_reverse()
  ) /
  (
  DT14 |>
    ggplot(aes(
    ## x = `Section [m]`,
    x = `Age [ka BP]` * 1e-3,
    y = `δ18O carb [‰ PDB]`)) +
    geom_line() +
    scale_x_reverse()
  ) + plot_layout(axes = "collect")
#+end_src

#+RESULTS:
[[file:imgs/Dinares-Turell2014_Zumaia_stable-isotopes.png]]

*** create tables with ranges of bp filters in depth domain
:PROPERTIES:
:CREATED:  [2023-09-27 Wed 10:05]
:END:
#+begin_src R
  # for wavelet analysis: notch filter that removes periods >25 m
  bat_filters_old <- tribble(
    ~ target, ~ proxy, ~ center, ~ plow, ~ phigh,
    "405 kyr", "Lstar", 15.7, 12, 22,
    "405 kyr", "MS", 18.9, 12, 40,
    "405 kyr", "d13C", 16.6, 11, 31,
    ) |>
    mutate(flow = 1 / plow, fhigh = 1 / phigh, site = "Zumaia", ref = "Batenburg et al., 2011")

  # these are from Batenburg et al., 2014 figure 3
  bat_filters <- tribble(
    ~ target, ~ proxy, ~ depth_chunk, ~ center, ~ plow, ~ phigh, ~site,
    "405 kyr", "Lstar", "depth < 109.26", 16, 12, 29, "Zumaia",
    "405 kyr", "Lstar", "depth >= 109.26", 12, 8.5, 20, "Zumaia",
    "405 kyr", "Lstar", "full record", 12, 8.5, 20, "Sopelana",
    ## "prec", "Lstar", 4, 3.0, 6.0, "both",
    "100 kyr", "Lstar", "depth < 109.26", 4, 3.0, 6.0, "Zumaia",
    "100 kyr", "Lstar", "depth >= 109.26", 4, 3.0, 6.0, "Zumaia",
    "100 kyr", "Lstar", "full record", 4, 3.0, 6.0, "Sopelana",
    "prec", "Lstar", "depth < 109.26", 0.72, 0.53, 1.1, "Zumaia",
    "prec", "Lstar", "depth >= 109.26", 0.49, 0.37, 0.75, "Zumaia",
    "prec", "Lstar", "full record", 0.49, 0.37, 0.75, "Sopelana",
    "405 kyr", "MS", "depth < 109.26", 17, 12, 24, "Zumaia",
    "405 kyr", "MS", "depth >= 109.26", 12, 8.8, 19, "Zumaia",
    "405 kyr", "MS", "full record", 12, 8.8, 19, "Sopelana",
    ## "prec", "MS", 4, 3.0, 6.0, "both",
    "100 kyr", "MS", "depth < 109.26", 4, 3.0, 6.0, "Zumaia",
    "100 kyr", "MS", "depth >= 109.26", 4, 3.0, 6.0, "Zumaia",
    "100 kyr", "MS", "full record", 4, 3.0, 6.0, "Sopelana",
    ## "prec", "MS", 0.72, 0.50, 1.3, "both",
    "prec", "MS", "depth < 109.26", 0.72, 0.50, 1.3, "Zumaia",
    "prec", "MS", "depth >= 109.26", 0.72, 0.50, 1.3, "Zumaia",
    "prec", "MS", "full record", 0.72, 0.50, 1.3, "Sopelana",
    ) |>
    mutate(flow = 1 / plow, fhigh = 1 / phigh, ref = "Batenburg et al., 2014")

  freq_perc <- 0.4
  my_filters <- tribble(
    ~ target, ~proxy, ~site,     ~ depth_chunk, ~ p,
    "405 kyr", "MS", "Zumaia", "full record", 16,
    "405 kyr", "MS", "Zumaia", "depth < 109.26", 16,
    "405 kyr", "MS", "Zumaia", "depth >= 109.26", 12,
    "405 kyr", "MS", "Sopelana", "full record", 12,
    "100 kyr", "MS", "Zumaia", "full record", 4,
    "100 kyr", "MS", "Zumaia", "depth < 109.26", 4,
    "100 kyr", "MS", "Zumaia", "depth >= 109.26", 4,
    "100 kyr", "MS", "Sopelana", "full record", 4,
    "prec", "MS", "Zumaia", "depth < 109.26", 0.72,
    "prec", "MS", "Zumaia", "depth >= 109.26", 0.49,
    "prec", "MS", "Sopelana", "full record", 0.49,
    "405 kyr", "Lstar", "Zumaia", "full record", 16,
    "405 kyr", "Lstar", "Zumaia", "depth < 109.26", 16,
    "405 kyr", "Lstar", "Zumaia", "depth >= 109.26", 12,
    "405 kyr", "Lstar", "Sopelana", "full record", 12,
    "100 kyr", "Lstar", "Zumaia", "full record", 4,
    "100 kyr", "Lstar", "Zumaia", "depth < 109.26", 4,
    "100 kyr", "Lstar", "Zumaia", "depth >= 109.26", 4,
    "100 kyr", "Lstar", "Sopelana", "full record", 4,
    "prec", "Lstar", "Zumaia", "depth < 109.26", 0.72,
    "prec", "Lstar", "Zumaia", "depth >= 109.26", 0.49,
    "prec", "Lstar", "Sopelana", "full record", 0.49,
     "405 kyr", "d13C", "Zumaia", "full record", 16,
    "405 kyr", "d13C", "Zumaia", "depth < 109.26", 16,
    "405 kyr", "d13C", "Zumaia", "depth >= 109.26", 12,
    "405 kyr", "d13C", "Sopelana", "full record", 12,
    "100 kyr", "d13C", "Zumaia", "full record", 4,
    "100 kyr", "d13C", "Zumaia", "depth < 109.26", 4,
    "100 kyr", "d13C", "Zumaia", "depth >= 109.26", 4,
    "100 kyr", "d13C", "Sopelana", "full record", 4,
    "prec", "d13C", "Zumaia", "depth < 109.26", 0.72,
    "prec", "d13C", "Zumaia", "depth >= 109.26", 0.49,
    "prec", "d13C", "Sopelana", "full record", 0.49,
  ) |>
    mutate(f = 1 / p,
           range = freq_perc * f,
           flow = f - range, fhigh = f + range,
           ref = "This study")

  # stick to old simple version for now to make sure nested_bandpass_filter still works :S
  my_filters_simple <- tribble(
    ~ target,  ~ p,
    "405 kyr", 16,
    "100 kyr", 4,
    "prec", 0.72,
  ) |>
    mutate(f = 1 / p,
           range = freq_perc * f,
           flow = f - range, fhigh = f + range,
           ref = "This study")
#+end_src

#+RESULTS:

*** COMMENT make a plot
:PROPERTIES:
:CREATED:  [2023-09-27 Wed 18:49]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_Batenburg2012.png :width 900 :height 500 :eval never
  library(patchwork)

  (Zumaia |>
    ggplot(aes(x = depth, y = MS)) +
    geom_line()) /
  (Zumaia |>
    ggplot(aes(x = depth, y = Lstar)) +
    geom_line()) /
  (Zumaia |>
    filter(!is.na(d13C)) |>
    ggplot(aes(x = depth, y = d13C)) +
   geom_line())

  (Sopelana |>
     ggplot(aes(x = depth, y = magsus)) +
   geom_line()) /
    (Sopelana |>
     ggplot(aes(x = depth, y = Lstar)) +
     geom_line())

  comp |>
    ggplot(aes(x = depth, y = value, colour = site)) +
    facet_grid(rows = vars(proxy), scales = "free_y") +
    geom_line() +
    geom_smooth()
    ## geom_smooth(aes(group = "all"))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_Batenburg2012.png]]

*** COMMENT simple taner filters
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 14:18]
:END:
Like [cite:@Husson2011].
#+begin_src R :results output graphics file :file imgs/Zumaia_filters.png :width 900 :height 500 :eval never
  f100 <- Zumaia |>
    select(depth, Lstar) |>
    filter(!is.na(Lstar)) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::taner(flow = 0, fhigh = 1) |>
    as_tibble()

  f405 <- Zumaia |>
    select(depth, Lstar) |>
    filter(!is.na(Lstar)) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::taner(flow = 0, fhigh = .4) |>
    as_tibble()

  (Zumaia |>
   filter(!is.na(d13C)) |>
    ggplot(aes(x = depth, y = d13C)) +
    geom_line() + labs(title = "Zumaia")) /
  (Zumaia |>
   ggplot(aes(x = depth, y = Lstar)) +
   geom_line(alpha = .3, colour = "darkblue") +
   geom_line(data = f100, colour = "skyblue") +
   geom_line(data = f405)) /
  (Zumaia |>
    ggplot(aes(x = depth, y = MS)) +
    geom_line())
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_filters.png]]

*** subtract the long-term trends
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 14:18]
:END:
We have several ways of subtracting the long-term trends prior to doing spectral analysis. Below is a table to summarize them:

#+name: tab:detrend_types
#+caption: The different detrend methods to remove long-term trends prior to spectral analysis.
| name           | method                                                                         |
|----------------+--------------------------------------------------------------------------------|
| ~value~          | The raw value. Often I still remove a linear trend from the spectral analysis call. |
| ~scl~            | The scaled (or normalized = mean subtracted, divided by standard deviation) value. |
| ~lin_scl_rw~     | Remove linear trends from red/white intervals separately, then scale the result. I think I chose wrong intervals for this so have removed it. |
| ~lin_scl_coarse~ | Chop the record into three (33--59 m) pieces based on broad scale visual trends in L*, and detrend linearly. |
| ~lin_scl_med~    | Same as fine below, but with coarse for depth >= 109.26 m                      |
| ~lin_scl_fine~   | Chop the record into smaller (~9--21 m) pieces based on visual trends in L*, and detrend linearly. |
| ~gam_scl~        | Subtract a gam from the value, then scale the result.                          |
| ~lin_gam_scl~    | First do ~lin_scl~ from above, then do ~gam_det~. This is excessive so I removed it from the analysis. |
| ~hp_scl~         | Subtract a lowpass filter from the value, then scale the result.               |

**** this just subtracts a gam from the raw data
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 15:35]
:END:
#+begin_src R
  smooth_basic <- comp |>
    ## pivot_wider() |>
    nest(.by = c(proxy, site)) |> # nest_by is different!!
    mutate(
      gam = map(data,
                # gam doesn't need equally-spaced values
                ~ mgcv::gam(value ~ s(depth, bs = "cs"),
                            method = "REML",
                            data = .))) |>
    mutate(
      gam_pred = map(gam, \(x) x |> predict() |> as.vector()),
    ) |>
    select(-gam) |>
    unnest(cols = c(data, gam_pred)) |>
    mutate(det = scale(value - gam_pred)[, 1], .by = c(proxy, site))
#+end_src

#+RESULTS:

**** let's try a loess with small span
:PROPERTIES:
:CREATED:  [2024-02-15 Thu 17:24]
:END:
#+begin_src R
  smooth_loess <- comp |>
    ## pivot_wider() |>
    nest(.by = c(proxy, site)) |> # nest_by is different!!
    mutate(
      loess = map(data, ~ loess(value ~ depth, span = .15,
                                data = .))) |>
    mutate(
      loess_pred = map(loess, \(x) x |> predict() |> as.vector()),
    ) |>
    select(-loess) |>
    unnest(cols = c(data, loess_pred)) |>
    mutate(det = scale(value - loess_pred)[, 1], .by = c(proxy, site)) |>
    rename(loess_scl = det)
#+end_src

#+RESULTS:

**** subtracting lowpass filters
:PROPERTIES:
:CREATED:  [2023-11-21 Tue 11:14]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-11-21 Tue 11:20]
:END:
***** figure out which frequency we want to notch at
:PROPERTIES:
:CREATED:  [2024-01-09 Tue 13:46]
:END:
They do `notch' filtering of everything >2 Myr in [cite:@Batenburg2012].

Except I don't know what's 2 Myr yet, so we'll do it based on the lower bracket of the 405 kyr filter.

Let's think about what 2 Myr would look like.

src_R{agem_sol[agem_sol$sol=="ZB18a","depth_diff"]$depth_diff} {{{results(= [1] 16 16 15 14 15 15 20 11 13 14 11 11 12 NA=)}}}
holds the difference in depth for each subsequent 405 kyr cycle.

So by dividing by 405 and multiplying by 2e3, we get the period of a 2 Myr cycle. If we take the inverse, we get the range of frequencies of approximately 2 Myr for each 405 kyr cycle in the whole record.
#  src_R{1/(agem_sol[agem_sol$sol=="ZB18a",]$depth_diff / 405 * 2000)$depth_diff} {{{results(=Error: object 'agem_sol' not found=)}}}
That ranges between 0.010 and 0.018.

or visually:
#+begin_src R :eval never
  agem_sol |>
    filter(sol=="ZB18a") |>
    mutate(target = 1/(depth_diff / 405 * 2000)) |>
    ggplot(aes(x = target)) +
    geom_dotplot()
#+end_src

#+RESULTS:
: Bin width defaults to 1/30 of the range of the data. Pick better value with
: `binwidth`.
: Warning message:
: Removed 1 rows containing missing values (`stat_bindot()`).

+We'll filter at a frequency of 0.035 cycles / m, or a period of 28.57 m+
+I chose this because+ the 405 kyr target filter range (\pm40 %) ranges from 0.0375 to 0.0875 cycles/m, +so it doesn't overlap.+

That's a bit too close to the 405 kyr. Now changed to 0.025.

Ok I've now added vertical lines to the spectra plot below to indicate all of these ranges. Testing out 0.01, 0.02, and 0.025.
Let's see how each of them changes the spectrum of the 405 kyr cycle.

***** calculate the highpass filter with fcut = 0.025
:PROPERTIES:
:CREATED:  [2024-01-09 Tue 13:46]
:END:
#+begin_src R
  smooth_hp <- comp |>
    nest(.by = c(proxy, site)) |>
    mutate(
      linterp = map(data,
                    ~ . |>
                      select(depth, value) |>
                      astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                      rename(depth_linterp = depth, value_linterp = value)) ,
      notch = map(linterp,
                  ~ . |>
                    astrochron::lowpass(fcut = 0.025, xmax = 0.1, verbose = FALSE, genplot = FALSE) |>
                    select(lowpass = value_linterp))) |>
    select(-data) |>
    unnest(c(linterp, notch)) |>
    mutate(highpass = scale(value_linterp - lowpass)[, 1])
#+end_src

#+RESULTS:

***** calculate the highpass filter with fcut = 0.010
:PROPERTIES:
:CREATED:  [2024-01-09 Tue 13:46]
:END:
second alternative, even longer period/lower frequency.
#+begin_src R
  smooth_hp_2 <- comp |>
    nest(.by = c(proxy, site)) |>
    mutate(
      linterp = map(data,
                    ~ . |>
                      select(depth, value) |>
                      astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                      rename(depth_linterp = depth, value_linterp = value)) ,
      notch = map(linterp,
                  ~ . |>
                    astrochron::lowpass(fcut = 0.010, xmax = 0.1, verbose = FALSE, genplot = FALSE) |>
                    select(lowpass = value_linterp))) |>
    select(-data) |>
    unnest(c(linterp, notch)) |>
    mutate(highpass = scale(value_linterp - lowpass)[, 1])
#+end_src

#+RESULTS:

***** calculate the highpass filter with fcut = 0.020
:PROPERTIES:
:CREATED:  [2024-01-09 Tue 13:47]
:END:
third alternative, +shorter period, higher frequency.+
+Use the exact lower bound of the 405 kyr filter.+ hmm that's very similar to the first one. Let's try something else instead!
*intermediate, approximately 1 Myr ish?*

#+begin_src R
  smooth_hp_3 <- comp |>
    nest(.by = c(proxy, site)) |>
    mutate(
      linterp = map(data,
                    ~ . |>
                      select(depth, value) |>
                      astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                      rename(depth_linterp = depth, value_linterp = value)) ,
      notch = map(linterp,
                  ~ . |>
                    astrochron::lowpass(fcut = 0.02, xmax = 0.1, verbose = FALSE, genplot = FALSE) |>
                    select(lowpass = value_linterp))) |>
    select(-data) |>
    unnest(c(linterp, notch)) |>
    mutate(highpass = scale(value_linterp - lowpass)[, 1])
#+end_src

#+RESULTS:

***** calculate the highpass filter with fcut = 0.0375, the lower edge of the 405-kyr bp filter
:PROPERTIES:
:CREATED:  [2024-01-09 Tue 13:47]
:END:
lower edge of the 405 kyr filter
#+begin_src R
  smooth_hp_4 <- comp |>
    nest(.by = c(proxy, site)) |>
    mutate(
      linterp = map(data,
                    ~ . |>
                      select(depth, value) |>
                      astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                      rename(depth_linterp = depth, value_linterp = value)) ,
      notch = map(linterp,
                  ~ . |>
                    astrochron::lowpass(fcut = 0.0375, xmax = 0.1, verbose = FALSE, genplot = FALSE) |>
                    select(lowpass = value_linterp))) |>
    select(-data) |>
    unnest(c(linterp, notch)) |>
    mutate(highpass = scale(value_linterp - lowpass)[, 1])
#+end_src

#+RESULTS:

***** plot the highpass filters
:PROPERTIES:
:CREATED:  [2024-01-08 Mon 14:06]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_highpass.png :width 3400 :height 2100 :res 300 :eval never
  smooth_hp |>
    ggplot(aes(x = depth_linterp, y = value_linterp)) +
    facet_grid(cols = vars(site),
               rows = vars(proxy),
               scales = "free", space = "free_x") +
    labs(x = "Depth (m)", y = "Proxy value", colour = "Fit/filter strategy") +
    scale_x_reverse(breaks = seq(0, 200, 10), minor_breaks = seq(0, 200, 2)) +
    geom_vline(aes(xintercept = strat_bot),
               colour = "gray",
               data = agem_simple) +
    geom_line(colour = "gray") + # raw data
    geom_line(aes(y = lowpass, colour = "lp 0.025")) +
    geom_line(aes(y = lowpass, colour = "lp 0.01"), data = smooth_hp_2) +
    geom_line(aes(y = lowpass, colour = "lp 0.02"), data = smooth_hp_3) +
    geom_line(aes(y = lowpass, colour = "lp 0.0375"), data = smooth_hp_4) +
    geom_line(aes(x = depth, y = gam_pred, colour = "gam"), data = smooth_basic) #+
    # this one isn't available yet!
    ## geom_line(aes(x = depth, y = filter, colour = "bp 0.0625 ± 40%"), data = filts |> filter(detrend_type == "value", target == "405 kyr"))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia-Sopelana_highpass.png]]

***** [#A] spectral analysis on highpass filters
:PROPERTIES:
:CREATED:  [2024-01-08 Mon 14:57]
:END:
:LOGBOOK:
- Note taken on [2024-01-09 Tue 12:00] \\
  yay finished this?
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_lowpass_spectra.png :width 2400 :height 2200 :res 300 :eval never
  spec_hp <- smooth_hp |>
    nested_spectral_analysis(nest = c("proxy", "site"),
                             x = depth_linterp, y = highpass)
  spec_hp_2 <- smooth_hp_2 |>
    nested_spectral_analysis(nest = c("proxy", "site"),
                             x = depth_linterp, y = highpass)
  spec_hp_3 <- smooth_hp_3 |>
    nested_spectral_analysis(nest = c("proxy", "site"),
                             x = depth_linterp, y = highpass)
  spec_hp_4 <- smooth_hp_4 |>
    nested_spectral_analysis(nest = c("proxy", "site"),
                             x = depth_linterp, y = highpass)


  spec_hp |>
    ggplot(aes(x = frequency, y = power)) +
    facet_grid(cols = vars(site), rows = vars(proxy),
               scales = "free_y") +
    scale_x_continuous("Frequency (cycles/m)",
                       sec.axis = sec_axis(breaks = c(1, 3.33, 5, 10, ## 20,
                                                      30 #40,

                                                      ## 100
                                                      ),
                                           trans = \(x) 1 / x, name = "Period (m)")) +
    coord_cartesian(xlim = c(0, 0.4)) +
    scale_y_log10() +
    ## annotation_logticks(sides = "l") +
    ## annotate("text", x = 0.0625, y = 0, label = "405 kyr") +
    geom_text(aes(x = f, y = 1e-5, label = target),
              size = 3,
              data = my_filters) +
    ## annotate("pointrange", x = 0.0625, xmin = 0.025, xmax = 0.0875, y = 0) +
    geom_rect(aes(xmin = flow, xmax = fhigh, ymin = 1e-6, ymax = 1e-4),
              inherit.aes = FALSE,
              fill = "orange", alpha = .1,
              data = my_filters) +
    # hide for now because it makes the plot go up a lot
    ## geom_line(aes(colour = "raw"),
    ##           data = specs_fancy |>
    ##             filter(detrend_type == "value")) +
    ## geom_line(aes(colour = "gam"),
    ##           data = specs_fancy |>
    ##             filter(detrend_type == "gam_det")) +
    geom_vline(aes(colour = "lp 0.025", xintercept = 0.025)) +
    geom_line(aes(colour = "lp 0.025")) +
    geom_line(aes(colour = "lp 0.01"), data = spec_hp_2) +
    geom_vline(aes(colour = "lp 0.01", xintercept = 0.01)) +
    geom_line(aes(colour = "lp 0.02"), data = spec_hp_3) +
    geom_vline(aes(colour = "lp 0.02", xintercept = 0.02)) +
    geom_line(aes(colour = "lp 0.0375"), data = spec_hp_4) +
    geom_vline(aes(colour = "lp 0.0375", xintercept = 0.0375))
#+end_src

#+name: fig:lowpass-spec
#+caption: See overleaf.
#+RESULTS:
[[file:imgs/Zumaia-Sopelana_lowpass_spectra.png]]

**** subtract red/white interval means and then do a gam for the whole record
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 15:35]
:END:
We have to be careful of the white/red intervals in the record!
So instead of fitting a simple gam through the whole record, we fit +one for+ a line for each coloured interval separately.

This is still a bit iffy, not sure if it is the best approach for detrending\dots

***** the main one that I started with
:PROPERTIES:
:CREATED:  [2024-01-09 Tue 14:12]
:END:
#+begin_src R :exports none
  smooth <- comp |>
    # cut the depth into groups, be sure to make the names unique!
    mutate(colour = case_when(
             depth < 0 ~ "white1",
             depth > 0 & depth <= 58.59 ~ "red1",
             depth > 58.59 & depth <= 59 ~ "pink1",
             depth > 59 & depth <= 82.75 ~ "white2",
             depth > 82.75 & depth <= 87.8 ~ "pink2",
             depth > 87.8 & depth <= 108.5 ~ "red2",
             depth > 108.5 & depth <= 109.8 ~ "pink3",
             depth > 109.8 ~ "white3",
             TRUE ~ NA_character_)) |>
    # just subtract a mean value for each colour? = a flat line
    ## mutate(mean_colour = mean(value), .by = c(site, proxy, colour)) |>
    ## mutate(dec = value - mean_colour) |>
    # first calculate a lm for each slice of colour interval
    nest(.by = c(proxy, site, colour)) |>
    # fit a line through each white/red interval
    mutate(
      lim = map(data, ~ lm(value ~ depth, data = .x)),
      # predict the value for each depth
      lin_pred = map(lim, predict)) |>
    select(-lim) |>
    unnest(c(data, lin_pred)) |>
    mutate(lin = value - lin_pred) |>
    nest(.by = c(proxy, site)) |>
    # fit a generalized additive models with integrated smoothness estimation
    mutate(
      gamm = map(data,
                 # could also do local polynomial regression fit?
                 ## ~ loess(dec ~ depth, data = ., span = .9)
                 # but gam is more robust, less parameters to choose.
                 ~ mgcv::gam(lin ~ s(depth, bs = "cs"),
                             method = "REML",
                             data = .)),
      # make predictions for the gam model for each depth
      gam_pred = map(gamm, \(x) x |> predict() |> as.vector()),
    ) |>
    select(-gamm) |>
    unnest(cols = c(data, gam_pred)) |>
    mutate(
      lin_scl = scale(lin)[, 1],
      gam = lin - gam_pred,
      det = scale(gam)[, 1],
      .by = c(proxy, site))
#+end_src

#+RESULTS:

***** [#B] the second one, small chunks?
:PROPERTIES:
:CREATED:  [2024-01-09 Tue 14:12]
:END:
#+begin_src R :exports none
  smooth_2 <- comp |>
    # just cut the record into 10 meter slices
    mutate(colour = findInterval(depth, c(-50, 0, 15.2, 32.8, 42.75, 58.8, 80, 91.3, 109.26, 123.2, 131.8, 160))) |>
    # first calculate a lm for each slice
    nest(.by = c(proxy, site, colour)) |>
    # fit a line through each interval
    mutate(
      lim = map(data, ~ lm(value ~ depth, data = .x)),
      # predict the value for each depth
      lin_pred = map(lim, predict)) |>
    select(-lim) |>
    unnest(c(data, lin_pred)) |>
    mutate(lin = value - lin_pred,
           lin_scl = scale(lin)[, 1],
           .by = c(proxy, site))
#+end_src

#+RESULTS:

***** the third one, large chunks?
:PROPERTIES:
:CREATED:  [2024-01-09 Tue 14:12]
:END:
#+begin_src R :exports none
  smooth_3 <- comp |>
    # just cut the record into slices
    mutate(colour = findInterval(depth, c(-50, 0, 58.8, 109.26, 142))) |>
    # first calculate a lm for each slice of colour interval
    nest(.by = c(proxy, site, colour)) |>
    # fit a line through each white/red interval
    mutate(
      lim = map(data, ~ lm(value ~ depth, data = .x)),
      # predict the value for each depth
      lin_pred = map(lim, predict)) |>
    select(-lim) |>
    unnest(c(data, lin_pred)) |>
    mutate(lin = value - lin_pred,
           lin_scl = scale(lin)[, 1],
           .by = c(proxy, site))
#+end_src

#+RESULTS:

***** fourth one, intermediate?
:PROPERTIES:
:CREATED:  [2024-02-15 Thu 13:40]
:END:

#+begin_src R :exports none
  smooth_4 <- comp |>
    # just cut the record into 10 meter slices
    mutate(colour = findInterval(depth, c(-50, 0, 15.2, 32.8, 42.75, 58.8, 80, 91.3, 109.26, 160))) |>
    # first calculate a lm for each slice
    nest(.by = c(proxy, site, colour)) |>
    # fit a line through each interval
    mutate(
      lim = map(data, ~ lm(value ~ depth, data = .x)),
      # predict the value for each depth
      lin_pred = map(lim, predict)) |>
    select(-lim) |>
    unnest(c(data, lin_pred)) |>
    mutate(lin = value - lin_pred,
           lin_scl = scale(lin)[, 1],
           .by = c(proxy, site))
#+end_src

#+RESULTS:

**** fit a MARS
:PROPERTIES:
:CREATED:  [2024-03-24 Sun 21:42]
:END:
***** d13C + Lstar + MS ~ depth
#+begin_src R :results output graphics file :file imgs/mars_full.png :width 800
  # if we match all proxies, remove quite a lot of NA becaues of d13C
  mars <- comp |>
     ## filter(proxy == "Lstar") |>
    pivot_wider(names_from = proxy) |>
    filter(!is.na(d13C), !is.na(MS), !is.na(Lstar)) |>
    earth::earth(d13C + Lstar + MS ~ depth,
                 data = _)

  plot(mars, nresponse = 2)
  summary(mars)

  pred_raw <- predict(mars) |>
    as_tibble() |>
    rename(pred_d13C = d13C, pred_Lstar = Lstar, pred_MS = MS)

  pred <- comp |>
    pivot_wider(names_from = proxy) |>
    filter(!is.na(d13C), !is.na(MS), !is.na(Lstar)) |>
    bind_cols(pred_raw)

  (pred |>
    ggplot(aes(x = depth, y = Lstar)) +
    xlim(0, 180) +
    geom_point(colour = "gray", data = comp |> pivot_wider(names_from = proxy)) +
    geom_line() +
    geom_point() +
    geom_line(aes(y = pred_Lstar), colour = "red")) /
  (pred |>
    ggplot(aes(x = depth, y = MS)) +
    xlim(0, 180) +
    geom_point(colour = "gray", data = comp |> pivot_wider(names_from = proxy)) +
    geom_line() +
    geom_point() +
    geom_line(aes(y = pred_MS), colour = "red")) /
  (pred |>
    ggplot(aes(x = depth, y = d13C)) +
    xlim(0, 180) +
    geom_line() +
    geom_point() +
   geom_line(aes(y = pred_d13C), colour = "red")) +
    plot_layout(axes = "collect")
#+end_src

#+RESULTS:
[[file:imgs/mars_full.png]]

***** Lstar + MS ~ depth
#+begin_src R :results output graphics file :file imgs/mars.png :width 800
  # only MS and Lstar
  mars <- comp |>
    filter(proxy != "d13C") |>
    pivot_wider(names_from = proxy) |>
    filter(!is.na(MS), !is.na(Lstar)) |>
    earth::earth(Lstar + MS ~ depth + site, # note site binning here!
                 Scale.y = TRUE,
                 degree = 5,
                 ## nfold = 15, ncross = 5,
                 data = _)

  plot(mars, nresponse = 2)
  ## summary(mars)
#+end_src

#+RESULTS:
[[file:imgs/mars.png]]

#+begin_src R :results output graphics file :file imgs/mars_fit.png :width 800
  pred_raw <- predict(mars) |>
    as_tibble() |>
    rename(pred_Lstar = Lstar, pred_MS = MS)

  pred <- comp |>
    pivot_wider(names_from = proxy) |>
    filter(!is.na(MS), !is.na(Lstar)) |>
    bind_cols(pred_raw)

  (pred |>
    ggplot(aes(x = depth, y = Lstar)) +
    xlim(0, 180) +
    geom_point(colour = "gray", data = comp |> pivot_wider(names_from = proxy)) +
    geom_line() +
    geom_line(aes(y = pred_Lstar, group = site), colour = "red")) /
  (pred |>
    ggplot(aes(x = depth, y = MS)) +
    xlim(0, 180) +
    geom_point(colour = "gray", data = comp |> pivot_wider(names_from = proxy)) +
    geom_line() +
    geom_line(aes(y = pred_MS, group = site), colour = "red")) +
    plot_layout(axes = "collect")
#+end_src

#+RESULTS:
[[file:imgs/mars_fit.png]]

**** CANC bayesian MARS - bass
CLOSED: [2024-04-03 Wed 16:39]
:PROPERTIES:
:CREATED:  [2024-04-03 Wed 16:30]
:END:
#+begin_src R
  wide <- comp |>
    filter(proxy != "d13C") |>
    pivot_wider(names_from = proxy) |>
    filter(!is.na(MS), !is.na(Lstar))

  bass <- BASS::bass(xx = wide$depth, y = wide[, c("Lstar", "MS")])
#+end_src

#+RESULTS:
: Error in BASS::bass(xx = wide$depth, y = wide[, c("Lstar", "MS")]) :
:   missing xx.func

**** bspline
:PROPERTIES:
:CREATED:  [2024-03-24 Sun 22:37]
:END:
***** prep data
#+begin_src R
  wide <- comp |>
     ## filter(proxy == "Lstar") |>
    filter(site == "Zumaia") |>
    pivot_wider(names_from = proxy) |>
    tidylog::filter(## !is.na(d13C),
               !is.na(MS), !is.na(Lstar)) |>
    arrange(depth) |>
    select(-comment,
           -d13C)
#+end_src

#+RESULTS:
: filter: removed 29 rows (2%), 1,359 rows remaining

separate for sopelana
#+begin_src R
  wide_S <- comp |>
     ## filter(proxy == "Lstar") |>
    filter(site == "Sopelana") |>
    pivot_wider(names_from = proxy) |>
    tidylog::filter(## !is.na(d13C),
               !is.na(MS), !is.na(Lstar)) |>
    arrange(depth) |>
    select(-comment)
#+end_src

#+RESULTS:
: filter: no rows removed

***** fit bspline for Zumaia
this was pretty slow!
#+begin_src R :eval never
  # NOTE: THIS IS STILL COMBINED
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          n = 1,
                          nki = 40
                          )
  write_rds(bs, file = "out/bs.rds")
#+end_src

another coarser one, also slow
#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          n = 1,
                          nki = 25
                          ) |>
    write_rds("out/bs_25.rds")
#+end_src

coarser still: too coarse, jumps are now / in stead of _|-
#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          n = 1,
                          nki = 15
                          ) |>
    write_rds("out/bs_15.rds")
#+end_src

less coarse
#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          n = 1,
                          nki = 20
                          ) |>
    write_rds("out/bs_20_Z.rds")
#+end_src

slightly coarser
#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          n = 1,
                          nki = 17
                          ) |>
    write_rds("out/bs_17.rds")
#+end_src

maybe a little finer?
#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          n = 1,
                          nki = 23
                          ) |>
    write_rds("out/bs_23.rds")
#+end_src

almost there?
#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          n = 1,
                          nki = 24
                          ) |>
    write_rds("out/bs_24.rds")
#+end_src

very coarse, based on what I counted
#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          n = 1,
                          nki = 12
                          ) |>
    write_rds("out/bs_12.rds")
#+end_src

even courser, but this misses the sharp jump
#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          n = 1,
                          nki = 8
                          ) |>
    write_rds("out/bs_8.rds")
#+end_src

one more to put the kink back in?
#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          n = 1,
                          nki = 9
                          ) |>
    write_rds("out/bs_9.rds")
#+end_src


a smooth one?
#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 9
                          ) |>
    write_rds("out/bs_9_smooth.rds")
#+end_src

this lacks the sharp edges that I so desperately desire
#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 11
                          ) |>
    write_rds("out/bs_11_smooth.rds")
#+end_src

#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 12
                          ) |>
    write_rds("out/bs_12_smooth.rds")
#+end_src

#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 15
                          ) |>
    write_rds("out/bs_15_smooth.rds")
#+end_src

#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 16
                          ) |>
    write_rds("out/bs_16_smooth.rds")
#+end_src

#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 17
                          ) |>
    write_rds("out/bs_17_smooth.rds")
#+end_src

#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 18
                          ) |>
    write_rds("out/bs_18_smooth.rds")
#+end_src


#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 19
                          ) |>
    write_rds("out/bs_19_smooth.rds")
#+end_src

#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 20
                          ) |>
    write_rds("out/bs_20_smooth.rds")
#+end_src

#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 40
                          ) |>
    write_rds("out/bs_40_smooth.rds")
#+end_src

#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 30
                          ) |>
    write_rds("out/bs_30_smooth.rds")
#+end_src

#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 100
                          ) |>
    write_rds("out/bs_100_smooth.rds")
#+end_src

should be somewhere between 30 and 40?
#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 35
                          ) |>
    write_rds("out/bs_35_smooth.rds")
#+end_src
***** fit bspline for Sopelana
let's do Sopelana separately
#+begin_src R :eval never
  bs <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          n = 1,
                          nki = 20
                          ) |>
    write_rds("out/bs_20_S.rds")
#+end_src

fewer knots for Sopelana
#+begin_src R :eval never
  bs_S <- bspline::fitsmbsp(x = wide$depth,
                          y = wide[c(## "d13C",
                            "Lstar", "MS")],
                          n = 1,
                          nki = 1
                          ) |>
    write_rds("out/bs_1_S.rds")
#+end_src

sopelana fewer knots
#+begin_src R :eval never
  bs_S <- bspline::fitsmbsp(x = wide_S$depth,
                          y = wide_S[c(## "d13C",
                            "Lstar", "MS")],
                          n = 1,
                          nki = 2
                          ) |>
    write_rds("out/bs_2_S.rds")
#+end_src

sopelana smooth
#+begin_src R :eval never
  bs_S <- bspline::fitsmbsp(x = wide_S$depth,
                          y = wide_S[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 2
                          ) |>
    write_rds("out/bs_2_smooth_S.rds")
#+end_src


#+begin_src R :eval never
  bs_S <- bspline::fitsmbsp(x = wide_S$depth,
                          y = wide_S[c(## "d13C",
                            "Lstar", "MS")],
                          nki = 3
                          ) |>
    write_rds("out/bs_3_smooth_S.rds")
#+end_src
***** read in results
#+begin_src R
  ## bs <- read_rds("out/bs.rds") # bs_40
  ## bs <- read_rds("out/bs_25.rds")
  ## bs <- read_rds("out/bs_20.rds")
  ## bs <- read_rds("out/bs_20_Z.rds") # Zumaia only
  ## bs <- read_rds("out/bs_17.rds") # Zumaia only
  ## bs <- read_rds("out/bs_23.rds") # Zumaia only
  ## bs <- read_rds("out/bs_15.rds")
  ## bs <- read_rds("out/bs_12.rds") # Zumaia only
  bs <- read_rds("out/bs_9.rds")
  ## bs <- read_rds("out/bs_9_smooth.rds")
  ## bs <- read_rds("out/bs_10_smooth.rds")
  ## bs <- read_rds("out/bs_12_smooth.rds")
  ## bs <- read_rds("out/bs_17_smooth.rds")
  ## bs <- read_rds("out/bs_20_smooth.rds")
  ## bs <- read_rds("out/bs_30_smooth.rds")
  ## bs <- read_rds("out/bs_40_smooth.rds")
  ## bs <- read_rds("out/bs_100_smooth.rds") # obvious overfit
  bs_S <- read_rds("out/bs_2_S.rds")
  ## bs_S <- read_rds("out/bs_2_smooth_S.rds")
  ## bs_S <- read_rds("out/bs_3_smooth_S.rds")
  ## bs <- read_rds("out/bs_20_S.rds") # Sopelana only
  ## bs_S <- read_rds("out/bs_20_S.rds") # actually nki = 1
#+end_src

#+RESULTS:

*****  extract the knots
#+begin_src R
  the_knots <- tibble(depth = bspline::bsppar(bs)$xk) |>
    mutate(Lstar = bs(depth)[, 1], MS = bs(depth)[, 2], site = "Zumaia") |>
    bind_rows(
      tibble(depth = bspline::bsppar(bs_S)$xk) |>
      mutate(Lstar = bs_S(depth)[, 1], MS = bs_S(depth)[, 2], site = "Sopelana")
    )
#+end_src

#+RESULTS:

***** now that we have the knots, fit a bs with those for d13C
#+begin_src R
  dat <- comp |>
    filter(proxy == "d13C") |>
    pivot_wider(names_from = "proxy")

  d13C_knots <- the_knots[-1, ] |>
    filter(site == "Zumaia") |>
    filter(depth <= max(dat$depth))

  bs_d13C <- bspline::smbsp(x = dat$depth,
                            y = dat$d13C,
                            n = 1,
                            xki = d13C_knots$depth)

  the_knots <- the_knots |>
    mutate(d13C = bs_d13C(depth)[, 1], .before = site)
#+end_src

#+RESULTS:

***** predict the model and residuals
#+begin_src R
  pred <- wide |> # first Zumaia
    # add predictions from bs
    mutate(bs = map(depth, \(x) bs(x) |>
                                as_tibble() |>
                                rename(pred_MS = MS, #pred_d13C = d13C,
                                       pred_Lstar = Lstar))) |>
    unnest(bs) |>
    # add Sopelana
    bind_rows(
      wide_S |>
      # add predictions from bs
      mutate(bs = map(depth, \(x) bs_S(x) |>
                                  as_tibble() |>
                                  rename(pred_MS = MS, #pred_d13C = d13C,
                                         pred_Lstar = Lstar))) |>
      unnest(bs)
    ) |>
    mutate(Lstar_scl = scale(Lstar - pred_Lstar)[, 1],
           MS_scl = scale(MS - pred_MS)[, 1],
           .by = site) |>
    full_join(
      dat |>
      mutate(pred_d13C = bs_d13C(depth)[, 1],
             d13C_scl = scale(d13C - pred_d13C)[, 1])
    ) |>
    arrange(depth)
#+end_src

#+RESULTS:
: Joining with `by = join_by(site, depth)`

this could be simplified?

***** plot detrending
#+begin_src R :results output graphics file :file imgs/bspline.png :width 800
  (
    pred |>
    filter(!is.na(d13C)) |>
    ggplot(aes(x = depth, y = d13C)) +
    coord_cartesian(xlim = range(the_knots$depth)) +
    geom_line(alpha = .3) +
    geom_point(data = the_knots, colour = "blue") +
    geom_line(aes(y = pred_d13C), colour = "red")
  ) / (
  pred |>
    ggplot(aes(x = depth, y = Lstar, group = site)) +
    coord_cartesian(xlim = range(the_knots$depth)) +
    geom_line(alpha = .3) +
    ## geom_point() +
    geom_point(data = the_knots, colour = "blue") +
    geom_line(aes(y = pred_Lstar), colour = "red")
  ) /
  (
  pred |>
    ggplot(aes(x = depth, y = MS, group = site)) +
    coord_cartesian(xlim = range(the_knots$depth)) +
    geom_line(alpha = .3) +
    ## geom_point() +
    geom_point(data = the_knots, colour = "blue") +
    geom_line(aes(y = pred_MS), colour = "red")
  ) + plot_layout(axes = "collect")
#+end_src

#+RESULTS:
[[file:imgs/bspline.png]]

***** filtering residuals
:PROPERTIES:
:CREATED:  [2024-04-04 Thu 15:43]
:END:
#+begin_src R
  filts <- bat_filters[bat_filters$proxy == "Lstar" &
                       bat_filters$depth_chunk == "depth < 109.26" &
                       bat_filters$target != "prec", ]

  bps <- pred |>
    ## pivot_longer(cols = c(MS, Lstar, d13C), names_to = "proxy", values_to = "raw") |>
    ## pivot_longer(cols = starts_with("pred_"), names_to = "pred_proxy", values_to = "fit") |>
    select(site, depth, ends_with("_scl")) |>
    pivot_longer(cols = ends_with("_scl"), names_to = "proxy_scl", values_to = "scl") |>
    separate(proxy_scl, into = c("proxy", "xxx")) |>
    select(-xxx) |>
    filter(!is.na(scl)) |>
    nested_taner_filter(frequencies = filts,
                        x = depth,
                        y = scl,
                        nest = c("site", "proxy"),
                        roll = 1e10,
                        genplot = FALSE, verbose = FALSE)
#+end_src

#+RESULTS:

***** plot detrended
#+begin_src R :results output graphics file :file imgs/bspline_scl.png :width 800
  (
    pred |>
    filter(!is.na(d13C)) |>
    ggplot(aes(x = depth, y = d13C_scl, group = site)) +
    coord_cartesian(xlim = range(the_knots$depth)) +
    geom_line(alpha=.3) +
    geom_line(aes(y = filter + 2 * as.integer(as.factor(target)), group = paste(site, target)), data = bps |> filter(proxy == "d13C"))
  ) / (
  pred |>
    ggplot(aes(x = depth, y = Lstar_scl, group = site)) +
    coord_cartesian(xlim = range(the_knots$depth)) +
    geom_line(alpha=.3)  +
    geom_line(aes(y = filter + 2 * as.integer(as.factor(target)), group = paste(site, target)), data = bps |> filter(proxy == "Lstar")) +
    geom_vline(xintercept = 116)
  ) / (
   pred |>
    ggplot(aes(x = depth, y = MS_scl, group = site)) +
    coord_cartesian(xlim = range(the_knots$depth)) +
    geom_line(alpha=.3) +
    geom_line(aes(y = filter + 2 * as.integer(as.factor(target)), group = paste(site, target)), data = bps |> filter(proxy == "MS")) +
    geom_vline(xintercept = 116)
  ) + plot_layout(axes = "collect")
#+end_src

#+RESULTS:
[[file:imgs/bspline_scl.png]]

**** CANC cobs
CLOSED: [2024-04-03 Wed 17:27]
:PROPERTIES:
:CREATED:  [2024-04-01 Mon 17:24]
:END:
#+begin_src R
  fancyfit <- cobs::cobs(comp$depth[comp$proxy == "Lstar" & comp$site == "Zumaia"], y = comp$value[comp$proxy == "Lstar" & comp$site == "Zumaia"],
                         ## lambda = -1,
                         lambda = 0,
                         degree = 1, # lines, not cubes
                         ## degree = 2, # default
                         method = "uniform", # defaults to "quantile"
                         ## nknots = 200, # at 200, this really removes a lot of long ecc variability
                         ## nknots = 100, # at 100, this removes some of long ecc variability
                         ## nknots = 50, # at 50, this does not remove the major switches at around 110 m depth
                         ## nknots = 75, # at 75, this  removes too much long ecc variability
                         nknots = 60, # at 60, this  removes too much long ecc variability
                         # tau defaults to 0.5, median
                         ## tau = c((1 - 0.95) / 2, (1 - 0.68) / 2, 0.5, 1 - (1 - 0.68) / 2, 1 - (1 - 0.95) / 2),
                         ## nknots = 15,
                         # I can set knots explicitly
                         ## knots = c(## -50,
                         ##           0, 58.8, 109.26, 142), # original coarse
                         ## knots = c(## -50,
                         ##   0, 15.2, 32.8, 42.75, 58.8, 80, 91.3, 109.26, 160), # original med
                         # manually tweaked while watching the output
                         ## knots = c(## -50,
                         ##   0, 15.2,
                         ##   19,
                         ##   27,
                         ##   32.4,
                         ##   ## 32.5,
                         ##   42.75,
                         ##   47,
                         ##   58,
                         ##   58.8,
                         ##   70,
                         ##   80, 91.3,
                         ##   109.26, 110, # added extra point so it can make the jump
                         ##   117, 118,
                         ##   127,
                         ##   160), # same as lin_scl_med
                         knots.add = TRUE,
                         ## lambda.length = 100,
                         ## lambda.lo = sd(comp$depth[comp$proxy == "Lstar" & comp$site == "Zumaia"])^2 * 1e-8, # defaults to this * 1e-4
                         ## lambda.hi = sd(comp$depth[comp$proxy == "Lstar" & comp$site == "Zumaia"])^2 * 1e3 # defaults to 1000
                         )
  summary(fancyfit)
  ## plot(fancyfit, type = 'l')
#+end_src

#+RESULTS:
#+begin_example
qbsks2():
 Performing general knot selection ...

 Deleting unnecessary knots ...

 Searching for missing knots ...
COBS regression spline (degree = 1) from call:
	 cobs::cobs(x = comp$depth[comp$proxy == "Lstar" & comp$site ==     "Zumaia"], y = comp$value[comp$proxy == "Lstar" & comp$site ==     "Zumaia"], nknots = 60, method = "uniform", degree = 1, lambda = 0,     knots.add = TRUE)
{tau=0.5}-quantile;  dimensionality of fit: 48 from {48}
x$knots[1:48]:   0.04860897,   2.43917373,   7.22002119, ... , 141.08389104
coef[1:48]: 53.03228, 43.74047, 46.88116, 46.47333, 45.57353, ... , 54.47205
R^2 = 69.81% ;  empirical tau (over all): 691/1361 = 0.5077149 (target tau= 0.5)
#+end_example

#+begin_src R :results graphics file :file imgs/cobs_detrending_Lstar.png :width 900 :height 600
  par(mfrow = c(2, 1))
  plot(fancyfit$x,
       fancyfit$y,
       type = "l",
       xlab = "Depth (m)", ylab = "L*")
  lines(fancyfit$x, fancyfit$fitted, col = "red", lwd = 2)
  plot(fancyfit$x,
       fancyfit$resid,
       type = 'l', xlab = "Depth (m)", ylab = "residual")
#+end_src

#+RESULTS:
[[file:imgs/cobs_detrending_Lstar.png]]

#+begin_src R :results output graphics file :file imgs/fancyfit_mtm.png
  astrochron::mtm(astrochron::linterp(data.frame(fancyfit$x, fancyfit$resid)))
#+end_src

#+RESULTS:
[[file:imgs/fancyfit_mtm.png]]

**** eemd
empirical mode decomposition
:PROPERTIES:
:CREATED:  [2024-04-11 Thu 14:15]
:END:
#+begin_src R
  wide <- comp |>
     ## filter(proxy == "Lstar") |>
    filter(site == "Zumaia") |>
    pivot_wider(names_from = proxy) |>
    tidylog::filter(## !is.na(d13C),
               !is.na(MS), !is.na(Lstar)) |>
    arrange(depth) |>
    select(-comment,
           -d13C)
#+end_src

ensemble mode decomposition
***** with ~hht::EEMD~
was recently updated [2023-03-13 Mon]

this cites the same [cite:@Wu2009] paper

#+begin_src R
  trials <- 10
  nimf <- 10
  noise.amp <- 6.4e-7
  trials.dir <- "test"
  LEEMD <- hht::EEMD(wide$Lstar, wide$depth, noise.amp, trials, nimf, trials.dir = trials.dir)
  EEMD.result <- hht::EEMDCompile(trials.dir, trials, nimf)
  time.span <- range(wide$depth)
  imf.list <- 1:5
  hht::PlotIMFs(EEMD.result, time.span, imf.list, TRUE, TRUE)

  # they also do CEEMD!
  LCEEMD <- hht::CEEMD(wide$Lstar, wide$depth, noise.amp, trials)

  hht::PlotIMFs(LCEEMD, imf.list = 2:6, time.span = range(wide$depth))
#+end_src

***** with ~Rlibeemd::eemd~
or "complete variant" ~Rlibeemd::ceemdan~

the C-backend libeemd was most recently updated on [2019-01-11 Fri]

this cites more recent papers [cite:@Huang1999,@Torres2011]

#+begin_src R
  simp <- wide |>
    select(depth, Lstar) |>
    ## filter(depth <= 109.26) |>
    select(depth, Lstar) |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE)

  Leemd <- simp$Lstar |>
    Rlibeemd::eemd(num_imfs = 8)

  Lceemdan <- simp$Lstar |>
    Rlibeemd::ceemdan(#num_imfs = 10, # 1 residual (the weird trend) and 3 core cycles
                noise_strength = 0.9,
                threads = 4)
#+end_src

#+RESULTS:

#+begin_src R :results output graphics file :file imgs/CEEMDAN_base.png :width 2200 :height 1900 :res 300
  par(mfrow = c(5, 1), mar = c(0.5, 4, 0.5, 0), oma = c(5, 4, 4, 0))
  # raw data
  plot(-simp$depth, simp$Lstar |> as.ts(), col = "gray", type = "l", ylab = "Data - IMF 1-7", xaxt = "n", xlab = "")
  lines(-simp$depth, simp$Lstar - rowSums(Lceemdan[, 1:7]), col = "red") # all the smallest components subtracted
  abline(v = -agem_simple$strat_bot, col = "gray")
  ## plot(Lceemdan[, 1], type = "l") # ??
  ## plot(Lceemdan[, 2], type = "l") # ??
  plot(-simp$depth, Lceemdan[, 3], type = "l", col = "navyblue", ylab = "IMF 3", xaxt = "n", xlab = "") # precession?
  abline(v = -agem_simple$strat_bot, col = "gray")
  plot(-simp$depth, Lceemdan[, 4], type = "l", col = "darkgreen", ylab = "IMF 4", xaxt = "n", xlab = "") # obliquity?
  abline(v = -agem_simple$strat_bot, col = "gray")
  # the ecc compontents?
  plot(-simp$depth, Lceemdan[, 5], type = "l", col = "indianred",
       ylab = "IMF 5 and 6", xaxt = "n", xlab = "") # pretty much 100 kyr
  abline(v = -agem_simple$strat_bot, col = "gray")
  lines(-simp$depth, Lceemdan[, 6]) # seems like a 200 kyr cycle?
  plot(-simp$depth, Lceemdan[, 7], type = "l", col = "orange", xlab = "Depth (m)", ylab = "IMF 7") # pretty much 405 kyr
  ## lines(-simp$depth, Lceemdan[, 8])
  ## lines(-simp$depth, Lceemdan[, 9])
  abline(v = -agem_simple$strat_bot, col = "gray")
#+end_src

#+RESULTS:
[[file:imgs/CEEMDAN_base.png]]

# #+begin_src R :results output graphics file :file imgs/CEEMDAN.png :width 2200 :height 1900 :res 300
#+begin_src R :results output graphics file :file imgs/CEEMDAN.pdf :width 5 :height 5
  (
  wide |>
    ggplot(aes(x = depth, y = Lstar)) +
    scale_x_reverse() +
    geom_line() +
    geom_vline(aes(xintercept = strat_bot),
               data = agem_simple |> filter(strat_bot < 140),
               colour = "gray") +
    geom_line(colour = "red", data = simp)
  ) / (
    # contrast to bandpass filters
    filts |>
    filter(site == "Zumaia",
           proxy == "Lstar",
           depth_chunk == "full record",
           detrend_type == "value"
           ## detrend_type == "lin_scl_med"
           ) |>
    ggplot(aes(x = depth, y = filter)) +
    facet_grid(rows = vars(target), scales = "free_y", space = "free_y") +
    scale_x_reverse() +
    geom_vline(aes(xintercept = strat_bot),
               data = agem_simple |> filter(strat_bot < 140),
               colour = "gray") +
    geom_line(colour = "blue")
  ) / (
    Lceemdan |> as_tibble() |> mutate(idx = 0:(n() - 1)) |>
    pivot_longer(cols = matches("(IMF)|(Resid)")) |>
    separate(name, sep = " ", into = c("x", "imf")) |>
    mutate(imf = parse_integer(imf)) |>
    filter(imf > 2, imf < 8) |>
    ggplot(aes(x = idx, y = value)) +
    scale_x_reverse() +
    geom_line() +
    facet_grid(rows = vars(imf), scales = "free_y", space = "free_y")
  ) + plot_layout(axes = "collect", heights = c(1, 1, 3))
#+end_src

#+RESULTS:
[[file:imgs/CEEMDAN.pdf]]

5 6 and 7 seem to have the core eccentricity components
#+begin_src R
  plot(-simp$depth, ## simp$Lstar - # take the raw data
                    ## rowSums(Lceemdan[, 1:4]) - # subtract all the high-frequency noise
                    ## rowSums(Lceemdan[, 8:10]), # then subtract all the low frequency trends
                    rowSums(Lceemdan[, c(5,7)]),
       type = 'l')
#+end_src

#+RESULTS:

but the combination is messy still
#+RESULTS:

***** SOME using the floating age model?
:PROPERTIES:
:CREATED:  [2024-04-11 Thu 16:08]
:END:
:LOGBOOK:
- State "SOME"       from              [2024-04-11 Thu 17:03]
:END:
#+begin_src R

#+end_src
**** combine the trend removal dataframes into smooth_pred
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 14:26]
:END:
#+begin_src R :results none
    smooth_all <- smooth_basic |>
      mutate(scl = scale(value)[, 1],
             .before = gam_pred, .by = c(proxy, site)) |>
      rename(gam_scl = det) |>
      tidylog::left_join(smooth_loess) |>
      # add rw linear detrend
      tidylog::left_join(
                 smooth |> # just changed to new linear detrend!
                 rename(
                   lin_scl_rw = lin_scl,
                   lin_pred_rw = lin_pred,
                   lin_rw = lin,
                   lin_gam_pred = gam_pred,
                   lin_gam = gam,
                   lin_gam_scl = det)) |>
      # add fine linear detrend
      tidylog::left_join(
                 smooth_2 |>
                 ## mutate(chunk_fine = paste0("fine_", colour)) |>
                 select(-colour) |>
                 rename(lin_pred_fine = lin_pred,
                        lin_fine = lin,
                        lin_scl_fine = lin_scl)) |>
      # add coarse linear detrend
      tidylog::left_join(
                 smooth_3 |>
                 ## mutate(chunk_coarse = paste0("coarse_", colour)) |>
                 select(-colour) |>
                 rename(lin_pred_coarse = lin_pred,
                        lin_coarse = lin,
                        lin_scl_coarse = lin_scl)) |>
      # add med linear trend
      tidylog::left_join(
                 smooth_4 |>
                 ## mutate(chunk_med = paste0("med_", colour)) |>
                 select(-colour) |>
                 rename(lin_pred_med = lin_pred,
                        lin_med = lin,
                        lin_scl_med = lin_scl)) |>
      ## bind_rows(smooth_hp) |>
      pivot_longer(c(
        value, scl,
        lin_rw, lin_gam, lin_fine, lin_med, lin_coarse,
        lin_scl_rw, lin_scl_fine, lin_scl_med, lin_scl_coarse,
        gam_scl, loess_scl,
        gam_pred,
        lin_pred_rw, lin_pred_fine, lin_pred_med, lin_pred_coarse,
        lin_gam_pred, lin_gam_scl,
        loess_pred),
        names_to = "detrend_type", values_to = "value") |>
      filter(!is.na(value)) |>
      # append the lowpass filter
      bind_rows(
        smooth_hp |>
        select(proxy, site, depth = depth_linterp, value = lowpass) |>
        mutate(detrend_type = "lp_0.025")
      ) |>
      # which is subtracted to calculate the highpass
      bind_rows(
        smooth_hp |>
        select(proxy, site, depth = depth_linterp, value = highpass) |>
        mutate(detrend_type = "hp_scl")
      )
#+end_src
**** define consistent colours for detrend_type
:PROPERTIES:
:CREATED:  [2024-02-23 Fri 14:13]
:END:
#+begin_src R
  detrend_colours <- c(
    "scl" = "#483737", # !
    "gam_scl" = "#89a02c",
    "loess_scl" = "#008000",
    "hp_scl" = "#0088aa",
    "lin_scl_rw" = "#d40000",
    "lin_scl_fine" = "#ff9955",
    "lin_scl_med" = "#aa4400",
    "lin_scl_coarse" = "#803300",
    "value" = "#ff0000"
  )
#+end_src

#+RESULTS:

**** [#B] create a quick plot of all the detrend types
:PROPERTIES:
:CREATED:  [2024-01-11 Thu 10:47]
:END:
this is not easy to customize, so we manually create it below.
# #+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_detrend_types_all.png :width 2400 :height 2200 :res 300
# #+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_detrend_types_all.pdf :width 6 :height 5
***** for Lstar
#+begin_src R :results output graphics file :file imgs/detrend.png :width 800 :height 450
  pl_detrend <- smooth_all |>
    arrange(detrend_type) |>
    mutate(detrend_megatype = case_when(
               detrend_type %in% c("value") ~ "original",
               detrend_type %in% c("scl") ~ "scaled",
               detrend_type %in% c("lin_pred_rw", "lin_pred_fine", "lin_pred_med", "lin_pred_coarse", "lp_0.025", "gam_pred", "loess_pred") ~ "original",
               detrend_type %in% c("lin_rw", "lin_gam", "lin_fine", "lin_med", "lin_coarse") ~ "detrended",
               detrend_type %in% c("lin_scl_rw", "lin_scl_fine", "lin_scl_med", "lin_scl_coarse", "gam_scl", "loess_scl") ~ "scaled"
               )) |>
    filter(detrend_megatype != "detrended") |>
    filter(detrend_megatype != "scaled") |>
    filter(detrend_type %in% c("gam_pred", #"lin_pred_coarse",
                               "lin_pred_fine",
                               "lin_pred_med",
                               "lin_pred_coarse",
                               "lp_0.025", "value")) |>
    filter(proxy == "Lstar") |>
    ## filter(!detrend_type %in% c("lin_scl_rw", "lin_pred_rw")) |>
    ## filter(detrend_type %in% c("lin_pred_coarse", "value")) |>
    ## filter(detrend_type %in% c("lin_pred_rw","lin_pred_fine", "lin_pred_med","lin_pred_coarse", "value")) |>
    ## filter(!detrend_type %in% c("lin_rw", "lin_scl_rw", "lin_pred_rw")) |>
    ## filter(detrend_megatype == "detrended and scaled") |>
    ggplot(aes(x = depth, y = value,
               group = paste(proxy, site, detrend_type))) +
    theme(legend.position = c(.9, .7), legend.location = "inside") +
    ## facet_grid(rows = vars(proxy),
    ##            ## cols = vars(site),
    ##            ## scales = "free", space = "free_x",
    ##            labeller = labeller(proxy = c("d13C" = "δ¹³C",
    ##                                          "MS" = "MS",
    ##                                          "Lstar" = "L*")),
    ##            switch = "y") +
    labs(x = "Depth (m)", y = "L*") +
    coord_cartesian(xlim = c(183, 0)) +
    scale_x_reverse(breaks = seq(-20, 200, 20),
                    minor_breaks = seq(-10, 200, 10)) +
    scale_colour_manual(name = "",
                        values = c("Zumaia" = "purple",
                                   "Sopelana" = "orange",
                                   "Solution" = "black")) +
    geom_vline(aes(xintercept = strat_bot, colour = site),
               alpha = .2,
               data = agem_simple) +
    geom_line(aes(colour = site),
              alpha = .3,
              data = \(x) x |> filter(detrend_type == "value")) +
    ggnewscale::new_scale_color() +
    scale_color_manual(values =
                          setNames(detrend_colours,
                                   c("scl", "gam_pred", "loess_pred", "lp_0.025",
                                     "lin_pred_rw", "lin_pred_fine", "lin_pred_med", "lin_pred_coarse",
                                     "value"))) +
    # interactive loess so we can quickly iterate
    ## geom_smooth(colour = "red",
    ##             method = "loess", span = 0.2,
    ##             data = \(x) x |> filter(detrend_type == "value")) +
    # first draw the lines so we can pass the group argument
    geom_line(aes(colour = detrend_type, group = paste(proxy, site, detrend_type, colour)),
              data = \(x) x |>
              filter(str_detect(detrend_type, "^lin_pred"))) +
    geom_line(aes(colour = detrend_type),#alpha = .5,
              data = \(x) x |>
                          filter(detrend_type != "value") |>
                          filter(str_detect(detrend_type, "^lin_pred", negate = TRUE)))

    ## cairo_pdf("imgs/Zumaia-Sopelana_detrend_types_all.pdf",
  ##           width = 9.6, height = 2)

  pl_detrend
  ## dev.off()
#+end_src

#+RESULTS:
[[file:imgs/detrend.png]]

[[file:imgs/Zumaia-Sopelana_detrend_types_all.pdf]]

***** for d13C
same but for d13C
#+begin_src R :results output graphics file :file imgs/detrend_d13C.png :width 800 :height 450
  pl_detrend_d13C <- smooth_all |>
    arrange(detrend_type) |>
    mutate(detrend_megatype = case_when(
               detrend_type %in% c("value") ~ "original",
               detrend_type %in% c("scl") ~ "scaled",
               detrend_type %in% c("lin_pred_rw", "lin_pred_fine", "lin_pred_med", "lin_pred_coarse", "lp_0.025", "gam_pred", "loess_pred") ~ "original",
               detrend_type %in% c("lin_rw", "lin_gam", "lin_fine", "lin_med", "lin_coarse") ~ "detrended",
               detrend_type %in% c("lin_scl_rw", "lin_scl_fine", "lin_scl_med", "lin_scl_coarse", "gam_scl", "loess_scl") ~ "scaled"
               )) |>
    filter(detrend_megatype != "detrended") |>
    filter(detrend_megatype != "scaled") |>
    filter(detrend_type %in% c("gam_pred", #"lin_pred_coarse",
                               "lin_pred_fine",
                               "lin_pred_med",
                               "lin_pred_coarse",
                               "lp_0.025", "value")) |>
    filter(proxy == "d13C") |>
    ## filter(!detrend_type %in% c("lin_scl_rw", "lin_pred_rw")) |>
    ## filter(detrend_type %in% c("lin_pred_coarse", "value")) |>
    ## filter(detrend_type %in% c("lin_pred_rw","lin_pred_fine", "lin_pred_med","lin_pred_coarse", "value")) |>
    ## filter(!detrend_type %in% c("lin_rw", "lin_scl_rw", "lin_pred_rw")) |>
    ## filter(detrend_megatype == "detrended and scaled") |>
    ggplot(aes(x = depth, y = value,
               group = paste(proxy, site, detrend_type))) +
    theme(legend.position = c(.9, .7), legend.location = "inside") +
    ## facet_grid(rows = vars(proxy),
    ##            ## cols = vars(site),
    ##            ## scales = "free", space = "free_x",
    ##            labeller = labeller(proxy = c("d13C" = "δ¹³C",
    ##                                          "MS" = "MS",
    ##                                          "Lstar" = "L*")),
    ##            switch = "y") +
    labs(x = "Depth (m)", y = expression(delta^{13}*C)) +
    coord_cartesian(xlim = c(183, 0)) +
    scale_x_reverse(breaks = seq(-20, 200, 20),
                    minor_breaks = seq(-10, 200, 10)) +
    scale_colour_manual(name = "",
                        values = c("Zumaia" = "purple",
                                   "Sopelana" = "orange",
                                   "Solution" = "black")) +
    geom_vline(aes(xintercept = strat_bot, colour = site),
               alpha = .2,
               data = agem_simple) +
    geom_line(aes(colour = site),
              alpha = .3,
              data = \(x) x |> filter(detrend_type == "value")) +
    ggnewscale::new_scale_color() +
    scale_color_manual(values =
                          setNames(detrend_colours,
                                   c("scl", "gam_pred", "loess_pred", "lp_0.025",
                                     "lin_pred_rw", "lin_pred_fine", "lin_pred_med", "lin_pred_coarse",
                                     "value"))) +
    # interactive loess so we can quickly iterate
    ## geom_smooth(colour = "red",
    ##             method = "loess", span = 0.2,
    ##             data = \(x) x |> filter(detrend_type == "value")) +
    # first draw the lines so we can pass the group argument
    geom_line(aes(colour = detrend_type, group = paste(proxy, site, detrend_type, colour)),
              data = \(x) x |>
              filter(str_detect(detrend_type, "^lin_pred"))) +
    geom_line(aes(colour = detrend_type),#alpha = .5,
              data = \(x) x |>
                          filter(detrend_type != "value") |>
                          filter(str_detect(detrend_type, "^lin_pred", negate = TRUE)))

    ## cairo_pdf("imgs/Zumaia-Sopelana_detrend_types_all.pdf",
  ##           width = 9.6, height = 2)

  pl_detrend_d13C
  ## dev.off()
#+end_src

#+RESULTS:
[[file:imgs/detrend_d13C.png]]

***** for MS
same for MS
#+begin_src R :results output graphics file :file imgs/detrend_MS.png :width 800 :height 450
  pl_detrend_MS <- smooth_all |>
    arrange(detrend_type) |>
    mutate(detrend_megatype = case_when(
               detrend_type %in% c("value") ~ "original",
               detrend_type %in% c("scl") ~ "scaled",
               detrend_type %in% c("lin_pred_rw", "lin_pred_fine", "lin_pred_med", "lin_pred_coarse", "lp_0.025", "gam_pred", "loess_pred") ~ "original",
               detrend_type %in% c("lin_rw", "lin_gam", "lin_fine", "lin_med", "lin_coarse") ~ "detrended",
               detrend_type %in% c("lin_scl_rw", "lin_scl_fine", "lin_scl_med", "lin_scl_coarse", "gam_scl", "loess_scl") ~ "scaled"
               )) |>
    filter(detrend_megatype != "detrended") |>
    filter(detrend_megatype != "scaled") |>
    filter(detrend_type %in% c("gam_pred", #"lin_pred_coarse",
                               "lin_pred_fine",
                               "lin_pred_med",
                               "lin_pred_coarse",
                               "lp_0.025", "value")) |>
    filter(proxy == "MS") |>
    ## filter(!detrend_type %in% c("lin_scl_rw", "lin_pred_rw")) |>
    ## filter(detrend_type %in% c("lin_pred_coarse", "value")) |>
    ## filter(detrend_type %in% c("lin_pred_rw","lin_pred_fine", "lin_pred_med","lin_pred_coarse", "value")) |>
    ## filter(!detrend_type %in% c("lin_rw", "lin_scl_rw", "lin_pred_rw")) |>
    ## filter(detrend_megatype == "detrended and scaled") |>
    ggplot(aes(x = depth, y = value,
               group = paste(proxy, site, detrend_type))) +
    theme(legend.position = c(.9, .7), legend.location = "inside") +
    ## facet_grid(rows = vars(proxy),
    ##            ## cols = vars(site),
    ##            ## scales = "free", space = "free_x",
    ##            labeller = labeller(proxy = c("d13C" = "δ¹³C",
    ##                                          "MS" = "MS",
    ##                                          "Lstar" = "L*")),
    ##            switch = "y") +
    labs(x = "Depth (m)", y = "MS") +
    coord_cartesian(xlim = c(183, 0)) +
    scale_x_reverse(breaks = seq(-20, 200, 20),
                    minor_breaks = seq(-10, 200, 10)) +
    scale_colour_manual(name = "",
                        values = c("Zumaia" = "purple",
                                   "Sopelana" = "orange",
                                   "Solution" = "black")) +
    geom_vline(aes(xintercept = strat_bot, colour = site),
               alpha = .2,
               data = agem_simple) +
    geom_line(aes(colour = site),
              alpha = .3,
              data = \(x) x |> filter(detrend_type == "value")) +
    ggnewscale::new_scale_color() +
    scale_color_manual(values =
                          setNames(detrend_colours,
                                   c("scl", "gam_pred", "loess_pred", "lp_0.025",
                                     "lin_pred_rw", "lin_pred_fine", "lin_pred_med", "lin_pred_coarse",
                                     "value"))) +
    # interactive loess so we can quickly iterate
    ## geom_smooth(colour = "red",
    ##             method = "loess", span = 0.2,
    ##             data = \(x) x |> filter(detrend_type == "value")) +
    # first draw the lines so we can pass the group argument
    geom_line(aes(colour = detrend_type, group = paste(proxy, site, detrend_type, colour)),
              data = \(x) x |>
              filter(str_detect(detrend_type, "^lin_pred"))) +
    geom_line(aes(colour = detrend_type),#alpha = .5,
              data = \(x) x |>
                          filter(detrend_type != "value") |>
                          filter(str_detect(detrend_type, "^lin_pred", negate = TRUE)))

  pl_detrend_MS
#+end_src

#+RESULTS:
[[file:imgs/detrend_MS.png]]

***** combine them all
#+begin_src R :results output graphics file :file imgs/depth_detrend.pdf :width 6 :height 5
  pl_detrend / pl_detrend_MS / pl_detrend_d13C + plot_layout(guides = "collect", axes = "collect")
#+end_src

#+RESULTS:
[[file:imgs/depth_detrend.pdf]]

**** compare the detrending for the different proxies
:PROPERTIES:
:CREATED:  [2024-03-22 Fri 16:22]
:END:
#+begin_src R
  (pl_detrend / pl_detrend_d13C / pl_detrend_MS) + plot_layout(axes = "collect")
#+end_src
**** create smooth_pred, a subset with only detrend types we care about
:PROPERTIES:
:CREATED:  [2024-01-11 Thu 10:48]
:END:
#+begin_src R
  smooth_pred <- smooth_all |>
    tidylog::filter(detrend_type %in%
                    c(## "value",
                      "scl",
                      "lin_scl_rw", "lin_scl_fine", "lin_scl_med", "lin_scl_coarse",
                      "gam_scl", "loess_scl",
                      "hp_scl"
                      )) |>
    mutate(detrend_type = factor(detrend_type,
                                 levels = names(detrend_colours) #c("scl", "gam_scl", "hp_scl", "lin_scl_fine", "lin_scl_med", "lin_scl_coarse")
                                 )) |>
    mutate(depth_chunk = list(c(
             "full record", "depth < 109.26", "depth >= 109.26"))) |>
    unnest(depth_chunk) |>
    tidylog::filter(
               (site == "Zumaia" & depth_chunk == "depth < 109.26" & depth < 109.26) |
               (site == "Zumaia" & depth_chunk == "depth >= 109.26" & depth >= 109.26) |
               ((site == "Zumaia" | site == "Sopelana") & depth_chunk == "full record")
           ) |>
    mutate(depth_chunk = factor(depth_chunk,
                                levels = c("full record",
                                           "depth < 109.26",
                                           "depth >= 109.26")))

  smooth_pred |> distinct(detrend_type)
#+end_src

#+RESULTS:
#+begin_example
filter: removed 61,165 rows (67%), 30,561 rows remaining
filter: removed 39,359 rows (43%), 52,324 rows remaining
# A tibble: 7 × 1
  detrend_type
  <fct>
1 scl
2 lin_scl_rw
3 lin_scl_fine
4 lin_scl_med
5 lin_scl_coarse
6 gam_scl
7 hp_scl
#+end_example

**** CANC show how the linear/gam detrending works
CLOSED: [2024-02-20 Tue 14:37]
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 16:19]
:END:
:LOGBOOK:
- Note taken on [2024-02-20 Tue 14:38] \\
  see above
- Note taken on [2024-01-29 Mon 13:38] \\
  i think I messed this one up when I tried to make it fancy
:END:
we make this plot with the raw results because it gives us more control but more code.

#+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_records_complicated.png :height 2200 :width 2600 :res 300
  xnot <- 144
  ## prx <- "MS"
  ## prx <- "d13C"
  prx <- "Lstar"

  smooth |>
    filter(
      site == "Zumaia",
      proxy == prx
    ) |>
    mutate(mean = mean(value),
           med = median(value),
           sd = sd(value),
           max = max(value),
           min = min(value),
           rng = max - min,
           .by = c(site,proxy)) |>
    ggplot(aes(x = depth, y = value,
               group = paste(site, proxy))) +
    facet_grid(rows = vars(proxy),
               scales = "free_y") +
    ## scale_colour_brewer(type = "qual") +
    scale_colour_manual(values = detrend_colours) +
    scale_size_manual(values = c("FALSE" = 1, "TRUE" = 1.3)) +
    coord_cartesian(xlim = c(178, 0)) +
    labs(x = "Depth (m)", y = "Proxy value", colour = "", size = "Well-defined") +
    scale_x_continuous(minor_breaks = seq(0, 200, 10)) +

    # r/w intervals
    ## scale_fill_manual(values = c("red" = "indianred", "pink" = "pink", "white" = "gray"),
    ##                   guide = "none") +
    ## geom_rect(aes(fill = str_sub(colour, 1, -2),
    ##               xmin = depth - .1, xmax = depth + .1,
    ##               ymin = min, ymax = (min - rng) / rng)) +

    # "raw" data
    geom_line(colour = "gray") +
    geom_text(aes(x = xnot, y = med, label = "value"),
              size = 2, hjust = 1) +
    # raw value scaled
    geom_line(aes(y = (med - 3 * sd) + scale(value)[, 1]), colour = "gray") + # scaled
    geom_text(aes(x = xnot, y = med - 3 * sd,
                  label = "scl = scale(value)"),
             size = 2, hjust = 1)

    # raw data after subtracting lines for red/white intervals
    ## geom_line(aes(y = lin_scl - 5), colour = "gray") +
    ## annotate("text", x = xnot, y = -5, label = "lin_scl = scale(value-lin)",
    ##          size = 2, hjust = 1) +
    # TEMP other linear detrend approaches: results

    ## geom_line(aes(y = lin_scl - 30), colour = "gray") +
    ## annotate("text", x = xnot, y = -30, label = "lin_scl_rw",
    ##          size = 2, hjust = 1) +
    ## geom_line(aes(y = lin_scl - 35), colour = "gray",
    ##           data = smooth_2 |> filter(site == "Zumaia"## , proxy == prx
    ##                                     )) +
    ## annotate("text", x = xnot, y = -35, label = "lin_scl_fine",
    ##          size = 2, hjust = 1) +
    ## geom_line(aes(y = lin_scl - 40), colour = "gray",
    ##           data = smooth_3 |> filter(site == "Zumaia"## , proxy == prx
    ##                                     )) +
    ## annotate("text", x = xnot, y = -40, label = "lin_scl_coarse",
    ##          size = 2, hjust = 1) +
    ## # TEMP

    ## # scale(value - gam_pred) = det
    ## geom_line(aes(y = scale(value - gam_pred)[, 1] - 10), colour = "gray") +
    ## annotate("text", x = xnot, y = -10, label = "gam_scl = scale(value-gam)",
    ##          size = 2, hjust = 1) +

    ## # scale(value - lowpass) = highpass
    ## geom_line(aes(x = depth_linterp, y = scale(highpass)[,1] - 20), colour = "gray",
    ##           data = smooth_hp |>
    ##             filter(site == "Zumaia"## , proxy == prx
    ##                    )) +
    ## annotate("text", x = xnot, y = -20, label = "hp_scl = scale(value-lowpass)",
    ##          size = 2, hjust = 1) +

    ## # trends: lin, gam, lowpass
    ## geom_line(aes(y = gam_pred, colour = "gam"),
    ##           linewidth = 1.2,alpha = .9,
    ##           data = smooth_basic |>
    ##             filter(site == "Zumaia"## , proxy == prx
    ##                    )) +
    ## geom_line(aes(x = depth_linterp, y = lowpass,
    ##               colour = detrend_type),
    ##             linewidth = 1.2,alpha = .9,
    ##           data = smooth_hp |>
    ##             mutate(detrend_type = "lowpass") |>
    ##             filter(site == "Zumaia"## , proxy == prx
    ##                    )) +
    ## ## geom_line(aes(y = gam_pred - 5, colour = "lin_gam"),
    ## ##           linewidth = 1.2,
    ## ##           data = smooth |>
    ## ##             filter(site == "Zumaia", proxy == prx)) +

    ## geom_line(aes(y = lin_pred, colour = "lin_rw", group = colour),
    ##           linewidth = 1.2, alpha = .9,
    ##           data = smooth |>
    ##             filter(site == "Zumaia"## , proxy == prx
    ##                    )) +
    ## geom_line(aes(y = lin_pred, colour = "lin_fine", group = colour),
    ##           linewidth = 1.2, alpha = .9,
    ##           data = smooth_2 |>
    ##             filter(site == "Zumaia"## , proxy == prx
    ##                    )) +
    ## geom_line(aes(y = lin_pred, colour = "lin_coarse", group = colour),
    ##           linewidth = 1.2, alpha = .9,
    ##           data = smooth_3 |>
    ##             filter(site == "Zumaia"## , proxy == prx
    ##                    )) +

    # filters
    ## geom_line(aes(y = filt, colour = detrend_type, group = target),
    ##           data = filts |>
    ##             filter(site == "Zumaia", proxy == "MS")) +

    # age model from the log
    ## geom_point(aes(x = strat_bot, y = -2,
    ##                size = !is.na(comment)),
    ##            inherit.aes = FALSE,
    ##            data = agem |>
    ##              filter(minmax == "minimum")) +
    ## annotate("text", x = xnot, y = -2, label = "405 kyr minima (field)", hjust = 1, size = 2.5) +
    ## annotate("text", x = xnot, y = 2, label = "405 kyr maxima (field)", hjust = 1, size = 2.5) +
    ## geom_segment(aes(x = strat_bot, xend = strat_top,
    ##                  y = 2, yend = 2),
    ##              inherit.aes = FALSE,
    ##              data = agem |>
    ##                filter(minmax == "maximum"),
    ##              linewidth = 1)
    ## try to make it into little sine waves
    ## geom_segment(aes(x = strat_bot, xend = strat_top,
    ##                  y = if_else(minmax == "minimum", 1.5, -1.5),
    ##                  yend = if_else(minmax == "minimum", -1.5, 1.5)),
    ##              data = agem) +
    ## theme(legend.position = "none")
#+end_src

#+name: fig:detrend
#+caption: Zumaia and Sopelana trend removal using various strategies (coloured lines). See cref:tab:detrend_types for an overview. Bottom gray lines show results of these long-term detrending strategies with offsets incremented by -5. The highpass was constructed by subtracting a lowpass filter with a frequency \lt\qty{0.035}{cycles\per\metre} (period of \qty{28.57}{\metre}).
#+RESULTS:
[[file:imgs/Zumaia-Sopelana_records_complicated.png]]

*** COMMENT figures to inspect if it worked
:PROPERTIES:
:CREATED:  [2023-11-14 Tue 13:26]
:END:
**** did the linear trend removal work?
:PROPERTIES:
:CREATED:  [2023-09-26 Tue 10:57]
:END:
***** lines
#+begin_src R :results output graphics file :file imgs/Zumaia_linear-trend-removal.png :width 800
  smooth |>
    ggplot(aes(x = depth, y = value)) +
    geom_line() +
    facet_grid(rows = vars(proxy), scales = "free_y") +
    geom_line(aes(y = lin_pred, group = paste(site, colour)), colour = "red", linewidth = 2)
#+end_src

#+caption: Zumaia/Sopelana MS/L*/d13C linear trend removal.
#+RESULTS:
[[file:imgs/Zumaia_linear-trend-removal.png]]

***** gam
#+begin_src R :results output graphics file :file imgs/Zumaia_gam-trend-removal.png :width 800
  smooth |>
    ggplot(aes(x = depth, y = lin)) +
    geom_line() +
    facet_grid(rows = vars(proxy), scales = "free_y") +
    geom_line(aes(y = gam_pred, group = paste(site)), colour = "red", linewidth = 2)
#+end_src

#+caption: Zumaia/Sopelana MS/L*/d13C gam trend removal (after linear trend removal).
#+RESULTS:
[[file:imgs/Zumaia_gam-trend-removal.png]]

***** detrended result
#+begin_src R :results output graphics file :file imgs/Zumaia_linear-gam-trend-removal.png :width 800
  smooth |>
    ggplot(aes(x = depth, y = det)) +
    geom_line(aes(y=lin_scl)) +
    geom_line(colour = "red") +
    facet_grid(rows = vars(proxy), scales = "free_y") #+
    ## geom_line(aes(y = gam_pred, group = paste(site)), colour = "red", linewidth = 2)
#+end_src

#+caption: Zumaia/Sopelana MS/L*/d13C detrended record (after linear trend and gam removal).
#+RESULTS:
[[file:imgs/Zumaia_linear-gam-trend-removal.png]]

***** COMMENT gam with custom knots around the colour transitions
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 15:43]
:END:
#+begin_src R :eval never
  smooth_k <- comp |>
    nest(.by = c(proxy, site)) |> # nest_by is different!!
    mutate(
      gam = map(data,
                     ~ mgcv::gam(value ~ s(depth, bs = "cs"),
                                 method = "REML",
                                 k = 6,
                                 knots = c(-5, 0, 58.75, 85, 109, 145),
                                 data = .))) |>
    mutate(
      gam_pred = map(gam, predict),
    ) |>
    select(-gam) |>
    unnest(cols = c(data, gam_pred)) |>
    mutate(det = scale(value - gam_pred)[, 1], .by = c(proxy, site))
#+end_src

#+RESULTS:
: Error in `mutate()`:
: ℹ In argument: `gam = map(...)`.
: Caused by error in `map()`:
: ℹ In index: 1.
: Caused by error in `data[[txt]]`:
: ! subscript out of bounds
: Run `rlang::last_trace()` to see where the error occurred.

*** COMMENT plot long-term trend removal
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 14:30]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_long-term-trend.png :width 900 :height 500
  (smooth |>
   filter(site == "Zumaia", proxy == "MS") |>
   ggplot(aes(x = depth, y = dec)) +
   geom_line(aes(y = value), colour = "gray") +
   ## geom_line(aes(y = det), smooth_basic) +
   geom_line(colour = "gray4") +
   geom_line(aes(y = mean_colour), colour = "darkgreen") +
   ## geom_smooth(method = "loess", span = .05) +
   geom_line(aes(y = gam_pred, group = site), colour = "blue", linewidth = 2) +
   geom_line(aes(y = gam_pred, group = site), linewidth = 2,
             colour = "red",
             data = smooth_basic |> filter(site == "Zumaia", proxy == "MS")) +
   facet_grid(rows = vars(proxy), scales = "free_y") #+
    ## geom_vline(xintercept = c(59, 85, 109)) +
    ## annotate("rect",
    ##          xmin = c(-5, 0, 58.75, 85, 109),
    ##          xmax = c(0, 59, 85, 109, 145),
    ##          ymin = 0, ymax = 1,
    ##          fill = c("gray", "red", "gray", "red", "gray"),
    ##          alpha = .2
   ##          )
   ) /
  (smooth |>
   filter(site == "Zumaia", proxy == "MS") |>
   ggplot(aes(x = depth, y = det)) +
   geom_line() +
   ## geom_smooth(method = "loess", span = .05) +
   facet_grid(rows = vars(proxy), scales = "free_y") +
   ## geom_vline(xintercept = c(59, 85, 109)) +
   annotate("rect",
            xmin = c(-5, 0, 59, 85, 109),
            xmax = c(0, 59, 85, 109, 145),
            ymin = 0, ymax = 1,
            fill = c("gray", "red", "gray", "red", "gray"),
            alpha = .2
            ))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_long-term-trend.png]]

*** analysis in the depth domain
:PROPERTIES:
:CREATED:  [2023-09-29 Fri 13:11]
:END:
**** spectral analysis
:PROPERTIES:
:CREATED:  [2023-10-03 Tue 16:05]
:END:
***** MTM spectra
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 10:56]
:END:
#+begin_src R
  specs_fancy <- smooth_pred |>
    nested_spectral_analysis(nest = c("proxy", "site", "detrend_type", "depth_chunk"),
                             detrend = TRUE,
                             x = depth, y = value)
#+end_src

#+RESULTS:
***** mtmML96
:PROPERTIES:
:CREATED:  [2024-02-20 Tue 15:19]
:END:
#+begin_src R
  specs_ML96 <- smooth_pred |>
    nest(.by = c("proxy", "site", "detrend_type", "depth_chunk")) |>
    mutate(mtmML96 = map(data,
                      ~ . |>
                        select(depth, value) |>
                        astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                        astrochron::mtmML96(genplot = F, verbose = F,
                                            output = 1,
                                            detrend = TRUE,
                                            medsmooth = 0.2) |>
                        as_tibble() |>
                        tidyr::pivot_longer(c("AR1_90_power",
                                              "AR1_95_power",
                                              "AR1_99_power"),
                                            names_to = c("AR1", ".width"),
                                            names_pattern = "^(AR1)_(9[950])",
                                            values_to = "ar1_power") |>
                        dplyr::select(-.data$AR1) |>
                        dplyr::mutate(.width = readr::parse_double(paste0(".", .data$.width))) |>
                        dplyr::rename(frequency = .data$Frequency,
                                      power = .data$Power,
                                      harmonic_cl = .data$Harmonic_CL,
                                      ar1_cl = .data$AR1_CL,
                                      ar1_fit = .data$AR1_fit,
                                      med_smooth_power = .data$Median_Smoothed_Power))) |>
    select(-data) |>
    unnest(cols = c(mtmML96))
#+end_src
***** lowspec
:PROPERTIES:
:CREATED:  [2024-01-30 Tue 16:43]
:END:
#+begin_src R
  specs_lowspec <- smooth_pred |>
    nest(.by = c("proxy", "site", "detrend_type", "depth_chunk")) |>
    mutate(lowspec = map(data,
                      ~ . |>
                        select(depth, value) |>
                        astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                        astrochron::lowspec(genplot = F, verbose = F, output = 1,
                                            lowspan = 3, detrend = TRUE) |>
                        as_tibble()
                        )) |>
    select(-data) |>
    unnest(cols = c(lowspec)) |>
    rename(frequency = Frequency, power = Prewhite_power)
#+end_src

#+RESULTS:

***** FFT periodogram
:PROPERTIES:
:CREATED:  [2023-11-16 Thu 14:47]
:END:
#+begin_src R
  specs_fft <- smooth_pred |>
    nest(.by = c("proxy", "site", "detrend_type", "depth_chunk")) |>
    mutate(fft = map(data,
                      ~ . |>
                        select(depth, value) |>
                        astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                        astrochron::periodogram(genplot = F, verbose = F, output = 1,
                                                detrend = TRUE) |>
                        as_tibble()
                        )) |>
    select(-data) |>
    unnest(cols = c(fft)) |>
    rename(frequency = Frequency, amplitude = Amplitude, power = Power, phase = Phase)
#+end_src

#+RESULTS:

***** Blackman-Tukey
:PROPERTIES:
:CREATED:  [2023-11-16 Thu 14:13]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-11-16 Thu 15:01]
:END:
#+begin_src R
  # I had some issues with installing the package before, this is how I
  # circumvented that. Now I've just installed it as TSAUMN!
  ## source("https://github.com/jrevenaugh/TSAUMN2/raw/main/R/spec.bt.R")
  ## source("https://github.com/jrevenaugh/TSAUMN2/raw/main/R/ttools.R")

  ## spec_bt <- smooth_pred |>
  ##   filter(proxy == "MS", site == "Zumaia", detrend_type == "value") |>
  ##   select(depth, value) |>
  ##   astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
  ##   pull(value) |>
  ##   spec.bt(plot = FALSE)
  ##   ## select(c("freq", "spec"))

  specs_bt <- smooth_pred |>
    nest(.by = c("proxy", "site", "detrend_type", "depth_chunk")) |>
    mutate(bt = map(data,
                      ~ . |>
                        select(depth, value) |>
                        astrochron::linterp(dt = .1, genplot = FALSE, verbose = FALSE) |>
                        pull(value) |>
                        TSAUMN::spec.bt(deltat = .1, plot = FALSE, demean = TRUE, detrend = TRUE))) |>
    select(-data) |>
    mutate(freq = map(bt, pluck, "freq"),
           spec = map(bt, pluck, "spec")) |>
    select(-bt) |>
    unnest(cols = c(freq, spec)) |>
    rename(frequency = freq, power = spec)
#+end_src

#+RESULTS:

***** Lomb-Scargle
:PROPERTIES:
:CREATED:  [2024-01-29 Mon 13:39]
:END:
#+begin_src R
  specs_ls <- smooth_pred |>
    nest(.by = c("proxy", "site", "detrend_type", "depth_chunk")) |>
    mutate(ls = map(data,
                      ~ . |>
                        select(depth, value) |>
                        TSAUMN::spec.ls(plot = FALSE, detrend = TRUE) |>
                        as_tibble())) |>
    select(-data) |>
    unnest(ls) |>
    rename(frequency = freq, power = spec)
#+end_src

#+RESULTS:

***** use MTLS on the record
:PROPERTIES:
:CREATED:  [2023-11-16 Thu 12:01]
:END:
MTLS is the Multi-taper Averaged Lomb-Scargle periodogram of (un)evenly spaced data. Available on [[https://github.com/jrevenaugh/TSAUMN2/blob/main/R/spec.mtls.R][the author's GitHub]].
It's pretty slow.
#+begin_src R
  # I had some issues with installing the package before, this is how I
  # circumvented that. Now I've just installed it as TSAUMN!
  ## source("https://github.com/jrevenaugh/TSAUMN2/raw/main/R/spec.mtls.R")
  ## source("https://github.com/jrevenaugh/TSAUMN2/raw/main/R/mtm_plots.R")

  specs_mtls <- smooth_pred |>
    nest(.by = c("proxy", "site", "detrend_type", "depth_chunk")) |>
    mutate(mtls = map(data,
                      ~ . |>
                        select(depth, value) |>
                        # NOTE: no need to linearly interpolate!
                        # That's the point!
                        TSAUMN::spec.mtls(plot = FALSE, detrend = TRUE) |>
                        as_tibble())) |>
    select(-data) |>
    unnest(mtls) |>
    rename(frequency = freq, power = spec)
#+end_src

#+RESULTS:

**** make plot of spectra and annotate the target frequency ranges for bp filtering
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 10:57]
:END:
In [cite:@Batenburg2012;@Batenburg2014] they specify different filter ranges for each proxy, but it's not entirely clear what the ranges are based on. At least the correspond roughly to what we see in the spectrum.

The blue rectangles correspond to our simplified filter intervals where we just take a desired period, convert it to a frequency, then add/subtract a certain percentage from each (\pm40% in the last iteration).
The frequency ranges need to be a little broad to encapsulate the potentially variable sedimentation rates throughout the record.

Note that we flip our default faceting here, because it makes comparison between detrend_types easier.
# #+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_mtm.png :width 3200 :height 2600 :res 300
#+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_mtm.pdf :width 9 :height 6
  my_filt <- \(d) d |>
                    ## filter(site == "Zumaia",
                    ##        depth_chunk == "depth < 109.26") |>
                    filter(detrend_type == "lin_scl_med") |>
                    ## filter(detrend_type == "value") |>
                    ## filter(detrend_type %in% c("value", "lin_scl_med")) |>
                    filter((str_detect(depth_chunk, "^depth") & site == "Zumaia") |
                           depth_chunk == "full record") #|>
                    ## filter(depth_chunk == "full record") |>
                    ## filter(site == "Zumaia")

  my_rect_filt <-
    \(d) d |>
                     ## filter(site == "Zumaia", depth_chunk == "depth < 109.26") |>
      ## filter((str_detect(depth_chunk, "^depth") & site == "Zumaia") |
      ##        depth_chunk == "full record")
        ## filter(depth_chunk == "full record") |>
        filter(site == "Zumaia")


  specs_fancy |>
    my_filt() |>
    ggplot(aes(x = frequency, y = power,
               ## colour = detrend_type,
               ## linetype = detrend_type,
               group = paste(detrend_type, proxy, site, depth_chunk))) +
    facet_grid(cols = vars(site, depth_chunk),
               rows = vars(proxy)
               ## scales = "free_y", space = "free_y"
               ) +
    coord_cartesian(
      ## xlim = c(1e-4, 0.0625) * 100 # log axis
      ## xlim = c(0, 2), # linear axis
      ## xlim = c(0, .4),  # linear axis zoomed on 405 and 100 kyr
      xlim = c(0, 1.5),  # linear axis
      ## xlim = c(0, .1),  # linear axis zoomed on 405 and lower to find lowpass/highpass cutoff
      ## xlim = c(0, 1.5),  # linear axis zoomed on 405 and 100 kyr
      ## ylim = c(0, 3)
      ## ylim = c(2e-5, 1.5) # linear axis
      ## ylim = c(-0.001, .016) # linear axis zoomed in
      ## ylim = c(2e-6, 1) # log for raw
      ylim = c(1e-4, 1e-1) # log for lin_scl_fine
      ) +
    scale_y_log10() +
    annotation_logticks(sides = "l") + # remember to update if we switch back to log!
    scale_x_continuous(
    ## scale_x_log10(
      sec.axis = sec_axis(trans = ~ 1 / .x,
                                           name = "Period (m)",
                                           breaks = c(10, 2, 0.5))) +
    labs(x = "Frequency (cycles/m)", y = "Spectral power",
         colour = "Spectral analysis type") +
    labs(fill = "Filter interval from study") +
    ## scale_colour_manual(values = c("MTM" = "solid","FFT" = "dotdash", "MTLS" = "longdash")) +
    scale_colour_manual(values = c("MTM" = "indianred",
                                   "MTM ML96" = "orange",
                                   "LOWSPEC" = "black",
                                   "FFT" = "darkgray", "MTLS" = "purple",
                                   "LS" = "lightblue", "BT" = "orange")) +

    # annotate the Batenburg 2014 filters
    geom_rect(aes(xmin = flow, xmax = fhigh,
                  ## ymin = 2e-6, ymax = 1e-5, # log axis raw
                  ymin = 1e-5, ymax = 1e-4, # log axis raw
                  ## ymin = -.002, ymax = -.001, # linear axis
                  fill = ref),
              inherit.aes = FALSE,
              show.legend = FALSE,
              ## colour = "black",
              alpha = .2,
              data = bat_filters |>
                my_rect_filt()
              ) +
    # show our filters
    geom_rect(aes(xmin = flow, xmax = fhigh,
                  ymin = 1e-5, ymax = 2e-5, # log axis
                  ## ymin = -0.001, ymax = 0, # linear axis
                  fill = ref),
              inherit.aes = FALSE,
              show.legend = FALSE,
              alpha = .3,
              data = my_filters |>
                filter(site == "Zumaia") |>
                filter(depth_chunk == "full record") |>
                my_rect_filt()) +
    ggnewscale::new_scale_fill() +

    # plot periodogram
    geom_line(aes(colour = "FFT"),
              data = specs_fft |> my_filt()) +
    # annotate Blackman-Tukey spectra
    # commented out because the y axis values are waaaay higher (up at 1--10)
    ## geom_line(aes(colour = "BT"),
    ##           data = specs_bt |> my_filt()) +
    geom_line(aes(colour = "LS"),
              data = specs_ls |> my_filt()) +
    # plot MTM spectra
    geom_line(aes(colour = "MTM")) +
    geom_ribbon(aes(ymin = ar1_fit, ymax = ar1_power,
                    linetype = NA, group = paste(detrend_type, .width)),
                show.legend = FALSE,
                fill = "indianred", colour = NA,
                alpha = .1) +

    geom_line(aes(y = med_smooth_power, colour = "MTM ML96"),
              linetype = "dashed",
              data = specs_ML96 |> my_filt()) +
    geom_ribbon(aes(ymin = ar1_fit, ymax = ar1_power,
                    linetype = NA, group = paste(detrend_type, .width)),
                show.legend = FALSE,
                fill = "orange", colour = NA, alpha = .1) +

    geom_line(aes(colour = "LOWSPEC"),
              data = specs_lowspec |> my_filt()) +
    # Lowspec ci
    geom_ribbon(aes(ymin = LOWSPEC_back,
                    ymax = LOWSPEC_99_power),
                show.legend = FALSE,
                alpha = .1, colour = NA, fill = "black",
                data = specs_lowspec |> my_filt()) +
    geom_ribbon(aes(ymin = LOWSPEC_back,
                    ymax = LOWSPEC_95_power),
                show.legend = FALSE,
                alpha = .1, colour = NA, fill = "black",
                data = specs_lowspec |> my_filt()) +
    geom_ribbon(aes(ymin = LOWSPEC_back,
                    ymax = LOWSPEC_90_power),
                show.legend = FALSE,
                alpha = .1, colour = NA, fill = "black",
                data = specs_lowspec |> my_filt()) +

    # add AR1 fit and uncertainty
    ## geom_line(aes(y = AR1_fit)) +
    ## geom_line(aes(y = AR1_95_power), alpha = .3) +

    # annotate the MTLS spectra
    geom_line(aes(colour = "MTLS"),
              data = specs_mtls |> my_filt())
#+end_src

#+attr_latex: :width \textwidth
#+name: fig:spectra-depth
#+caption: Zumaia/Sopelana spectral analysis in the depth domain. See cref:tab:detrend_types for a description of the different detrending methods. FFT = fast fourier transform, MTM = multi-taper method, MTLS = Multi-taper averaged Lomb-Scargle periodogram of unevenly spaced data.
#+RESULTS:
[[file:imgs/Zumaia-Sopelana_mtm.pdf]]

**** eha
:PROPERTIES:
:CREATED:  [2023-11-17 Fri 15:33]
:END:
Evolutive harmonics analysis from Astrochron.
#+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_eha.png :width 2400 :height 2600 :res 300
  smooth_pred |>
    ## filter(detrend_type == "value") |>
    ## filter(detrend_type == "scl") |>
    filter(detrend_type == "lin_scl_coarse") |>
    ## filter(detrend_type == "gam_det") |>
    ## filter(detrend_type == "lin_gam_det") |>
    evolutive_analysis(nest = c("proxy", "site", "detrend_type"), x = depth, y = value) |>
    mutate(width = lead(depth) - depth, .by = c(proxy, site, detrend_type, freq)) |>
    ggplot(aes(x = depth, y = freq, fill = value)) +
    facet_grid(rows = vars(proxy), cols = vars(site), scales = "free_x", space = "free_x") +
    scale_fill_viridis_c() +
    ## geom_raster() + # different pixel sizes because of different interpolation to median sample interval
    geom_tile(aes(width = width), height = .05) +
    scale_x_reverse() +
    coord_cartesian(ylim = c(0, 0.5), expand = FALSE) +
    labs(x = "Depth (m)", y = "Frequency (cycles / m)",
         ## fill = "Power"  # for output = 2
         fill = "Amplitude" # if I set output = 3
         ## fill = "Probability" # for output = 4
         ) +
    geom_hline(yintercept = my_filters$f, linetype = "dotted", colour = "white") +
    geom_hline(yintercept = my_filters$flow, linetype = "dashed") +
    geom_hline(yintercept = my_filters$fhigh, linetype = "dashed")
#+end_src

#+RESULTS:
[[file:imgs/Zumaia-Sopelana_eha.png]]

***** COMMENT Zumaia MS lin_gam_det
:PROPERTIES:
:CREATED:  [2023-12-21 Thu 09:57]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_MS_eha.png :width 2400 :height 900 :res 300
  smooth_pred |>
    filter(proxy == "MS",
           site == "Zumaia",
           detrend_type == "lin_gam_det") |>
    select(depth, value) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::eha(#sigID = TRUE,
                  win = 10, step = .5,
                  fmax = 2,
                  ydir = -1,
                  genplot = FALSE, verbose = FALSE,
                  output = 3) |> # harmonic CL
    pivot_longer(-freq) |>
    mutate(name = str_sub(name, 2, -1) |> parse_double()) |>
    rename(depth = name) |>
    ggplot(aes(x = depth, y = freq, fill = value)) +
    scale_fill_viridis_c() +
    scale_x_reverse() +
    coord_cartesian(expand = FALSE) +
    labs(y = "Frequency", x = "Depth (m)") +
    geom_raster() +
    geom_hline(yintercept = my_filters$f, linetype = "dotted", colour = "white") +
    geom_hline(yintercept = my_filters$flow, linetype = "dashed") +
    geom_hline(yintercept = my_filters$fhigh, linetype = "dashed")
#+end_src

#+name: fig:Zumaia-eha
#+attr_latex: :width \textwidth
#+caption: Zumaia MS amplitude of EHA analysis in the depth domain. Do we see a shift in sedimentation rate?
#+RESULTS:
[[file:imgs/Zumaia_MS_eha.png]]
***** COMMENT Zumaia Lstar lin_gam_det
:PROPERTIES:
:CREATED:  [2023-12-21 Thu 09:57]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_Lstar_eha.png :width 2400 :height 900 :res 300
  smooth_pred |>
    filter(proxy == "Lstar",
           site == "Zumaia",
           detrend_type == "lin_gam_det") |>
    select(depth, value) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::eha(#sigID = TRUE,
                  win = 10, step = .5,
                  fmax = 1,
                  ydir = -1,
                  genplot = FALSE, verbose = FALSE,
                  output = 3) |> # harmonic CL
    pivot_longer(-freq) |>
    mutate(name = str_sub(name, 2, -1) |> parse_double()) |>
    rename(depth = name) |>
    ggplot(aes(x = depth, y = freq, fill = value)) +
    geom_raster() +
    scale_fill_viridis_c() +
    scale_x_reverse() +
    coord_cartesian(expand = FALSE) +
    labs(y = "Frequency", x = "Depth (m)")
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_Lstar_eha.png]]

***** COMMENT Zumaia d13C lin_gam_det
:PROPERTIES:
:CREATED:  [2023-12-21 Thu 09:57]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_d13C_eha.png :width 2400 :height 900 :res 300
  smooth_pred |>
    filter(proxy == "d13C",
           site == "Zumaia",
           detrend_type == "lin_gam_det") |>
    select(depth, value) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::eha(#sigID = TRUE,
                  win = 10, step = .5,
                  fmax = 1,
                  ydir = -1,
                  genplot = FALSE, verbose = FALSE,
                  output = 3) |> # harmonic CL
    pivot_longer(-freq) |>
    mutate(name = str_sub(name, 2, -1) |> parse_double()) |>
    rename(depth = name) |>
    ggplot(aes(x = depth, y = freq, fill = value)) +
    geom_raster() +
    scale_fill_viridis_c() +
    scale_x_reverse() +
    coord_cartesian(expand = FALSE) +
    labs(y = "Frequency", x = "Depth (m)")
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_d13C_eha.png]]

**** wavelet analysis
:PROPERTIES:
:CREATED:  [2023-12-21 Thu 10:48]
:END:
I found the ~astrochron::eha~ output a bit difficult to interpret, so I'm also doing wavelet analysis using ~WaverideR~.

Though it's using base graphics, seems like Michiel figured out exactly what I would want to plot :).

The filter intervals are perhaps not so good for Sopelana?

***** Zumaia MS lin_scl_fine
:PROPERTIES:
:CREATED:  [2023-12-21 Thu 11:12]
:END:
:LOGBOOK:
- Note taken on [2024-01-11 Thu 11:57] \\
  checked a lot of different combinations to see if I also see the shift in sedrate they describe in [cite:@Batenburg2014]
  I don't, really! After my linear detrending in fine chunks.
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_MS_wavelet.png :width 2400 :height 1200 :res 300
  ## smooth_wavelet <-
    smooth_pred |>
    ## filter(detrend_type == "value") |>
    ## filter(detrend_type == "scl") |>
    ## filter(detrend_type == "lin_scl_rw") |>
    filter(detrend_type == "lin_scl_fine") |>
    ## filter(detrend_type == "lin_scl_coarse") |>
    ## filter(detrend_type == "gam_scl") |>
    ## filter(detrend_type == "lin_gam_det") |>
    filter(proxy == "MS") |>
    ## filter(proxy == "Lstar") |>
    ## filter(proxy == "d13C") |>
    filter(site == "Zumaia") |>
    ## filter(site == "Sopelana") |>
    select(depth, value) |>
    WaverideR::analyze_wavelet(lowerPeriod = 2,
                               upperPeriod = 30,
                               omega_nr = 10,
                               ## verbose = TRUE
                               ) |>
      WaverideR::plot_wavelet(plot_dir = FALSE,
                              palette_name = "inferno",
                            siglvl = .95,
                            dev_new = FALSE,
                            add_avg = TRUE,
                            add_MTM = TRUE,
                            add_MTM_peaks = TRUE,
                            add_abline_h =
                              c(

                                my_filters$p,
                                1 / my_filters$flow, 1 / my_filters$fhigh

                                ## bat_filters |>
                                ## filter(site == "Zumaia", proxy == "Lstar") |>
                                ## select(center,plow,phigh) |>
                                ## as_vector()

                            ))
  # wanted to customize this but it has already moved on to another subplot by the end
  ## abline(h = my_filters$p, colour = "white")
  ## abline(h = c(1 / my_filters$flow, 1 / my_filters$fhigh), colour = "gray")

#+end_src

#+RESULTS:
[[file:imgs/Zumaia-Sopelana_MS_wavelet.png]]

***** Zumaia Lstar lin_scl_fine
:PROPERTIES:
:CREATED:  [2023-12-21 Thu 11:12]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_Lstar_wavelet.png :width 2400 :height 1200 :res 300
  ## smooth_wavelet <-
    smooth_pred |>
    ## filter(detrend_type == "value") |>
    ## filter(detrend_type == "scl") |>
    ## filter(detrend_type == "lin_scl_rw") |>
    filter(detrend_type == "lin_scl_fine") |>
    ## filter(detrend_type == "lin_scl_coarse") |>
    ## filter(detrend_type == "gam_scl") |>
    ## filter(detrend_type == "lin_gam_det") |>
    ## filter(proxy == "MS") |>
    filter(proxy == "Lstar") |>
    ## filter(proxy == "d13C") |>
    filter(site == "Zumaia") |>
    ## filter(site == "Sopelana") |>
    select(depth, value) |>
    WaverideR::analyze_wavelet(lowerPeriod = 2,
                               upperPeriod = 30,
                               omega_nr = 10,
                               ## verbose = TRUE
                               ) |>
      WaverideR::plot_wavelet(plot_dir = FALSE,
                              palette_name = "inferno",
                            siglvl = .95,
                            dev_new = FALSE,
                            add_avg = TRUE,
                            add_MTM = TRUE,
                            add_MTM_peaks = TRUE,
                            add_abline_h =
                              c(

                                my_filters$p,
                                1 / my_filters$flow, 1 / my_filters$fhigh

                                ## bat_filters |>
                                ## filter(site == "Zumaia", proxy == "Lstar") |>
                                ## select(center,plow,phigh) |>
                                ## as_vector()

                            ))
  # wanted to customize this but it has already moved on to another subplot by the end
  ## abline(h = my_filters$p, colour = "white")
  ## abline(h = c(1 / my_filters$flow, 1 / my_filters$fhigh), colour = "gray")

#+end_src

#+RESULTS:
[[file:imgs/Zumaia-Sopelana_Lstar_wavelet.png]]

***** Zumaia d13C lin_scl_fine
:PROPERTIES:
:CREATED:  [2023-12-21 Thu 11:12]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_d13C_wavelet.png :width 2400 :height 1200 :res 300
  ## smooth_wavelet <-
    smooth_pred |>
    ## filter(detrend_type == "value") |>
    ## filter(detrend_type == "scl") |>
    ## filter(detrend_type == "lin_scl_rw") |>
    filter(detrend_type == "lin_scl_fine") |>
    ## filter(detrend_type == "lin_scl_coarse") |>
    ## filter(detrend_type == "gam_scl") |>
    ## filter(detrend_type == "lin_gam_det") |>
    ## filter(proxy == "MS") |>
    ## filter(proxy == "Lstar") |>
    filter(proxy == "d13C") |>
    filter(site == "Zumaia") |>
    ## filter(site == "Sopelana") |>
    select(depth, value) |>
    WaverideR::analyze_wavelet(lowerPeriod = 2,
                               upperPeriod = 30,
                               omega_nr = 10,
                               ## verbose = TRUE
                               ) |>
      WaverideR::plot_wavelet(plot_dir = FALSE,
                              palette_name = "inferno",
                            siglvl = .95,
                            dev_new = FALSE,
                            add_avg = TRUE,
                            add_MTM = TRUE,
                            add_MTM_peaks = TRUE,
                            add_abline_h =
                              c(

                                my_filters$p,
                                1 / my_filters$flow, 1 / my_filters$fhigh

                                ## bat_filters |>
                                ## filter(site == "Zumaia", proxy == "Lstar") |>
                                ## select(center,plow,phigh) |>
                                ## as_vector()

                            ))
  # wanted to customize this but it has already moved on to another subplot by the end
  ## abline(h = my_filters$p, colour = "white")
  ## abline(h = c(1 / my_filters$flow, 1 / my_filters$fhigh), colour = "gray")

#+end_src

#+RESULTS:
[[file:imgs/Zumaia-Sopelana_d13C_wavelet.png]]

***** Sopelana MS lin_scl_fine
:PROPERTIES:
:CREATED:  [2023-12-21 Thu 11:12]
:END:
#+begin_src R :results output graphics file :file imgs/Sopelana_MS_wavelet.png :width 2400 :height 1200 :res 300
  ## smooth_wavelet <-
    smooth_pred |>
    ## filter(detrend_type == "value") |>
    ## filter(detrend_type == "scl") |>
    ## filter(detrend_type == "lin_scl_rw") |>
    filter(detrend_type == "lin_scl_fine") |>
    ## filter(detrend_type == "lin_scl_coarse") |>
    ## filter(detrend_type == "gam_scl") |>
    ## filter(detrend_type == "lin_gam_det") |>
    filter(proxy == "MS") |>
    ## filter(proxy == "Lstar") |>
    ## filter(proxy == "d13C") |>
    ## filter(site == "Zumaia") |>
    filter(site == "Sopelana") |>
    select(depth, value) |>
    WaverideR::analyze_wavelet(lowerPeriod = 2,
                               upperPeriod = 30,
                               omega_nr = 10,
                               ## verbose = TRUE
                               ) |>
      WaverideR::plot_wavelet(plot_dir = FALSE,
                              palette_name = "inferno",
                            siglvl = .95,
                            dev_new = FALSE,
                            add_avg = TRUE,
                            add_MTM = TRUE,
                            add_MTM_peaks = TRUE,
                            add_abline_h =
                              c(

                                my_filters$p,
                                1 / my_filters$flow, 1 / my_filters$fhigh

                                ## bat_filters |>
                                ## filter(site == "Zumaia", proxy == "Lstar") |>
                                ## select(center,plow,phigh) |>
                                ## as_vector()

                            ))
  # wanted to customize this but it has already moved on to another subplot by the end
  ## abline(h = my_filters$p, colour = "white")
  ## abline(h = c(1 / my_filters$flow, 1 / my_filters$fhigh), colour = "gray")


#+end_src

#+RESULTS:
[[file:imgs/Sopelana_MS_wavelet.png]]

***** Sopelana Lstar lin_scl_fine
:PROPERTIES:
:CREATED:  [2023-12-21 Thu 11:12]
:END:
#+begin_src R :results output graphics file :file imgs/Sopelana_Lstar_wavelet.png :width 2400 :height 1200 :res 300
  ## smooth_wavelet <-
    smooth_pred |>
    ## filter(detrend_type == "value") |>
    ## filter(detrend_type == "scl") |>
    ## filter(detrend_type == "lin_scl_rw") |>
    filter(detrend_type == "lin_scl_fine") |>
    ## filter(detrend_type == "lin_scl_coarse") |>
    ## filter(detrend_type == "gam_scl") |>
    ## filter(detrend_type == "lin_gam_det") |>
    ## filter(proxy == "MS") |>
    filter(proxy == "Lstar") |>
    ## filter(proxy == "d13C") |>
    ## filter(site == "Zumaia") |>
    filter(site == "Sopelana") |>
    select(depth, value) |>
    WaverideR::analyze_wavelet(lowerPeriod = 2,
                               upperPeriod = 30,
                               omega_nr = 10,
                               ## verbose = TRUE
                               ) |>
      WaverideR::plot_wavelet(plot_dir = FALSE,
                              palette_name = "inferno",
                            siglvl = .95,
                            dev_new = FALSE,
                            add_avg = TRUE,
                            add_MTM = TRUE,
                            add_MTM_peaks = TRUE,
                            add_abline_h =
                              c(

                                my_filters$p,
                                1 / my_filters$flow, 1 / my_filters$fhigh

                                ## bat_filters |>
                                ## filter(site == "Zumaia", proxy == "Lstar") |>
                                ## select(center,plow,phigh) |>
                                ## as_vector()

                            ))
  # wanted to customize this but it has already moved on to another subplot by the end
  ## abline(h = my_filters$p, colour = "white")
  ## abline(h = c(1 / my_filters$flow, 1 / my_filters$fhigh), colour = "gray")
#+end_src

#+RESULTS:
[[file:imgs/Sopelana_Lstar_wavelet.png]]

**** Bandpass Filtering
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 10:56]
:END:
#+begin_src R
  filts <- smooth_pred |>
    ## nested_bandpass_filter(frequencies = my_filters, x = depth, y = value,
                    ## nest = c("proxy", "site", "detrend_type", "depth_chunk"))
    nest(.by = all_of(c("proxy", "site", "detrend_type", "depth_chunk"))) |>
    mutate(target = list(c("405 kyr", "100 kyr"))) |>
    unnest(target) |>
    left_join(my_filters) |>
    dplyr::mutate(bp = purrr::pmap(.l = list(data,
                                             target,
                                             flow,
                                             fhigh),
                                  .f = \(d, tg, fl, fh) d |>
                                               bandpass_filter(
                                                 frequencies = tibble(target = tg, flow = fl, fhigh = fh),
                                                 x = depth, y = value,
                                                 add_depth = FALSE))) |>
    select(-target, -flow, -fhigh) |> # prevent name clash
    unnest(bp) |>
    select(-data)
#+end_src

#+RESULTS:
: Joining with `by = join_by(proxy, site, depth_chunk, target)`

**** Bandpass Filtering the short ecc components
:PROPERTIES:
:CREATED:  [2024-02-09 Fri 14:27]
:END:
#+begin_src R
  filts_short_ecc <- smooth_pred |>
    nest(.by = all_of(c("proxy", "site", "detrend_type", "depth_chunk"))) |>
    mutate(target = list(tribble( ~ target, ~ flow, ~ fhigh,
                                 "95 kyr", 0.187, 0.248,
                                 "110 kyr", 0.262, 0.328))) |>
    unnest(target) |>
    dplyr::mutate(bp = purrr::pmap(.l = list(data,
                                             target,
                                             flow,
                                             fhigh),
                                  .f = \(d, tg, fl, fh) d |>
                                               bandpass_filter(
                                                 frequencies = tibble(target = tg, flow = fl, fhigh = fh),
                                                 x = depth, y = value,
                                                 add_depth = FALSE))) |>
    select(-target, -flow, -fhigh) |> # prevent name clash
    unnest(bp) |>
    select(-data)
#+end_src

#+RESULTS:

**** make plot of short ecc independent filters
:PROPERTIES:
:CREATED:  [2024-02-09 Fri 14:34]
:END:

#+begin_src R :results output graphics file :file imgs/Zumaia_Sopelana_records_and_filters_depth_short_ecc.png :width 2700 :height 1500 :res 300
  my_filt <- \(d) d |>
                    ## filter(detrend_type != "value") |>
                    filter(detrend_type == "lin_scl_fine") |>
                    filter(depth_chunk == "depth < 109.26") |>
                    ## filter(depth_chunk != "full record") |>
                    filter(proxy == "MS") |>
                    filter(site == "Zumaia")

  smooth_pred |>
    my_filt() |>
    ggplot(aes(x = depth, y = value, colour = target)) +
    theme(legend.pos = c(.9, .9)) +
    facet_grid(rows = vars(proxy, depth_chunk),
               scales = "free", space = "free_x") +
    scale_x_reverse(breaks = seq(0, 200, 10),
                    minor_breaks = seq(0, 200, 5)) +
    labs(x = "Depth (m)", y = "Normalized proxy") +
    geom_line(aes(group = paste(detrend_type, site, depth_chunk)),
              colour = "black",
              alpha = .1) +
    geom_line(aes(y = filter,
                  group = paste(detrend_type, site, target, depth_chunk)),
              data = filts_short_ecc |> my_filt()) +
    ## geom_line(aes(y = `95 kyr` + `110 kyr`,
    ##               colour = "combined 95 and 110 filter"),
    ##           data = filts_short_ecc |>
    ##             my_filt() |>
    ##             select(proxy, site, detrend_type, depth_chunk, depth, filter, target) |>
    ##             pivot_wider(names_from="target", values_from="filter")
    ##           ) +
    ## geom_line(aes(y = filter,
    ##               group = paste(detrend_type, site, target, depth_chunk),
    ##               colour = "full-width 100 kyr filter"),
    ##           colour = "black",
    ##           data = filts |> my_filt() |> filter(target == "100 kyr")) +
    geom_vline(aes(xintercept = strat_bot), colour = "gray",
               data = agem_simple |> filter(strat_bot < 120))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_Sopelana_records_and_filters_depth_short_ecc.png]]

**** [#B] do multiple-hypothesis testing corrections
:PROPERTIES:
:CREATED:  [2024-02-09 Fri 15:12]
:END:
:LOGBOOK:
- Note taken on [2024-02-12 Mon 15:57] \\
  showed it to Frits
- Note taken on [2024-02-09 Fri 15:31] \\
  just finished this, show to Frits on monday!
:END:

#+begin_src R
  # limit to one single piece with similar sedrates
  dat <- smooth_pred |>
    filter(proxy == "MS",
           site == "Zumaia",
           detrend_type == "lin_scl_fine",
           depth_chunk == "depth < 109.26")

  lin <- dat |>
    select(depth, value) |>
    astrochron::linterp()

  mmm <- lin |>
    astrochron::mtm(output=1)

  ls <- lin |>
    astrochron::lowspec(output = 1)

  bonf <- mmm |>
    astrochron::confAdjust(dt = 0.10667, npts = nrow(lin),
                           ## flow = c(0.0375, 0.15),
                           ## fhigh = c(0.0875, 0.35)
                           )

  mult <- mmm |>
    astrochron::multiTest(## flow = c(0.0375, 0.15),
                          ##  fhigh = c(0.0875, 0.35)
                          ) # targeting long and short ecc


  pl_mtm <- mmm |>
    ## filter(Frequency < 0.5) |>
    ggplot(aes(x = Frequency, y = Power)) +

    geom_ribbon(aes(y = LOWSPEC_back, ymin = LOWSPEC_back,
                    ymax = LOWSPEC_90_power, fill = "LOWSPEC"),
                alpha = .1, colour = NA, data = ls) +
    geom_ribbon(aes(y = LOWSPEC_back, ymin = LOWSPEC_back,
                    ymax = LOWSPEC_95_power, fill = "LOWSPEC"),
                alpha = .1, colour = NA, data = ls) +
    geom_ribbon(aes(y = LOWSPEC_back, ymin = LOWSPEC_back,
                    ymax = LOWSPEC_99_power),
                fill = "black", alpha = .1, colour = NA, data = ls) +
    geom_line(aes(y = Prewhite_power), data = ls) +

    geom_ribbon(aes(y = AR1_fit, ymin = AR1_fit, ymax = AR1_90_power),
                fill = "black", alpha = .1, colour = NA) +
    geom_ribbon(aes(y = AR1_fit, ymin = AR1_fit, ymax = AR1_95_power),
                fill = "black", alpha = .1, colour = NA) +
    geom_ribbon(aes(y = AR1_fit, ymin = AR1_fit, ymax = AR1_99_power),
                fill = "black", alpha = .1, colour = NA) +
    geom_line()  +

    geom_ribbon(aes(y = Background_fit, ymin = Background_fit, ymax = CL90_power),
                fill = "red", alpha = .1, colour = NA, data = bonf) +
    geom_ribbon(aes(y = Background_fit, ymin = Background_fit, ymax = CL95_power),
                fill = "red", alpha = .1, colour = NA, data = bonf) +
    geom_ribbon(aes(y = Background_fit, ymin = Background_fit, ymax = CL99_power),
                fill = "red", alpha = .1, colour = NA, data = bonf)
    geom_line(colour = "red", data = bonf)

  pl_mult <- mult |>
    as_tibble() |>
    pivot_longer(`Uncorrected p-value`:Bonferroni) |>
    ggplot(aes(x = Frequency, y = value, colour = name)) +
    geom_hline(yintercept = 1 - c(0.99, 0.95, 0.9),
               alpha = .2) +
    geom_line() +
    # just to check: the uncorrected p-value is the same as the
    # mtm's 1 - (AR1_CL / 100)
    geom_line(aes(y = 1-(AR1_CL / 100)),
              colour = "black",
              data = mmm |> filter(Frequency < 0.35))
    # no idea if below is correct


  pl_mtm / pl_mult + plot_layout(axes = "collect")


  # there's also this function
  tb <- astrochron::testBackground(method="mtmAR1")
#+end_src

**** get 405 kyr minima from bandpass filters
:PROPERTIES:
:CREATED:  [2023-11-30 Thu 10:46]
:END:
#+begin_src R
  rec_peaks <- filts |>
      tidylog::filter(target == "405 kyr") |>
      mutate(filter = -filter) |> # we want MINIMA rather than maxima
      nest(.by = c(proxy, site, detrend_type)) |>
      mutate(pk = map(data, ~ .x |>
                              select(depth, filter) |>
                              astrochron::peak(genplot = FALSE, verbose = FALSE) |>
                              as_tibble() |>
                              select(depth = Location, peak_value = Peak_Value))) |>
      unnest(pk) |>
    select(-data) |>
    mutate(peak_value = -peak_value) # convert back to original value
#+end_src

#+RESULTS:
: filter: removed 59,810 rows (50%), 59,810 rows remaining

**** COMMENT hilbert transform of the precession bp filter
:PROPERTIES:
:CREATED:  [2023-09-27 Wed 10:54]
:END:
#+begin_src R :exports none
  hb_prec <- filts |>
    filter(target == "prec") |>
    nest(.by = c(site, proxy, detrend_type, depth_chunk)) |>
    mutate(hb = map(data, \(d) d |>
                               select(depth, filter) |>
                               astrochron::hilbert(genplot = FALSE, verbose = FALSE))) |>
    unnest(hb) |>
    select(-data)
#+end_src

#+RESULTS:

[2023-11-27 Mon 19:45]
Richard says that the Hilbert transform is useful for visual inspection, but numerically it is very sensitive and probably doesn't reflect the real amplitude modulation signal very well.

**** make plot of records with filters
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 10:57]
:END:
The highpass filter gets rid of a LOT of the signal in all the filters *for d13C*.

#+begin_src R :results output graphics file :file imgs/Zumaia_Sopelana_records_and_filters_depth.png :width 2700 :height 2400 :res 300
  smooth_pred |>
    filter(detrend_type != "value") |>
    ggplot(aes(x = depth, y = value, colour = detrend_type)) +
    facet_grid(rows = vars(proxy, depth_chunk),
               scales = "free", space = "free_x") +
    geom_line(aes(group = paste(detrend_type, site, depth_chunk)), alpha = .1) +
    geom_line(aes(y = filter + as.integer(as.factor(target)),
                  group = paste(detrend_type, site, target, depth_chunk)),
              data = filts |> filter(detrend_type != "value")) +
    geom_vline(aes(xintercept = strat_bot), colour = "gray", data = agem_simple) +
    ## geom_line(aes(y = envelope + 3.5, group = paste(detrend_type, site)),
    ##           data = hb_prec |> filter(detrend_type != "value")) +
    geom_point(aes(y = pk - 2),
               size = 3,
               data = filts |>
                 filter(target == "405 kyr") |>
                 filter(detrend_type != "value") |>
                 nest(.by = c(proxy, site, detrend_type, flow, fhigh)) |>
                 mutate(pk = map(data, \(d) d |>
                                            select(depth, filter) |>
                                            mutate(filter = -filter) |> # we want minima rather than maxima
                                            astrochron::peak(genplot = FALSE, verbose = FALSE))) |>
                 unnest(pk) |>
                 rename(depth = Location, pk = Peak_Value) |>
                 mutate(pk = -pk)) +
    scale_x_reverse(breaks = seq(0, 200, 10),
                    minor_breaks = seq(0, 200, 5)) +
    labs(x = "Depth (m)", y = "Normalized proxy",
         ## title = "Zumaia raw proxy record filters"
         ## title = "Zumaia fancy detrended proxy record filters"
         )
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_Sopelana_records_and_filters_depth.png]]

[2024-01-11 Thu 16:13]
Oohh the coarse linear detrend leaves more power in the 405 kyr filter!

#+attr_latex: :width \linewidth
#+caption: *Zumaia/Sopelana detrended records (colour represents the way in which the detrending was done, see cref:tab:detrend_types) and various bandpass filters in the depth domain.* Top lines represent the Hilbert transform of the precession filter for comparison to the 405 and 100 kyr direct filters. Dots represent minima in the 405 kyr filter, which should approximately correspond to the vertical black lines (minima identified in the field) for MS, with maxima coinciding with the black lines for the d13C and Lstar records.
#+RESULTS:
[[file:imgs/Zumaia_Sopelana_records_and_filters_depth.png]]

**** construct an eccentricity curve from the filters in the depth domain
:PROPERTIES:
:CREATED:  [2023-09-27 Wed 10:50]
:END:
:LOGBOOK:
- Note taken on [2023-12-21 Thu 16:51] \\
  should get this working with new ~construct_eccentricity~ function
:END:
We normalize the filtered record and combine them in a few different proportions (for now 1:1, 0.5:1, and 1:0.5) using both a filtering approach (default) and a hilbert transform of the precession-filtered record. Furthermore we set the phase relationship to -1 for the d13C and Lstar proxies and to +1 for the MS.

#+begin_src R :results none
  data_ecc <- filts |>
    ## select(-p, -f, -range, -flow, -fhigh, -ref) |>
    ## pivot_wider(id_cols = c(proxy, site, detrend_type, depth, value),
    ##             names_from = target, values_from = filter) |>
    ## tidylog::left_join(hb_prec) |> # we no longer do the hilbert transfrom analysis
    mutate(
      fracs = list(tribble( ~ comb, ~ s405, ~ s100,
                          "1:1", 1, 1,
                          ## "0.5:1", 0.5, 1,
                          ## "1:0.5", 1, 0.5
                          )),
      # the phase relationships for the different proxies
      sign_405 = case_when(proxy == "d13C" ~ -1,
                           proxy == "Lstar" ~ -1,
                           proxy == "MS" ~ 1),
      sign_100 = case_when(proxy == "d13C" ~ -1,
                           proxy == "Lstar" ~ -1,
                           proxy == "MS" ~ 1)) |>
    unnest(fracs) |>
    nest(.by = c(proxy, site, detrend_type, comb, depth_chunk, s405, s100, sign_405, sign_100)) |>
    mutate(ecc = pmap(list(data, s405, s100, sign_405, sign_100),
                      \(d, s405, s100, sign405, sign100)
                      d |>
                      construct_eccentricity(sign = sign405, weights = c(s405, s100),
                                             id_cols = c(depth, value), f = filter))) |>
    select(-data) |>
    unnest(ecc)
    ## mutate(filter = scale(sign_405 * s405 * `405 kyr` + sign_100 * s100 * `100 kyr`)[, 1],
    ##        hilbert = scale(sign_405 * s405 * `405 kyr` + sign_100 * s100 * envelope)[, 1],
    ##        # we scale the two sites at the same level
    ##        .by = c(site, proxy, detrend_type, comb)) |>
    ## pivot_longer(c(filter, hilbert),
    ##              names_to = "filt_env",
    ##              values_to = "ecc") |>
    ## arrange(rev(site), rev(proxy), filt_env, comb, depth)
#+end_src

**** plot extracted eccentricity curve
:PROPERTIES:
:CREATED:  [2023-09-27 Wed 18:51]
:END:
We plot all the different ways in which we have constructed an `eccentricity' record against depth, including the 405 kyr minima that were identified in the field.
See [[cref:fig:record-construct]].

#+begin_src R :results output graphics file :file imgs/Zumaia_ecc_depth.png :width 2400 :height 2000 :res 300
  data_ecc |>
    ## filter(site == "Sopelana") |>
    mutate(scaled_405 = scale(`405 kyr`)[, 1], .by = c(proxy, site, depth_chunk, detrend_type)) |>
    ggplot(aes(x = depth, y = ecc,
               linetype = comb,
               group = paste(site, comb, depth_chunk, detrend_type## , filt_env
                             ),
               colour = detrend_type)) +
    facet_grid(rows = vars(proxy, depth_chunk)) +
    theme(strip.text.y = element_text(size = 7)) +
    scale_x_reverse(breaks = seq(0, 200, 10), minor_breaks = seq(0, 200, 2)) +
    labs(x = "Depth (m)", y = "Normalized scaled combination of filters",
         colour = "Detrend method") +
    ## geom_line(aes(y = `405 kyr`, colour = "405 kyr")) +
    ## geom_line(aes(y = `100 kyr`, colour = "100 kyr")) +
    ## geom_line(aes(y = prec, colour = "prec")) +
    ## geom_line(aes(y = envelope, colour = "envelope")) +
    geom_vline(aes(xintercept = strat_bot, colour = site), alpha = .2, data = agem_simple) +
    geom_line(aes(y = scaled_405)) +
    geom_line()
#+end_src

#+attr_latex: :width \textwidth
#+name: fig:record-construct
#+caption: Zumaia/Sopelana artificial combinations of 405 kyr and 100 kyr bandpass filtered/hilbert-transformed records in various combinations.
#+RESULTS:
[[file:imgs/Zumaia_ecc_depth.png]]

**** [#A] add the orbital solution to the data and calculate the RMSD
:PROPERTIES:
:CREATED:  [2023-09-27 Wed 11:20]
:END:
***** some old notes
We filter out only the 1:0.5 filtered records (because they consistently gave the lowest RMSD scores and otherwise my computer often froze).

There are a few parameters we can vary to convert our depth record to a record against time.

First we create a list of potential K/T ages, ranging from 65.92 Ma to 66.02 Ma in increments of 20 kyr, which corresponds to the range of K/T ages for all astronomical solutions in [cite:@ZeebeLourens2022EPSL] table 4.

Second, we look at potential phase lag between the proxy record and the astronomical solution, because in [cite:@Batenburg2012] they describe a lag of 2--3 precession cycles for the d13C record. So we let the lag vary between 0 and 65 kyr in increments of 5 kyr for d13C, and between 0 and 22 kyr in increments of 5 kyr for the remainder of the proxies.
*For now I've disabled this analysis!*

Third, we vary the sedimentation rate for the whole record at once to determine the best fit. In [cite:@Batenburg2014] they describe that the full Zumaia + Sopelana record contains 13 405 kyr cycles spanning 183 m. Thus, we let the inverted sedimentation rate vary between 22  kyr/m (what if there were only 11 cycles?) and 31 kyr/m (what if there were instead 14 cycles?).
If we only look at the Zumaia site, it would be 9 405 kyr minima in 135 m, so 27 kyr / m. If we calculate these inverted sedimentation rates for each cycle in the age model, assuming a fixed age difference of 405 kyr between the minima, we arrive at rates between 20.25 kyr/m and 36.8 kyr/m.
This indicates that this approach of fitting only a single sedimentation rate to the whole record is problematic. See below for a more elegant solution.

Which detrend_type is best?
- Hmm for Zumaia MS, ~lin_scl~ and ~lin_gam_det~ are best  if comb 1:0.5 hilbert!
- For Zumaia Lstar, ~lin_scl~, ~gam_det~, and ~lin_gam_det~ are about equally good with 1:0.5 filter!
- For Zumaia d13C, ~lin_gam_det~ and ~lin_scl~ are identical at 1:0.5 filter.
- For almost all 1:0.5 combs, filter is better than hilbert except for Zumaia d13C scl, so we can safely filter out only those comb/filt_env's.
***** calculate diffs and RMSD
first generate estimates of sedimentation rate based on the number of long ecc cycles in the depth range
#+begin_src R
  ## kpg_age <- 65970 # age taken from Batenburg et al., 2014
  ## tau <- (13 * 405) / 183 # conversion from depth to time,
  # 13 405 kyr cycles in 183 m of sediment, = 28.77 kyr/m
  # if we multiply the metres by this number you get kyr out.
  ## proxy_lag <- 2--3 precessional cycles, 44--65 kyr (Batenburg et al., 2012)

  ## miscount <- c(.5, .1, 0.05) # this still runs!
  ## miscount <- c(.5, .4, .3, .2, .1) # this was too large
  ## miscount <- c(.3, .2, .1) # .3 is way too large
  ## miscount <- c(.2, .15, .1, .05)
  ## miscount <- c(-miscount, 0, rev(miscount))
  ## sedrange <- seq(1.5, 0.5, -0.5) * 1e-2 # works, but coarse
  sedrange <- seq(0, 1, 0.1)[-1] * 1e-2 # change sedrate by ±1 cm
  sedrange <- c(-rev(sedrange), 0, sedrange)
  sedrange

  age_offsets <- seq(-200, +200, 40)
  age_offsets

  # first set them both to 0 and hone in on the correct number of cycles
  sedrange <- 0
  age_offsets <- 0

  diffs <-
    data_ecc |>
    # filter to limit options a little
    ## tidylog::filter(detrend_type == "lin_gam_det") |>
    tidylog::filter(detrend_type == "lin_scl_fine") |>
    ## tidylog::filter(comb == "0.5:1", filt_env == "filter") |>
    tidylog::filter(comb == "1:1") |>
    ## tidylog::filter(filt_env == "filter") |>
    ## tidylog::filter(site == "Zumaia") |>
    ## tidylog::filter(proxy == "MS") |>
    tidylog::filter(proxy == "Lstar") |>
    ## tidylog::filter(depth_chunk == "depth < 109.26") |>
    select(-`405 kyr`, -`100 kyr`) |>
    ## mutate(proxy_lag = case_when(
    ##          proxy == "d13C" ~ list(seq(44, 65, 5)), # 44 to 65 kyr (Batenburg et al., 2012)
    ##          proxy == "MS" ~ list(seq(0, 22, 5)),
    ##          proxy == "Lstar" ~ list(seq(0, 22, 5)),
    ##          TRUE ~ list(0.))) |>
    ## unnest(cols = c(proxy_lag)) |>
    # a single linear sedimentation rate, could well have varied by quite a bit!
    mutate(depth_range = diff(range(depth)),
           .by = c(proxy, site, depth_chunk)) |>
    mutate(num_cycles =
             # what if the Batenburg 2014 tuning is off by 3 405 kyr cycles?
             ## (10 * 405) / 183, (16 * 405) / 183,
             ## that's from 22.13 to 35.41
             ## 22, 36,
             # what if the Batenburg 2014 tuning is off by one 405 kyr cycle?
             ## c((12 * 405) / 183, (14 * 405) / 183),
             ## that's from 26.56 to 30.98
             ## 26, 31,
             ## 22,
             ## 24, # off by 2 cycles, (11 * 405) / 183 = 24.344
             ## 31, # but 26 keeps getting the best score, so expand that side
             # we could also do it based on the sedimentation rate in cm/kyr,
             # what are reasonable sedimentation rates here?
             ## 1 / 8 * 100, 1 / 2 * 100, # 2 to 8 cm / kyr?
             case_when(
               site == "Zumaia" & depth_chunk == "depth < 109.26" ~ 7,
               site == "Zumaia" & depth_chunk == "depth >= 109.26" ~ 2,
               site == "Zumaia" & depth_chunk == "full record" ~ 8,
               site == "Sopelana" ~ 3.35,
               )
             ## length.out = 12 # this is to limit the total number of simulations
             ## )
             ) |>
    ## mutate(count_error = list(miscount)) |>
    ## unnest(count_error) |>
    ## mutate(inv_sedrate = (num_cycles * 405) / depth_range) |>
    mutate(m_per_kyr = depth_range / (num_cycles * 405)) |> # in m/kyr
    mutate(sed_error = list(sedrange)) |>
    unnest(sed_error) |>
    mutate(sedrate = m_per_kyr + sed_error) |>
    ## distinct(site, depth_chunk, inv_sedrate) # check if it worked
    mutate(floating_age = depth / sedrate) |>
    mutate(age_offset = list(age_offsets)) |>
    unnest(cols = c(age_offset)) |>
    mutate(kpg_age = 65.9e3 + age_offset) |>
    mutate(age = kpg_age + floating_age) %>%
    # It kept crashing if I didn't filter out enough, this ensures this doesn't happen
    assertr::verify(nrow(.) <= 1.1005e6) |> # this still worked last time!
    # add target orbital solutions
    mutate(sol = list(target_astronomical_solutions)) |>
    unnest(cols = c(sol)) |>
    mutate(ecc_sln = case_when(
             sol == "ZB18a" ~ approx(sln$age, sln$scl,
                                     xout = age)$y,
             sol == "ZB20a" ~ approx(sln2$age, sln2$scl,
                                     xout = age)$y,
             sol == "ZB20b" ~ approx(sln2b$age, sln2b$scl,
                                     xout = age)$y,
             sol == "ZB20c" ~ approx(sln2c$age, sln2c$scl,
                                     xout = age)$y,
             sol == "ZB20d" ~ approx(sln2d$age, sln2d$scl,
                                     xout = age)$y,
             ## sol == "La11" ~ approx(sln3$age, sln3$scl,
             ##                         xout = age)$y,
             sol == "La10b" ~ approx(sln4$age, sln4$scl,
                                     xout = age)$y,
             sol == "La10c" ~ approx(sln5$age, sln5$scl,
                                     xout = age)$y,
             TRUE ~ NA_real_)) |>
    mutate(SD = (ecc_sln - ecc)^2)

  msd <- diffs |>
    summarize(RMSD = sqrt(mean(SD)),
              .by = c(proxy, site, detrend_type,
                      comb, #filt_env,
                      depth_chunk,
                      kpg_age, ## proxy_lag,
                      m_per_kyr,
                      sedrate, sed_error, age_offset,
                      sol)) |>
    arrange(RMSD)
#+end_src

#+RESULTS:
:  [1] -0.010 -0.009 -0.008 -0.007 -0.006 -0.005 -0.004 -0.003 -0.002 -0.001  0.000  0.001  0.002  0.003  0.004  0.005  0.006  0.007  0.008  0.009  0.010
:  [1] -200 -160 -120  -80  -40    0   40   80  120  160  200
: filter: removed 44,838 rows (86%), 7,486 rows remaining
: filter: no rows removed
: filter: removed 4,133 rows (55%), 3,353 rows remaining
***** same but now with simple range of sedrates
:PROPERTIES:
:CREATED:  [2024-02-06 Tue 11:34]
:END:
#+begin_src R :eval never
  diffs <-
    data_ecc |>
    # filter to limit options a little
    ## tidylog::filter(detrend_type == "lin_gam_det") |>
    tidylog::filter(detrend_type == "lin_scl_fine") |>
    ## tidylog::filter(comb == "0.5:1", filt_env == "filter") |>
    tidylog::filter(comb == "1:1") |>
    ## tidylog::filter(filt_env == "filter") |>
    ## tidylog::filter(site == "Zumaia") |>
    ## tidylog::filter(proxy == "MS") |>
    ## tidylog::filter(proxy == "Lstar") |>
    select(-`405 kyr`, -`100 kyr`) |>
    # a single linear sedimentation rate, could well have varied by quite a bit!
    mutate(sedrate = list(
             case_when(site == "Sopelana" ~ seq(0.025, 0.032, length.out = )
                         )seq(0.01, 0.05, 0.01))) |>
    unnest(cols = c(sedrate)) |>
    mutate(floating_age = depth / sedrate) |>
    mutate(age_offset = list(seq(-200, +200, 20))) |>
    unnest(cols = c(age_offset)) |>
    mutate(kpg_age = 65.9e3 + age_offset) |>
    mutate(age = kpg_age + floating_age) %>%
    # It kept crashing if I didn't filter out enough, this ensures this doesn't happen
    assertr::verify(nrow(.) <= 1.1005e6) |> # this still worked last time!
    # add target orbital solutions
    mutate(sol = list(target_astronomical_solutions)) |>
    unnest(cols = c(sol)) |>
    mutate(ecc_sln = case_when(
             sol == "ZB18a" ~ approx(sln$age, sln$scl,
                                     xout = age)$y,
             sol == "ZB20a" ~ approx(sln2$age, sln2$scl,
                                     xout = age)$y,
             sol == "ZB20b" ~ approx(sln2b$age, sln2b$scl,
                                     xout = age)$y,
             sol == "ZB20c" ~ approx(sln2c$age, sln2c$scl,
                                     xout = age)$y,
             sol == "ZB20d" ~ approx(sln2d$age, sln2d$scl,
                                     xout = age)$y,
             ## sol == "La11" ~ approx(sln3$age, sln3$scl,
             ##                         xout = age)$y,
             sol == "La10b" ~ approx(sln4$age, sln4$scl,
                                     xout = age)$y,
             sol == "La10c" ~ approx(sln5$age, sln5$scl,
                                     xout = age)$y,
             TRUE ~ NA_real_)) |>
    mutate(SD = (ecc_sln - ecc)^2)

  msd <- diffs |>
    summarize(RMSD = sqrt(mean(SD)),
              .by = c(proxy, site, detrend_type,
                      comb, #filt_env,
                      depth_chunk,
                      kpg_age, ## proxy_lag,
                      sedrate, age_offset,
                      sol)) |>
    arrange(RMSD)
#+end_src

#+RESULTS:
: Error: unexpected symbol in:
: "           case_when(site == "Sopelana" ~ seq(0.025, 0.032, length.out = )
:                        )seq"
: Error: object 'sedrate' not found

***** a function that we can optimize
:PROPERTIES:
:CREATED:  [2024-02-02 Fri 15:45]
:END:
I think you get more insight with the gridded approach though...

#+begin_src R
  ##' Optimize Sedimentation Rate and Age
  ##'
  ##' .. content for \details{} ..
  ##' @title
  ##' @param vec Vector with sedrate and age_offset.
  ##' @param data
  ##' @param sol
  ##' @return
  optimize_sedrate_age <- function(vec, data, sol, kpg_age = 65.9e3) {
    diffs <- data |>
      mutate(sedrate = vec[[1]],
             age_offset = vec[[2]]) |>
      mutate(floating_age = .data$depth / .data$sedrate) |>
      mutate(age = kpg_age + .data$floating_age + .data$age_offset) |>
      mutate(ecc_sln = approx(sol$age, sol$scl, xout = .data$age)$y) |>
      mutate(SD = (.data$ecc_sln - .data$ecc)^2)

    diffs |>
      summarize(RMSD = sqrt(mean(SD))) |>
      pull(RMSD)
  }
#+end_src

#+RESULTS:

#+begin_src R :eval never
  diffs <-
     data_ecc |>
     tidylog::filter(detrend_type == "lin_scl_fine") |>
     tidylog::filter(comb == "1:1") |>
     select(-`405 kyr`, -`100 kyr`) |>
     nest(.by = c(proxy, site, detrend_type, comb, depth_chunk)) |>
     mutate(optim = map(data,
                        \(d) optim(par = c(0.05, 0),
                                   optimize_sedrate_age,
                                   data = d,
                                   sol = sln))) |>
     mutate(sedrate = map_dbl(optim, \(x) x$par[[1]]),
            age_offset = map_dbl(optim, \(x) x$par[[2]]),
            RMSD_optim = map_dbl(optim, "value")) |>
     select(-optim) |>
     unnest(cols = c(data)) |>
     mutate(floating_age = depth / sedrate,
            kpg_age = 65900,
            age = kpg_age + floating_age + age_offset) |>
     mutate(ecc_sln = approx(sln$age, sln$scl, xout = .data$age)$y) |>
     mutate(SD = (.data$ecc_sln - .data$ecc)^2) |>
     mutate(RMSD = sqrt(mean(SD)),
            .by = c(proxy, site, detrend_type, comb, depth_chunk))

  ## # double-check
  ## msd <- diffs |>
  ##   summarize(RMSD = sqrt(mean(SD)),
  ##             .by = c(proxy, site, detrend_type,
  ##                     comb, depth_chunk, age_offset)) |>
  ##   arrange(RMSD)

  # plot
  diffs |>
    ggplot(aes(x = age * 1e-3, y = ecc,
               group = paste(proxy, site, detrend_type, comb, depth_chunk))) +
    facet_grid(rows = vars(proxy)) +
    scale_x_reverse() +
    scale_colour_manual(values = c("Astronomical Solution" = "black",
                                   "Zumaia" = "purple",
                                   "Sopelana" = "blue")) +
    geom_vline(xintercept = kpg_ages$age1[[4]]) +
    geom_vline(aes(xintercept = 1e-3 * (kpg_age + age_offset)),
               linetype = "dashed") +
    geom_line(aes(y = ecc_sln, colour = "Astronomical Solution")) +
    geom_line(aes(colour = paste(site)))
#+end_src

#+RESULTS:
#+begin_example
filter: removed 44,838 rows (86%), 7,486 rows remaining
filter: no rows removed
+ + Error in `.data$sol`:
! Column `sol` not found in `.data`.
Run `rlang::last_trace()` to see where the error occurred.
Warning message:
Use of .data in tidyselect expressions was deprecated in tidyselect 1.2.0.
ℹ Please use `"sol"` instead of `.data$sol`
This warning is displayed once every 8 hours.
Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
generated.
#+end_example

**** which solution has the overall lowest RMSD?
:PROPERTIES:
:CREATED:  [2023-10-03 Tue 16:14]
:END:
We find out which of the many solutions is the best by filtering out the lowest RMSD score for each proxy and astronomical solution in [[cref:tab:best-depth]].
We only look at Zumaia here though.


try to eliminate large sed errors and weird offsets so that Sopelana ends up on the "right" position
#+begin_src R :results output
  best <-
    msd |>
      filter(abs(sed_error) < 0.005) |>
      filter(abs(age_offset) < 100) |>
      # get the best combination of proxy_lag and inv_sedrate values
      ## mutate(the_lowest = min(RMSD, na.rm = TRUE),
      ##      .by = c(proxy, site, detrend_type, comb, depth_chunk, sol)) |>
      ## mutate(relative = RMSD - the_lowest) |>
      ## mutate(og = sed_error == 0 & age_offset == 0) |>
      ## ## mutate(pretty_bad = relative > 0.5) |>
      ## mutate(not_that_much = relative < 0.1) |>
    ##   ggplot(aes(x = kpg_age * 1e-3, y = sedrate * 1e2, fill = relative)) +
    ##   facet_grid(cols = vars(site, proxy, depth_chunk), rows = vars(sol)) +
    ##   scale_fill_viridis_c() +
    ##   geom_raster() +
    ##   geom_raster(fill = "red", alpha = .6,
    ##               data = \(x) filter(x, not_that_much)) +
    ##   geom_point(colour = "red",
    ##              data = \(x) x |>
    ##                          filter(og) ##
    filter(RMSD == min(RMSD, na.rm = TRUE),
           .by = c(proxy, site, detrend_type, comb, depth_chunk, sol))

  best |> mutate(RMSD = round(RMSD, 3))
#+end_src

#+RESULTS:
#+begin_example
# A tibble: 28 × 12
   proxy site   detrend_type comb  depth_chunk     kpg_age m_per_kyr sedrate sed_error age_offset sol    RMSD
   <chr> <chr>  <chr>        <chr> <chr>             <dbl>     <dbl>   <dbl>     <dbl>      <dbl> <chr> <dbl>
 1 Lstar Zumaia lin_scl_fine 1:1   depth < 109.26    65900    0.0385  0.0385         0          0 ZB20a  1.27
 2 Lstar Zumaia lin_scl_fine 1:1   depth < 109.26    65900    0.0385  0.0385         0          0 ZB20b  1.36
 3 Lstar Zumaia lin_scl_fine 1:1   depth < 109.26    65900    0.0385  0.0385         0          0 ZB20c  1.46
 4 Lstar Zumaia lin_scl_fine 1:1   depth < 109.26    65900    0.0385  0.0385         0          0 ZB20d  1.46
 5 Lstar Zumaia lin_scl_fine 1:1   depth < 109.26    65900    0.0385  0.0385         0          0 La10c  1.48
 6 Lstar Zumaia lin_scl_fine 1:1   depth < 109.26    65900    0.0385  0.0385         0          0 La10b  1.51
 7 Lstar Zumaia lin_scl_fine 1:1   depth < 109.26    65900    0.0385  0.0385         0          0 ZB18a  1.52
 8 Lstar Zumaia lin_scl_fine 1:1   depth >= 109.26   65900    0.0391  0.0391         0          0 ZB20c  1.56
 9 Lstar Zumaia lin_scl_fine 1:1   depth >= 109.26   65900    0.0391  0.0391         0          0 ZB20d  1.60
10 Lstar Zumaia lin_scl_fine 1:1   depth >= 109.26   65900    0.0391  0.0391         0          0 ZB18a  1.60
# ℹ 18 more rows
# ℹ Use `print(n = ...)` to see more rows
#+end_example

#+name: tab:best-depth
#+caption: Zumaia records with the lowest RMSD score by proxy and astronomical solution.
#+RESULTS:

Or just blindly calculate the average RMSD of all the different approaches in [[cref:tab:best-depth-global]]

#+begin_src R :results value :colnames yes :exports results
  msd |>
    filter(site == "Zumaia") |>
    ## filter(proxy != "d13C") |>
    filter(RMSD == min(RMSD), .by = sol) |> select(-inv_sedrate, -site) |>
    mutate(RMSD = round(RMSD, 3))
#+end_src

#+name: tab:best-depth-global
#+caption: Zumaia records lowest RMSD score per astronomical solution.
#+RESULTS:
| proxy | detrend_type | comb | depth_chunk     | kpg_age | count_error | age_offset | sol   |  RMSD |
|-------+--------------+------+-----------------+---------+-------------+------------+-------+-------|
| MS    | lin_scl_fine |  1:1 | depth >= 109.26 |   65980 |           0 |         80 | ZB20a | 1.051 |
| MS    | lin_scl_fine |  1:1 | depth >= 109.26 |   65820 |       -0.15 |        -80 | ZB20b | 1.106 |
| MS    | lin_scl_fine |  1:1 | depth >= 109.26 |   65760 |        -0.1 |       -140 | La10c | 1.106 |
| MS    | lin_scl_fine |  1:1 | depth >= 109.26 |   65840 |       -0.15 |        -60 | ZB18a | 1.143 |
| MS    | lin_scl_fine |  1:1 | depth >= 109.26 |   65860 |       -0.15 |        -40 | La10b | 1.188 |
| MS    | lin_scl_fine |  1:1 | depth >= 109.26 |   65840 |       -0.15 |        -60 | ZB20c | 1.204 |
| MS    | lin_scl_fine |  1:1 | depth >= 109.26 |   65740 |       -0.15 |       -160 | ZB20d | 1.286 |

We can also make a nice overview figure of all the different parameter perturbations.

#+begin_src R :results output graphics file :file imgs/Zumaia-depth-RMSD-scores.png :width 2600 :height 1200 :res 300
  ## msd |>
  best |>
    ggplot(aes(x = sol, y = RMSD,
               ## colour = factor(count_error)
               colour = sedrate * 100
               ## shape = detrend_type
               )) +
    facet_grid(cols = vars(site, depth_chunk,
                           ## round(1 / inv_sedrate * 100, 2)
                           ), rows = vars(proxy)) +
    scale_colour_viridis_c() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 0)) +
    geom_line(aes(group = paste(site, proxy, comb)), colour = "black") +
    geom_point(size = 2) #+
    ## geom_point(size = 4, data = best) +
    ## scale_colour_viridis_c()
#+end_src

#+caption: Best linear age model using a single sedimentation rate. We varied the K/T age (different lines/points), the ~inv_sedrate~ (colour), and the ~detrend_type~. This figure is limited to a ~comb~ of 1:0.5.
#+RESULTS:
[[file:imgs/Zumaia-depth-RMSD-scores.png]]

**** plot RMSD as a function of K/T age
:PROPERTIES:
:CREATED:  [2023-10-02 Mon 10:38]
:END:
[[cref:fig:depth-rmsd-scores]] has become a bit of a complex figure. I wanted to get a glance at which proxy for which site scores the best overall RMSD.

This shows that the d13C record gives us the overall best RMSD's, but the d13C seems to only shows a strong 405 kyr cyclicity, no significant 100 kyr cyclicity (see figure of spectra above).

# #+begin_src R :results output graphics file :file imgs/Zumaia_MSD-overview.png :width 1920 :height 1080
#+begin_src R :results output graphics file :file imgs/Zumaia_MSD-overview.png :width 3400 :height 2600 :res 300
  msd |>
    ## filter(abs(sed_error) < 0.01) |>
    ggplot(aes(x = kpg_age * 1e-3,
               y = RMSD,
               ## colour = paste(inv_sedrate, " = ", round(1 / inv_sedrate * 100, 2))## ,
               ## linetype = comb
               )) +
    facet_grid(cols = vars(proxy, site, depth_chunk,
                           ## round(1 / inv_sedrate * 100, 2)
                           ),
               rows = vars(sol)) +
    ## scale_colour_viridis_d(#guide = guide_colorbar(direction = "horizontal")
   ## ) +
    scale_x_reverse() +
    scale_colour_distiller(type = "div", palette = 3) +
    ## scale_colour_viridis_c() +
    labs(
      ## title = "Combinations of 405 kyr and 100 kyr filters and their RMSD",
      x = "K/T age", y = "RMSD",
      ## colour = "Inv sed rate (kyr/m) = Sedimentation rate (cm/kyr)"
    ) +
    geom_vline(aes(xintercept = age1), data = kpg_ages |> filter(sln != "La11") |> rename(sol = sln)) +
    geom_vline(aes(xintercept = age2), data = kpg_ages |> filter(sln != "La11") |> rename(sol = sln)) +
    geom_line(aes(group = paste(sed_error, comb, detrend_type),
                  ## colour = sedrate
                  colour = sed_error
                  ),
              linewidth = .7) +
    geom_point(colour = "red", data = best)
#+end_src

#+name: fig:depth-rmsd-scores
#+caption: *Overview of RMSD scores* Assumed age of the K/T boundary versus the RMSD score. Vertical panels are the sites (Zumaia and the downwards extension in Sopelana) different proxies (MS, L* and d13C). Horizontal panels are the orbital solution the filtered data were compared to (for now only ZB18a and ZB20a), whether I constructed my filtered record as a combination of a direct 405 kyr filter and a 100 kyr filter or as a combination of a 405 kyr filter and the Hilbert transform of the precession filter, and in which proportions I've added the 405 kyr and 100 kyr components together. Vertical lines show the age of the K/T boundary with uncertainty based on \ce{^40Ar/^39Ar} and U--Pb data ([cite:@Batenburg2014] cite [cite:@Renne2013] based on new bentonite ages from coals near the K/T boundary).
#+attr_latex: :width 1.2\linewidth
#+RESULTS:
[[file:imgs/Zumaia_MSD-overview.png]]

**** plot RMSD as a function of sedrate
:PROPERTIES:
:CREATED:  [2024-02-06 Tue 15:37]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_MSD-sedrate.png :width 3400 :height 2600 :res 300
  msd |>
    ## filter(abs(sed_error) < 0.01) |>
    ggplot(aes(x = sedrate * 1e2,
               y = RMSD,
               ## colour = paste(inv_sedrate, " = ", round(1 / inv_sedrate * 100, 2))## ,
               ## linetype = comb
               )) +
    facet_grid(cols = vars(proxy, site, depth_chunk,
                           ## round(1 / inv_sedrate * 100, 2)
                           ),
               rows = vars(sol)) +
    ## scale_colour_viridis_d(#guide = guide_colorbar(direction = "horizontal")
   ## ) +
    scale_colour_distiller(type = "div", palette = 3) +
    ## scale_colour_viridis_c() +
    labs(
      ## title = "Combinations of 405 kyr and 100 kyr filters and their RMSD",
      x =  "Sedimentation rate (cm/kyr)",
      y = "RMSD",
      colour = "K/T age (Ma)"
    ) +
    geom_line(aes(group = paste(age_offset, comb, detrend_type),
                  colour = kpg_age * 1e-3
                  ),
              linewidth = .7) +
    geom_point(colour = "red", data = best)
#+end_src

#+name: fig:depth-rmsd-scores
#+attr_latex: :width 1.2\linewidth
#+RESULTS:
[[file:imgs/Zumaia_MSD-sedrate.png]]

**** plot RMSD as a function of orbital solution, tau, K/T age, ...
:PROPERTIES:
:CREATED:  [2023-09-27 Wed 19:04]
:END:
Here I make a heatmap with the same information as the previous figure.

# #+begin_src R :results output graphics file :file imgs/Zumaia_ecc_RMSD.png :width 1920 :height 800
#+begin_src R :results output graphics file :file imgs/Zumaia_ecc_RMSD.png :width 1200 :height 2200 :res 300
  my_filt <- \(d) d |>
    tidylog::filter(detrend_type == "lin_scl_fine") |>
    tidylog::filter(comb == "1:1") |>
    ## tidylog::filter(site == "Zumaia") |>
    tidylog::filter(proxy == "Lstar") #|>
    ## tidylog::filter(depth_chunk == "depth < 109.26")

  msd |>
    # let's simplify a bit
    my_filt() |>
    ggplot(aes(x = kpg_age * 1e-3,
               y = sedrate * 1e2,
               ## y = count_error,
               ## y = sed_error,
               ## group = paste(comb, filt_env, site, tau, sol),
               ## colour = tau
               fill = RMSD
               )) +
    theme(strip.text.x.top = element_text(size = 4),
          axis.text.x = element_text(size = 6)) +
    facet_grid(cols = vars(proxy, site, depth_chunk),
               rows = vars(sol)) +
    scale_x_continuous(breaks = c(65.9 - 0.1,65.9 + .1)) +
    scale_fill_viridis_c() +
    scale_colour_viridis_c() +
    labs(x = "Age of the K/T boundary (Ma)",
         ## y = "Inverted sedimentation rate (kyr/cm)",
         y = "Sedimentation rate (cm/kyr)",
         ## y = "Count error (fraction)",
         ## y = "Sedimentation rate offset (m/kyr)",
         fill = "RMSD") +
    ## geom_hline(yintercept = 0, colour = "red", alpha = .3) +
    geom_vline(aes(xintercept = age1),
               colour = "red", alpha = .3,
               data = kpg_ages |> filter(sln != "La11") |> rename(sol = sln)) +
    geom_vline(aes(xintercept = age2),
               colour = "red", alpha = .3,
               data = kpg_ages |> filter(sln != "La11") |> rename(sol = sln)) +
    ## geom_line() +
    geom_raster() +
    geom_raster(fill = "white",
                alpha = 0.3,
                data = \(x)
                x |> filter(abs(age_offset) < 100,
                            abs(sed_error) < 0.005)) +
    ## geom_rect()
    ## geom_point(aes(colour = RMSD), size = 1.2, shape = "■") +
    geom_point(aes(colour = RMSD),
               colour = "red",
               size = .2, data = best |> my_filt())
#+end_src

#+attr_latex: :width .45\linewidth
#+caption: The various assumptions for the K/T age on the x-axis versus sedimentation rates on the y-axis. Horizontal panels are grouped by detrend_type, filter/Hilbert, and the proportion of the 405 kyr signal compared to the 100 kyr signal, while vertical panels are grouped by site, proxy, and orbital solution.
#+RESULTS:
[[file:imgs/Zumaia_ecc_RMSD.png]]

**** make the plot 3d and interactive
:PROPERTIES:
:CREATED:  [2024-02-06 Tue 15:30]
:END:
#+begin_src R
  ## pl_depth <- ggplot2::last_plot()
  pl_depth |>
    rayshader::plot_gg(width = 4,
                       height = 9,
                       height_aes = "fill",
                       scale = 50)
#+end_src

**** plot the curves with the lowest overall RMSD
:PROPERTIES:
:CREATED:  [2023-09-27 Wed 19:03]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_ecc_ZB18a.png :width 2600 :height 3200 :res 300
  # this plot crashes if I plot them all
  diffs |>
    # the "best" Zumaia setup?
    # filter out some of the best fits
    ## filter(site == "Zumaia") |>
    ## filter(depth_chunk != "full record") |>
    ## filter(depth_chunk != "full record") |>
    ## filter(site == "Sopelana") |>
    ## my_filt() |>
    tidylog::inner_join(best) |>
    ## tidylog::full_join(best) |>
    ## tidylog::left_join(best) |>
    ggplot(aes(x = age / 1e3,
               group = paste(comb, ## filt_env,
                             site, sedrate, kpg_age, depth_chunk #proxy_lag
                             ## count_error
                             ),
               ## colour = 1 / tau * 100, # convert from kyr/m to cm/kyr
               ## colour = kpg_age,
               # filt_env??
               )) +
    theme(legend.position = "top") +
    facet_grid(rows = vars(sol), cols = vars(proxy),
               scales = "free_x", space = "free_x") +
    labs(x = "Age (Ma)",
         y = "Normalized filtered proxy / Normalized OS",
         ## linetype = "405:100 kyr weighing",
         ## colour = "Age of the K/T boundary",
         ## colour = "Sedimentation rate (cm/kyr)",
         colour = "",
         ## alpha = "RMSD\n(lower = better)"
         ) +
    scale_alpha_manual("Smaller chunk",
                       values = c(.4, 1)) +
    scale_y_continuous(breaks = c(-2, 0, 2)) +
    ## scale_colour_viridis_c() +
    ## scale_alpha_continuous(range = c(.9, .05)) +
    scale_x_reverse() +
    ## scale_colour_brewer(type = "qual") +
    scale_colour_manual(values = c("Astronomical Solution" = "black",
                                   "Zumaia" = "purple",
                                   "Sopelana" = "skyblue"
                                   ## "Lstar" = "purple",
                                   ## "MS" = "skyblue",
                                   ## "d13C" = "darkgreen"
                                   )) +
    ## coord_cartesian(xlim = c(69.5, 65.9)) +
    geom_vline(aes(xintercept = age1), data = kpg_ages |>
                                         filter(sln != "La11") |>
                                         rename(sol = sln)) +
    geom_vline(aes(xintercept = age2), data = kpg_ages |>
                                         filter(sln != "La11") |>
                                         rename(sol = sln)) +
    # field tie points
    geom_vline(aes(xintercept = age * 1e-3, colour = site),
               data = agem_sol) +
    # k/pg age
    geom_vline(aes(xintercept = kpg_age * 1e-3, colour = site)) +
    # orbital solutions
    geom_line(aes(x = age * 1e-3, y = scl, group = sol,
                  colour = "Astronomical Solution"),
              data = slns |>
                filter(sln != "La11") |>
                ## filter(age > 65.5e3 & age < 72.5e3) |>
                filter(age > 65.5e3 & age < 73e3) |>
                rename(sol = sln)) +
    # our filtered record
    geom_line(aes(y = ecc, #RMSD = RMSD,
                  alpha = site != "Zumaia" | depth_chunk != "full record",
                  ## linetype = factor(count_error),
                  colour = site), linewidth = 1.2) +
    # annotate RMSD for each proxy/site/sol combo
    geom_text(aes(x = age / 1e3, y = 3.6,
                  group = paste(site, depth_chunk),
                  alpha = site != "Zumaia" | depth_chunk != "full record",
                  colour = site,
                  label = round(RMSD, 3)
                  ),
              size = 3,
              hjust = 0, alpha = 1,
              data = \(d) d |>
                summarize(age = mean(age),
                          RMSD = mean(RMSD),
                          .by = c(proxy, site, comb, depth_chunk, sol)))
#+end_src

#+name: fig:best-depth
#+caption: Zumaia best proxy match with astronomical solutions based on single sedimentation rate. *NOTE:* Because of my large range in sedimentation rates, the older Sopelana site is often floating off to ages too old.
#+attr_latex: :width \linewidth
#+RESULTS:
[[file:imgs/Zumaia_ecc_ZB18a.png]]

*** analysis in the time domain
:PROPERTIES:
:CREATED:  [2023-09-29 Fri 13:11]
:END:
We use the identification of the long eccentricity minima from the field (which has the 405 kyr minima) and assume each of them lasted 405 kyr.

After applying the age model, we filter the 405 kyr and 100 kyr components to generate an `eccentricity' curve from the record. Then we calculate RMSD between that and the astronomical solution.

Note that this often crashed my laptop, so we limit the variable perturbations a little bit. (My R session runs out of memory, crashing my whole emacs session but luckily not my laptop).

**** Apply floating age model based on long ecc
:PROPERTIES:
:CREATED:  [2023-11-17 Fri 14:07]
:END:
#+begin_src R
  smooth_ages <- smooth_pred |>
    mutate(Ma405 = findInterval(depth, agem_indep$strat_bot)) |>
    # add orbital solution ages based on the 405 kyr minima
    mutate(age_floating = Hmisc::approxExtrap(agem_indep$strat_bot,
                                                  agem_indep$age_floating,
                                                  xout = depth)$y,
           .after = depth) |>
    arrange(detrend_type)
#+end_src

#+RESULTS:

**** Did we number the Ma405 correctly?
#+begin_src R :results output graphics file :file imgs/Ma405_categories.png :width 2400 :height 1800 :res 300
  prx <- "Lstar"
  smooth_ages |>
    filter(proxy == prx, ## sol == "ZB18a",
           detrend_type == "value") |>
    ggplot(aes(x = kpg_ages$age1[[4]] + age_floating / 1e3, y = value, colour = site)) +
    facet_grid(rows = vars(proxy)) +
    scale_x_reverse() +
    labs(x = "Age (Ma)", y = "Magnetic Susceptibility") +
    # annotate astronomical solution
    geom_line(aes(x = age * 1e-3, y = scl * 2, group = sol),
              inherit.aes = FALSE,
              data = slns |>
                filter(sln != "La11") |>
                filter(age > 65800) |>
                filter(age < 71500) |>
                rename(sol = sln)) +

    # annotate the K/T ages
    geom_vline(aes(xintercept = age1),
               data = kpg_ages |> filter(sln != "La11") |> rename(sol = sln)) +
    geom_vline(aes(xintercept = age2),
               data = kpg_ages |> filter(sln != "La11") |> rename(sol = sln)) +

    geom_line() +
    geom_line(aes(y = Ma405 + 20),
              colour = "indianred") +
    annotate("text", x = 67, y = 32, colour = "indianred",
             label = "Ma405 cycle") +
    geom_text(aes(x = kpg_ages$age1[[4]] + age_floating / 1e3, y = 27,
                  label = round(kpg_ages$age1[[4]] + age_floating / 1e3, 3)),
              colour = "black",
              data = smooth_ages |>
                filter(proxy == prx, detrend_type == "value") |>
                filter(Ma405 == 1) |>
              distinct(Ma405, .keep_all = TRUE)) +
    geom_text(aes(y = Ma405 + 20, label = Ma405),
              colour = "indianred",
              nudge_x = - .405 / 2, nudge_y = 2.5,
              data = smooth_ages |>
                filter(proxy == prx, detrend_type == "value") |>
                distinct(Ma405, .keep_all = TRUE)) +
    theme(legend.pos = c(.06, .41), legend.background = element_blank())
#+end_src

#+attr_latex: :width \linewidth
#+caption: This figure is just to double-check that the astronomical solution 405 kyr minima were identifed consistently.
#+RESULTS:
[[file:imgs/Ma405_categories.png]]

**** calculate spectra in the time domain
:PROPERTIES:
:CREATED:  [2023-09-26 Tue 16:49]
:END:
***** mtm
#+begin_src R
  specs_age <- smooth_ages |>
    nested_spectral_analysis(nest = c("proxy", "site", "detrend_type", "depth_chunk"),
                             detrend = TRUE,
                      x = age_floating, y = value)
#+end_src

#+RESULTS:
***** lowspec
#+begin_src R
  specs_age_lowspec <- smooth_ages |>
    nested_spectral_analysis(nest = c("proxy", "site", "detrend_type", "depth_chunk"),
                             detrend = TRUE, lowspan = 5,
                             method = "LOWSPEC",
                             x = age_floating, y = value)
#+end_src

#+RESULTS:

***** FFT periodogram
:PROPERTIES:
:CREATED:  [2023-12-19 Tue 16:00]
:END:
#+begin_src R
  specs_fft_age <- smooth_ages |>
    nest(.by = c("proxy", "site", "detrend_type", "depth_chunk")) |>
    mutate(fft = map(data,
                      ~ . |>
                        select(age_floating, value) |>
                        astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                        astrochron::periodogram(genplot = F, verbose = F, output = 1, detrend = TRUE) |>
                        as_tibble()
                        )) |>
    select(-data) |>
    unnest(cols = c(fft)) |>
    rename(frequency = Frequency, amplitude = Amplitude, power = Power, phase = Phase)
#+end_src

#+RESULTS:

***** MTLS
:PROPERTIES:
:CREATED:  [2023-12-19 Tue 16:17]
:END:
Source the library (now installed!)
#+begin_src R :eval never
    source("https://github.com/jrevenaugh/TSAUMN2/raw/main/R/spec.mtls.R")
    source("https://github.com/jrevenaugh/TSAUMN2/raw/main/R/mtm_plots.R")
#+end_src

#+RESULTS:

#+begin_src R
  specs_mtls_age <- smooth_ages |>
    nest(.by = c("proxy", "site", "detrend_type", "depth_chunk")) |>
    mutate(mtls = map(data,
                      ~ . |>
                        select(age_floating, value) |>
                        # NOTE: no need to linearly interpolate!
                        # That's the point!
                        TSAUMN::spec.mtls(plot = FALSE, detrend = TRUE) |>
                        as_tibble())) |>
    select(-data) |>
    unnest(mtls) |>
    rename(frequency = freq, power = spec) |>
    select(-method, -series)
  #+end_src

  #+RESULTS:
  : Registered S3 method overwritten by 'quantmod':
  :   method            from
  :   as.zoo.data.frame zoo

**** COMMENT do eha on one example dataset
:PROPERTIES:
:CREATED:  [2023-11-17 Fri 15:30]
:END:
#+begin_src R
  smooth_ages |>
    filter(proxy == "Lstar",
           site == "Zumaia",
           detrend_type == "lin_scl_fine",
                   depth_chunk == "depth < 109.26") |>
    select(age_floating, value) |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::eha(fmax = .02, ydir = -1)
#+end_src

#+RESULTS:
#+begin_example

 ----- PERFORMING EVOLUTIVE HARMONIC ANALYSIS -----
 ,* Number of data points in stratigraphic series: 1037
 ,* Stratigraphic series length (space or time): 2797.2
 ,* Sampling interval (space or time): 2.7
 ,* Number of data points per window: 101
 ,* Moving window size (space or time): 270
 ,* Window step points: 10
 ,* Window step (space or time): 27
 ,* Number of windows: 94
 ,* Mean value for each window will be subtracted
 ,* Linear trend for each window will be subtracted
 ,* Nyquist frequency: 0.1851852
 ,* Rayleigh frequency: 0.003667033
 ,* MTM Power spectrum bandwidth resolution (halfwidth): 0.007334067
 ,* Will use 3 DPSS tapers
 ,* Padded to 256 points
#+end_example

**** which time-domain filters did they apply in Batenburg?
:PROPERTIES:
:CREATED:  [2023-11-17 Fri 14:21]
:END:
#+begin_src R
  # these are from Batenburg et al., 2014 figure 4
  # in the time domain they do not seem to make a distinction between sites
  bat_age_filters <- tribble(
    ~ target, ~ proxy, ~ center, ~ plow, ~ phigh,
    "405 kyr", "Lstar", 415, 311, 621,
    "100 kyr", "Lstar", 100, 75, 150,
    "23 kyr", "Lstar", 17.9, 13.4, 27.2,
    "405 kyr", "MS", 409, 308, 609,
    "100 kyr", "MS", 100, 75, 150,
    "23 kyr", "MS", 23.6, 17.8, 35.3,
    ) |>
    mutate(flow = 1 / plow, fhigh = 1 / phigh, ref = "Batenburg et al., 2014")
#+end_src

#+RESULTS:

**** add a tibble with our desired filter intervals here
:PROPERTIES:
:CREATED:  [2023-09-28 Thu 17:02]
:END:
We just filter by 405 kyr, 110 kyr and 23 kyr \pm30%.

see [[file:~/SurfDrive/Postdoc1/prj/2023-05-19_cretaceous_constraints/cretaceous_constraints.org::*filter ranges in the age domain][filter ranges in the age domain]].
#+begin_src R
  my_filt_age
#+end_src

#+RESULTS:
: # A tibble: 3 × 7
:   target      p       f    range    flow   fhigh ref
:   <chr>   <dbl>   <dbl>    <dbl>   <dbl>   <dbl> <chr>
: 1 405 kyr   405 0.00247 0.000741 0.00173 0.00321 This study
: 2 100 kyr   110 0.00909 0.00273  0.00636 0.0118  This study
: 3 23 kyr     23 0.0435  0.0130   0.0304  0.0565  This study

**** plot spectra
:PROPERTIES:
:CREATED:  [2023-09-26 Tue 16:50]
:END:
# #+begin_src R :results output graphics file :file imgs/Zumaia_Sopelana_spectra_filters.png :width 2400 :height 2200 :res 300
#+begin_src R :results output graphics file :file imgs/Zumaia_Sopelana_spectra_filters.pdf :width 10 :height 6
  my_filter <- \(x) x |>
                      ## filter(detrend_type != "value") # default to show all
                      ## filter(detrend_type == "value") |> # only raw for signif
                      filter(detrend_type %in% c("value", "lin_scl_med")) |> # only raw for signif
                      filter(depth_chunk == "full record")
                      ## filter(detrend_type == "scl") # only one so we can see different spectral analysis
                      ## filter(detrend_type == "lin_gam_det")
                      ## filter(detrend_type == "lin_scl_fine") #|>
                      ## filter(depth_chunk == "depth < 109.26")

  # plot spectra w/ Freq on x-axis
  specs_age |>
    my_filter() |>
    ## filter(detrend_type != "value") |>
    ## plot_spectrum(group = c("sol")) # only works well for a single grouping variable
    ggplot(aes(x = frequency, y = power,
               linetype = detrend_type
               ## linetype = site,
               ## colour = detrend_type
               )) +
    facet_grid(cols = vars(site, depth_chunk), rows = vars(proxy)) +
    ## scale_linetype_manual(values = c("Zumaia" = "solid",
    ##                                  "Sopelana" = "dashed")) +
    labs(x = "Frequency (cycles/kyr)", y = "Power (-)",
         colour = "Spectral Analysis", fill = "Reference") +
    scale_colour_manual(values = c("MTM" = "indianred",
                                   "FFT" = "darkgray",
                                   "LOWSPEC" = "orange",
                                   "MTLS" = "purple")) +
    coord_cartesian(
      ## xlim = c(1 / 1000, 1 / 10), # for a log x axis
      ## xlim = c(0, .072),
      xlim = c(0, .075), # same as new Malinverno & Meyers 2023 preprint
      ## xlim = c(0, .016), # zoom in on 405 and 100 kyr ecc
      ## ylim = c(0, .025) # previous best
      ## ylim = c(2e-5, .03) # log
      ## ylim = c(.0001, 0.020) # log axis
      ylim = c(2e-5, 1) # log for raw
    ) +
    scale_x_continuous(
    ## scale_x_log10(
      breaks = seq(0, 0.10, 0.020),
      minor_breaks = seq(0, 0.10, 0.01),
      sec.axis = sec_axis("Period (kyr)", trans = ~ 1 / .,
                          breaks = c(405, 100, 41, 23))) +
    ## scale_y_continuous(breaks = c(0, .01, .02)) +
    scale_y_log10() +
    annotation_logticks(sides = "l") +
    ## # plot AR1 fits/confidence levels
    ## ## geom_line(aes(y = AR1_power, group = paste(site, detrend_type, sol, .width))) +
    ## ## geom_line(aes(y = Harmonic_CL)) +
    ## geom_ribbon(aes(ymin = AR1_fit, ymax = AR1_power,
    ##                 linetype = NA, fill = detrend_type,
    ##                 group = paste(detrend_type, site, sol, proxy, .width)),
    ##               alpha = .1) +
    # rectangles for target frequencies
    ## ggnewscale::new_scale_fill() +

    geom_segment(aes(x = 1 / center, y = 3e-5, xend = 1 / center, yend = 6e-5),
                 inherit.aes = FALSE,
                 data = bat_age_filters) +
    geom_rect(aes(xmin = flow, xmax = fhigh, ymin = 3e-5, ymax = 6e-5, fill = ref),
              inherit.aes = FALSE,
              alpha = .3,
              data = bat_age_filters) +
    # I drew these, but then realized we're doing a uniform filter by default, mean is not relevant!
    ## geom_segment(aes(x = f, xend = f, y = 1e-5, yend = 3e-5, colour = ref),
    ##              data = my_filt_age) +
    geom_segment(aes(x = f, y = 1e-5, xend = f, yend = 3e-5),
                 inherit.aes = FALSE,
                 data = my_filt_age) +
    geom_rect(aes(xmin = flow, xmax = fhigh, ymin = 1e-5, ymax = 3e-5, fill = ref),
              inherit.aes = FALSE,
              alpha = .3,
              data = my_filt_age) +

    # plot spectra
    # FFT periodogram
    geom_line(aes(colour = "FFT",
                  group = paste(site, proxy, detrend_type, depth_chunk)),
              alpha = .4,
              data = specs_fft_age |>
                my_filter()) +
    # MTM
    geom_ribbon(aes(ymin = ar1_fit, ymax = ar1_power,
                    linetype = NA,
                    group = paste(site, proxy, detrend_type, depth_chunk, .width)),
                fill = "black",
                alpha = .1) +
    geom_line(aes(colour = "MTM",
                  group = paste(site, proxy, detrend_type, depth_chunk))) +
    # lowspec
    geom_ribbon(aes(ymin = lowspec_fit, ymax = lowspec_power,
                    linetype = NA,
                    group = paste(site, proxy, detrend_type, depth_chunk, .width)),
                fill = "orange",
                alpha = .2, data = specs_age_lowspec |> my_filter()) +
     geom_line(aes(colour = "LOWSPEC",
                   group = paste(site, proxy, detrend_type, depth_chunk)),
               data = specs_age_lowspec |> my_filter()) +

    # MTLS
    geom_line(aes(colour = "MTLS",
                  group = paste(site, proxy, detrend_type, depth_chunk)),
              data = specs_mtls_age |>
                my_filter())
#+end_src

#+attr_latex: :width \linewidth
#+caption: Zumaia/Sopelana spectral analysis after tuning each of the 405 kyr minima from the field [cite:@Batenburg2012] to 405 kyr mimima in each of the orbital solutions. Note that the d13C doesn't appear to have any spectral peak around the 100 kyr period. We show the fast fourier transform (FFT), multitaper method (MTM) and the multi-taper averaged Lomb-Scargle periodogram of (un)evenly spaced data (MTLS).
#+RESULTS:
[[file:imgs/Zumaia_Sopelana_spectra_filters.pdf]]

**** COMMENT plot spectra with period on the x-axis
:PROPERTIES:
:CREATED:  [2023-09-26 Tue 16:50]
:END:
#+begin_src R :eval never
  # plot spectra with period on x-axis (with log-axis)
  specs_age |>
    ggplot(aes(x = 1 / Frequency, y = Power, colour = site)) +
    facet_grid(## cols = vars(site),
               rows = vars(proxy)) +
    geom_line() +
    geom_line(aes(y = AR1_fit)) +
    geom_line(aes(y = AR1_95_power), linetype = "dashed") +
    ## geom_line(aes(y = Harmonic_CL)) +
    ## coord_cartesian(xlim = c(1e-3, 1e-1)) +
    coord_cartesian(xlim = c(10, 5000)) +
    scale_y_log10() +
    scale_x_log10() +
    annotation_logticks() +
    geom_rect(aes(xmin = 1 / flow, xmax = 1 / fhigh, ymin = 1e-5, ymax = 1),
              inherit.aes = FALSE,
              alpha = .3, fill = "yellow",
              data = filts_age |> distinct(proxy, flow, fhigh)) +
    labs(x = "Period (kyr)", y = "Power", colour = "Site")
#+end_src
**** play around with bandpass filter parameters
:PROPERTIES:
:CREATED:  [2024-02-21 Wed 14:36]
:END:
experiment with the effects of the bandpass window and frequency fraction

I think the gaussian window came out nicest!

ok the .3 is fine I guess

#+begin_src R :results none
  # after some experimentation, the same as bat
  ## target_periods <- c("405 kyr" = 415, "100 kyr" = 100)
  ## frequency_fraction <- 1/3
  target_periods <- c("405 kyr" = 405, "100 kyr" = 110)
  frequency_fraction <- 0.33
  bandpass_window <- 0
  my_filt_age <- tibble::tibble(target = c("405 kyr", "100 kyr"),
                                p = target_periods) |>
    dplyr::mutate(f = 1 / .data$p,
                  range = frequency_fraction * .data$f,
                  flow = .data$f - .data$range,
                  fhigh = .data$f + .data$range,
                  ref = "This study")

  mini_data <- smooth_ages |>
    ## filter(detrend_type == "value") |>
    filter(detrend_type == "lin_scl_med") |>
    filter(site == "Zumaia", proxy == "Lstar",
           depth_chunk == "full record")

  # 405 kyr
  fl <- 0.00165
  fh <- 0.00328

  # 100 kyr
  fl <- my_filt_age$flow[[2]]
  fh <- my_filt_age$fhigh[[2]]

  # guassian wider?
  # seems like it's parametrized at 95% CI?
  # hmm just 2*range doesn't cut it
  # I use
  ## flw <- my_filt_age$f[[2]] - my_filt_age$f[[2]] * 0.33 * 3
  ## fhw <- my_filt_age$f[[2]] + my_filt_age$f[[2]] * 0.33 * 3

  x11(title = "rectangular")
  mini_data |>
    select(age_floating, value) |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::bandpass(flow = fl, fhigh = fh,
                         win = 0, padfac = 5, alpha = 1,
                         demean = TRUE, detrend = TRUE,
                         genplot = TRUE, verbose = FALSE,
                         xmax = 0.03)

  x11(title = "gaussian")
  mini_data |>
    select(age_floating, value) |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::bandpass(flow = fl, fhigh = fh,
                         win = 1, padfac = 5, alpha = 3,
                         demean = TRUE, detrend = TRUE,
                         genplot = TRUE, verbose = FALSE,
                         xmax = 0.03)


  # but stephen told me he prefers the taner filter now
  x11(title = "taner 1e3")
  mini_data |>
    select(age_floating, value) |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::taner(flow = fl, fhigh = fh,
                      roll = 1e3,
                      padfac = 5,
                      demean = TRUE, detrend = TRUE,
                      genplot = TRUE, verbose = FALSE,
                      xmax = 0.03)

  x11(title = "taner 1e6")
  mini_data |>
    select(age_floating, value) |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::taner(flow = fl, fhigh = fh,
                      roll = 1e6,
                      padfac = 5,
                      demean = TRUE, detrend = TRUE,
                      genplot = TRUE, verbose = FALSE,
                      xmax = 0.03)

  x11(title = "taner 1e10")
  mini_data |>
    select(age_floating, value) |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::taner(flow = fl, fhigh = fh,
                      roll = 1e10,
                      padfac = 5,
                      demean = TRUE, detrend = TRUE,
                      genplot = TRUE, verbose = FALSE,
                      xmax = 0.03)

  x11(title = "taner 1e12")
  mini_data |>
    select(age_floating, value) |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::taner(flow = fl, fhigh = fh,
                      roll = 1e12,
                      padfac = 5,
                      demean = TRUE, detrend = TRUE,
                      genplot = TRUE, verbose = FALSE,
                      xmax = 0.03)

  x11(title = "taner 1e20")
  mini_data |>
    select(age_floating, value) |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::taner(flow = fl, fhigh = fh,
                      roll = 1e20,
                      padfac = 5,
                      demean = TRUE, detrend = TRUE,
                      genplot = TRUE, verbose = FALSE,
                      xmax = 0.03)


  # a little more manual approach
  mini_data |>
    select(age_floating, value) |>
    ggplot(aes(x = age_floating, y = value)) +
    ## geom_line() +
    geom_line(aes(colour = "rect 005"),
              data = \(x) x |>
                          astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                          astrochron::bandpass(flow = fl, fhigh = fh,
                                               win = 0, padfac = 5,
                                               demean = TRUE, detrend = TRUE,
                                               genplot = FALSE, verbose = FALSE,
                                               xmax = 0.03)) +
    geom_line(aes(colour = "rect 010"),
              data = \(x) x |>
                          astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                          astrochron::bandpass(flow = fl, fhigh = fh,
                                               win = 0, padfac = 10,
                                               demean = TRUE, detrend = TRUE,
                                               genplot = FALSE, verbose = FALSE,
                                               xmax = 0.03)) +
    geom_line(aes(colour = "rect 015"),
              data = \(x) x |>
                          astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                          astrochron::bandpass(flow = fl, fhigh = fh,
                                               win = 0, padfac = 15,
                                               demean = TRUE, detrend = TRUE,
                                               genplot = FALSE, verbose = FALSE,
                                               xmax = 0.03)) +
    geom_line(aes(colour = "rect 100"),
              data = \(x) x |>
                          astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                          astrochron::bandpass(flow = fl, fhigh = fh,
                                               win = 0, padfac = 100,
                                               demean = TRUE, detrend = TRUE,
                                               genplot = FALSE, verbose = FALSE,
                                               xmax = 0.03)) +
    # gaussians!
    geom_line(aes(colour = "gaussian 100"),
              data = \(x) x |>
                          astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                          astrochron::bandpass(flow = flw, fhigh = fhw,
                                               win = 1, padfac = 100,
                                               demean = TRUE, detrend = TRUE,
                                               genplot = FALSE, verbose = FALSE,
                                               xmax = 0.03)) +
    geom_line(aes(colour = "gaussian 005"),
              data = \(x) x |>
                          astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                          astrochron::bandpass(flow = flw, fhigh = fhw,
                                               win = 1, padfac = 5,
                                               demean = TRUE, detrend = TRUE,
                                               genplot = FALSE, verbose = FALSE,
                                               xmax = 0.03)) +
      geom_line(aes(colour = "gaussian 005 alpha = 6"),
              data = \(x) x |>
                          astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                          astrochron::bandpass(flow = fl, fhigh = fh,
                                               win = 1, padfac = 5, alpha = 1,
                                               demean = TRUE, detrend = TRUE,
                                               genplot = FALSE, verbose = FALSE,
                                               xmax = 0.03))





  f_off <- .003
  mini_data |>
    select(age_floating, value) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::bandpass(
                  ## flow = 0.00609, fhigh = 0.0121,
                  flow = 1 / 110 - f_off, fhigh = 1 / 110 + f_off,
                  win = 1,
                  demean = TRUE, detrend = TRUE,
                  xmax = 0.03)


  # all-at-once stuff that I built first
  mini_data <- smooth_ages |>
    ## filter(detrend_type == "value") |>
    ## filter(detrend_type == "lin_scl_med") |>
    filter(detrend_type != "value") |>
    filter(site == "Zumaia", proxy == "Lstar",
           depth_chunk == "full record")

  filts_age_test <- mini_data |>
    ## bandpass_filter(frequencies = my_filt_age,
    ##                 x = age_floating, y = value,
    ##                 window = bandpass_window,
    ##                 padfac = 200,
    ##                 add_depth = TRUE)
    nested_bandpass_filter(frequencies = my_filt_age,
                           x = age_floating, y = value,
                           nest = c("proxy", "site", "detrend_type", "depth_chunk"),
                           window = bandpass_window,
                           add_depth = TRUE)

  bandpass_window <- 1
  filts_age_test_1 <- mini_data |>
    nested_bandpass_filter(frequencies = my_filt_age,
                           x = age_floating, y = value,
                           nest = c("proxy", "site", "detrend_type", "depth_chunk"),
                           window = bandpass_window,
                           add_depth = TRUE)

  bandpass_window <- 2
  filts_age_test_2 <- mini_data |>
    nested_bandpass_filter(frequencies = my_filt_age,
                           x = age_floating, y = value,
                           nest = c("proxy", "site", "detrend_type", "depth_chunk"),
                           window = bandpass_window,
                           add_depth = TRUE)



  filts_age_test |>
    mutate(window = "rectangular") |>
    bind_rows(filts_age_test_1 |> mutate(window = "gaussian")) |>
    bind_rows(filts_age_test_2 |> mutate(window = "tukey")) |>
    construct_eccentricity(sign = -1, id_cols = c("age_floating", "depth", "value", "detrend_type", "window")) |>
    ggplot(aes(x = age_floating * 1e-3, y = ecc,
               colour = detrend_type,
               linetype = window)) +
    ## facet_grid(rows = vars(window)) +
    scale_x_reverse() +
    ## geom_line(aes(y = scale(value)[, 1]), alpha = .1) +
    geom_line() +
    labs(title = glue::glue("Zumaia Lstar freq_frac = {frequency_fraction}, bp win = {bandpass_window}"))
#+end_src


**** calculate bandpass filters in the time domain
:PROPERTIES:
#+begin_src R :results none
  filts_age <- smooth_ages |>
    nested_bandpass_filter(frequencies = my_filt_age,
                           x = age_floating, y = value,
                           nest = c("proxy", "site", "detrend_type", "depth_chunk"),
                           window = 1, # gaussian window
                           add_depth = TRUE)
#+end_src

**** COMMENT calculate hilbert transform of precession data in the time domain
:PROPERTIES:
:CREATED:  [2023-09-26 Tue 16:50]
:END:
I don't like this and it also doesn't preserve depth anymore.
#+begin_src R :results none
  hb_prec_age <- filts_age |>
    filter(target == "23 kyr") |>
    nest(.by = c(site, proxy, detrend_type, depth_chunk)) |>
    mutate(hb = map(data, \(d) d |>
                               select(age_floating, filter) |>
                               astrochron::hilbert(genplot = FALSE, verbose = FALSE))) |>
    unnest(hb) |>
    select(-data)
#+end_src

**** plot the data with the filters
:PROPERTIES:
:CREATED:  [2023-09-26 Tue 16:50]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_Sopelana_records_and_filters.png :width 2400 :height 1800 :res 300
  my_filter <- \(x) x |>
                      filter(detrend_type != "value") |>
                      filter(target != "23 kyr")

  filts_age |>
    my_filter() |>
    ## mutate(det = scale(value)[, 1], .by = c(site, proxy)) |>
    ggplot(aes(x = age_floating / 1e3, y = value, colour = detrend_type)) +
    facet_grid(rows = vars(proxy, depth_chunk),
               scales = "free", space = "free_x") +
    scale_x_reverse(breaks = 75 - seq(60, 75, 1),
                    minor_breaks = 75 - seq(60, 75, .1)) +
    labs(x = "Age (Ma)", y = "Normalized proxy") +

    # agemodel tie-points
    geom_vline(aes(xintercept = age_floating / 1e3), alpha = .3,
               data = agem_indep) +

    # record
    ## geom_line(aes(group = paste(detrend_type, site),
    ##               colour = "raw"), alpha = 1) +
    # filters
    geom_line(aes(y = filter + as.integer(as.factor(target)),
                  group = paste(detrend_type, site, target))) +

    ## # hilbert transform
    ## geom_line(aes(y = envelope + 3.5, group = paste(detrend_type, site)),
    ##           data = hb_prec_age |> filter(detrend_type != "value")) +

    # 405 kyr minima as points
    geom_point(aes(y = pk),
               size = 2,
               data = filts_age |>
                 my_filter() |>
                 filter(target == "405 kyr") |>
                 nest(.by = c(proxy, site, detrend_type, depth_chunk, flow, fhigh)) |>
                 mutate(pk = map(data, \(d) d |>
                                            select(age_floating, filter) |>
                                            ## mutate(filter = -filter) |> # we want minima rather than maxima
                                            astrochron::peak(genplot = FALSE, verbose = FALSE))) |>
                 unnest(pk) |>
                 rename(age_floating = Location, pk = Peak_Value) |>
                 mutate(pk = -pk))
#+end_src

#+attr_latex: :width \linewidth
#+caption: *Zumaia/Sopelana detrended records (colour represents the way in which the detrending was done, see cref:tab:detrend_types) and various bandpass filters (405 kyr and 100 kyr \pm 40% in frequency) in the time domain.* Large dots identify minima in the 405 kyr filters, which should approximately correspond to the vertical black lines for MS (minima identified in the field and tuned to 405 kyr minima in AS). These points should correspond to maxima for Lstar and d13C (between vertical lines).
#+RESULTS:
[[file:imgs/Zumaia_Sopelana_records_and_filters.png]]

**** compose an `eccentricity' curve from the data
:PROPERTIES:
:CREATED:  [2023-11-17 Fri 15:40]
:END:
#+begin_src R :results none
  data_ecc_age <- filts_age |>
    mutate(
      fracs = list(tribble( ~ comb, ~ s405, ~ s100,
                           "1:0", 1, 0,
                           "1:0.25", 1, 0.25,
                           "1:0.5", 1, 0.5,
                           "1:0.75", 1, 0.75,
                           "1:1", 1, 1,
                           "0.25:1", 0.25, 1,
                           "0.5:1", 0.5, 1,
                           "0.75:1", 0.75, 1,
                           "0:1", 0, 1
                          )),
      # the phase relationships for the different proxies
      sign_405 = case_when(proxy == "d13C" ~ -1,
                           proxy == "Lstar" ~ -1,
                           proxy == "MS" ~ 1),
      sign_100 = case_when(proxy == "d13C" ~ -1,
                           proxy == "Lstar" ~ -1,
                           proxy == "MS" ~ 1)) |>
    unnest(fracs) |>
    nest(.by = c(proxy, site, detrend_type, depth_chunk, comb, s405, s100, sign_405, sign_100)) |>
    mutate(ecc = pmap(list(data, s405, s100, sign_405, sign_100),
                      \(d, s405, s100, sign405, sign100)
                      d |>
                      construct_eccentricity(sign = sign405, weights = c(s405, s100),
                                             id_cols = c(depth, age_floating, value),
                                             f = filter))) |>
    select(-data) |>
    unnest(ecc)
    ## mutate(filter = scale(sign_405 * s405 * `405 kyr` + sign_100 * s100 * `100 kyr`)[, 1],
    ##        hilbert = scale(sign_405 * s405 * `405 kyr` + sign_100 * s100 * envelope)[, 1],
    ##        # do we want to do this by site or not?
    ##        .by = c(proxy, detrend_type, sol, comb)) |>
    ## pivot_longer(c(filter, hilbert),
    ##              names_to = "filt_env", values_to = "ecc") |>
    ## arrange(rev(site), rev(proxy), sol, detrend_type, filt_env, comb, age)
#+end_src

**** [#B] add the astronomical solution to the ecc curve and compute the RMSD
:PROPERTIES:
:CREATED:  [2023-09-26 Tue 16:51]
:END:

I've now reworked everything to work with long ecc = 405 kyr, now need to add age for K/Pg again for abs age!

#+begin_src R :results none
  data_diffs_age <- data_ecc_age |>
    ## tidylog::filter(sol == "ZB18a") |>
    ## tidylog::filter(sol == "ZB20a") |>
    ## tidylog::filter(sol == "La11") |>
    ## tidylog::filter(site == "Zumaia") |>
    ## tidylog::filter(proxy == "MS") |>
    ## tidylog::filter(comb == "1:0.5") |>
    select(-all_of(c("405 kyr", "100 kyr", "23 kyr", "s405", "s100", "sign_405", "sign_100"))) |>
    ## mutate(proxy_lag = #case_when(
    ##          ## proxy == "d13C" ~ list(seq(44, 65, 5)), # 44 to 65 kyr (Batenburg et al., 2012)
    ##          ## proxy == "MS" ~ list(seq(0, 22, 5)),
    ##          ## proxy == "Lstar" ~ list(seq(0, 22, 5)),
    ##          ## TRUE ~ list(0.))
    ##          list(seq(0, 75, 15)), .by = proxy) |>
    ## unnest(cols = c(proxy_lag)) |>
    ## mutate(lagged = age + proxy_lag) |>
    mutate(ecc_sln = case_when(
             sol == "ZB18a" ~ approx(sln$age, sln$scl,
                                     xout = age)$y,
             sol == "ZB20a" ~ approx(sln2$age, sln2$scl,
                                     xout = age)$y,
             sol == "ZB20b" ~ approx(sln2b$age, sln2b$scl,
                                     xout = age)$y,
             sol == "ZB20c" ~ approx(sln2c$age, sln2c$scl,
                                     xout = age)$y,
             sol == "ZB20d" ~ approx(sln2d$age, sln2d$scl,
                                     xout = age)$y,
             ## sol == "La11" ~ approx(sln3$age, sln3$scl,
             ##                        xout = age)$y,
             sol == "La10b" ~ approx(sln4$age, sln4$scl,
                                    xout = age)$y,
             sol == "La10c" ~ approx(sln5$age, sln5$scl,
                                    xout = age)$y,
             TRUE ~ NA_real_)) |>
    mutate(SD = (ecc_sln - ecc)^2) %>%
    assertr::verify(nrow(.) <= 6e6)

  msd_age <- data_diffs_age |>
      summarize(RMSD = sqrt(mean(SD)),
                .by = c(proxy, site, sol,
                        ## proxy_lag,
                        detrend_type, comb, ## filt_env
                        )) |>
      arrange(RMSD)
#+end_src

**** plot data ecc from filters
:PROPERTIES:
:CREATED:  [2023-10-02 Mon 16:01]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_MSD-vs-age.png :width 2400 :height 2400 :res 300
  data_ecc_age |>
    ## filter(filt_env != "hilbert") |>
    filter(detrend_type != "value") |>
    ggplot(aes(x = age_floating * 0.001, y = ecc, colour = detrend_type)) +
    facet_grid(rows = vars(proxy, depth_chunk),
               cols = vars(comb)) +
    scale_x_reverse() +
    scale_y_continuous(breaks = c(-2, 0, 2)) +
    geom_line(aes(group = paste(proxy, site, detrend_type, depth_chunk, comb))) +
    labs(x = "Age (Ma)", y = "Filtered normalized record")
#+end_src

#+caption: Artificial 405 kyr + 100 kyr filters for Zumaia/Sopelana.
#+RESULTS:
[[file:imgs/Zumaia_MSD-vs-age.png]]

**** COMMENT plot the squared difference vs age
:PROPERTIES:
:CREATED:  [2023-10-02 Mon 16:05]
:END:
For which time periods is the construction doing well and where is it failing?

#+begin_src R :results output graphics file :file imgs/Zumaia_age_MSD-overview.png :width 800
  data_diffs_age |>
    ## filter(detrend_type != "value") |>
    filter(detrend_type == "lin_scl_fine") |>
    ggplot(aes(x = age_floating * 0.001,
               y = squared_diff,
               ## colour = paste(site, proxy)
               )) +
    facet_grid(cols = vars(filt_env, comb),
               rows = vars(proxy, depth_chunk)) +
    ## geom_point() +
    ## geom_vline(xintercept = c(## kpg_age * 0.001, # based on 405 kyr minima in La11
    ##              66.043 + c(-1, 0, 1) * 0.043 # based on 40Ar/39Ar and U-Pb data from bentonites
    ##            ),
    ##            alpha = .3) +
    geom_line(aes(#colour = detrend_type,
                  group = paste(comb, filt_env, site, proxy)),
              ## linewidth = .7
              ) +
    scale_colour_viridis_d() +
    scale_x_reverse(breaks = seq(65,75,1)
                    minor_breaks = seq(65, 75, .1)) +
    labs(
      ## title = "Combinations of 405 kyr and 100 kyr filters and their MSD scores",
      x = "Age (Ma)", y = "Squared difference"## ,
      ## colour = tau~"(kyr/m) = Sedimentation rate (cm/kyr)"
    ) #+
    ## theme(legend.position = c(.1, .83))
#+end_src

#+caption: *Squared difference as a function of age* Here we vary the age of the K/T and apply the age model based on 405 kyr cycles identified in the field. The RMSD is the mean squared difference between the filtered and scaled proxy record and the filtered and scaled orbital solution.
#+RESULTS:
[[file:imgs/Zumaia_age_MSD-overview.png]]

**** which one is best?
:PROPERTIES:
:CREATED:  [2023-11-17 Fri 16:01]
:END:
#+begin_src R :results none
  best_age <- msd_age |>
    ## filter(filt_env != "hilbert") |>
    # then filter out the best for each site as well
    filter(comb == "1:1") |> # while the others score better, 1:0 doesn't make sense.
    filter(detrend_type == "lin_scl_fine") |> # this is almost always the best, let's be consistent
    tidylog::filter(
               RMSD == min(RMSD),
               .by = c(proxy,
                       ## detrend_type,
                       ## comb,
                       ## filt_env,
                       site,
                       sol)
    ) |>
    arrange(site, proxy, RMSD, sol)
#+end_src

#+begin_src R :exports both
  msd_age |>
    arrange(site, proxy, sol) |>
    select(-detrend_type, -comb)
#+end_src

#+RESULTS:
#+begin_example
# A tibble: 2,205 × 4
   proxy site     sol    RMSD
   <chr> <chr>    <chr> <dbl>
 1 Lstar Sopelana La10b  1.27
 2 Lstar Sopelana La10b  1.27
 3 Lstar Sopelana La10b  1.28
 4 Lstar Sopelana La10b  1.28
 5 Lstar Sopelana La10b  1.28
 6 Lstar Sopelana La10b  1.28
 7 Lstar Sopelana La10b  1.29
 8 Lstar Sopelana La10b  1.29
 9 Lstar Sopelana La10b  1.31
10 Lstar Sopelana La10b  1.31
# ℹ 2,195 more rows
# ℹ Use `print(n = ...)` to see more rows
#+end_example

#+begin_src R :results output graphics file :file imgs/Zumaia-RMSD-scores.png :width 2600 :height 1900 :res 300
  msd_age |>
    filter(site == "Zumaia") |>
    ## filter(proxy == "Lstar") |>
    mutate(comb = factor(comb, levels = c("1:0", "1:0.25", "1:0.5", "1:0.75",
                                          "1:1", "0.75:1", "0.5:1", "0.25:1", "0:1"))) |>
    ggplot(aes(x = sol, y = RMSD,
               colour = detrend_type,
               ## shape = comb,
               ## linetype = comb
               # TODO: visualize new combs I made
               )) +
    labs(x = "Astronomical solution", title = "Only 405 vs. Only 100") +
    facet_grid(cols = vars(comb), rows = vars(proxy)) +
    theme(axis.text.x = element_text(angle = 90, size = 7)) +
    ## scale_linetype_manual(values = c("1:1" = "solid",
    ##                                  "1:0.5" = "dashed",
    ##                                  "0.5:1" = "dotted")) +
    geom_point(size = 2) +
    geom_line(aes(group = paste(comb, detrend_type)))
#+end_src

#+attr_latex: :width \textwidth
#+caption: Overview plot of RMSD scores by applying the 405 kyr minima age model from the field (no tie-point uncertainty). Colours represent ~detrend_type~ (see cref:tab:detrend_types for explanation), columns represent different proportions of the 405 kyr component and the 100 kyr component. Rows are proxy types.
#+RESULTS:
[[file:imgs/Zumaia-RMSD-scores.png]]

**** plot the curves with the lowest overall RMSD
:PROPERTIES:
:CREATED:  [2023-11-17 Fri 16:02]
:END:

#+begin_src R :results output graphics file :file imgs/best_fits_age.png :width 2400 :height 3200 :res 300
  # this plot crashes if I plot them all
  data_diffs_age |>
    ## filter(proxy == "MS", site == "Zumaia") |>
    # filter out some of the best fits
    tidylog::inner_join(best_age) |>
    ggplot(aes(x = age / 1e3,
               group = paste(comb, ## filt_env,
                             site),
               ## colour = 1 / tau * 100, # convert from kyr/m to cm/kyr
               ## colour = kpg_age,
               ## linetype = filt_env # we plot both hilbert and filter now
               )) +
    facet_grid(rows = vars(proxy, sol)
               ## cols = vars(site),
               ## scales = "free_x", space = "free_x"
               ) +
    # plot the orbital solutions
    ## # 405 kyr filters
    ## geom_line(aes(x = age * 0.001,
    ##               y = scale(filt)[, 1],
    ##               group = sol),
    ##           inherit.aes = FALSE,
    ##           alpha = .4,
    ##           data = sln_filters |>
    ##             filter(sln != "La11") |>
    ##             filter(target == "405 kyr") |>
    ##             filter(age >= 65900, age <= 71200) |>
    ##             rename(sol = sln)) +
    # raw orbital solution
    geom_line(aes(y = ecc_sln),
              alpha = .4,
              linetype = 1) +
    # orbital solution 405 kyr minima as points
    geom_point(aes(x = age / 1e3, y = -2),
               inherit.aes = FALSE, data = agem_sol) +
    # proxy 'eccentricity' record
    geom_line(aes(y = ecc, RMSD = RMSD,
                  ## colour = sol,
                  ## alpha = RMSD,
                 ##  colour = paste("K/T age = ", kpg_age / 1000,
                 ##                 "\ntau = ", tau,
                 ##                 "\nsed. rate = ", round(1 / tau * 100, 2))
                 )) +
    # annotate RMSD for each fit
    geom_text(aes(x = age / 1e3, y = ## as.integer(as.factor(filt_env)) +
                                   2.7,
                  group = site,
                  label = round(RMSD, 3),
                  ## colour = sol
                  ),
              size = 3,
              hjust = 0, alpha = 1,
              data = data_diffs_age |>
                tidylog::inner_join(best_age) |>
                summarize(age = mean(age), RMSD = min(RMSD),
                          .by = c(## filt_env,
                                  sol, site, proxy))) +
    geom_text(aes(y = 2, #as.integer(as.factor(filt_env)),
                  group = site,
                  label = paste(## proxy_lag,
                                detrend_type, comb## , filt_env
                  )),
              hjust = 0, nudge_y = 1,
              size = 3,
              data = data_diffs_age |>
                inner_join(best_age) |>
                summarize(age = max(age),
                          .by = c(sol, site, proxy,
                                  ## proxy_lag,
                                  detrend_type, comb## , filt_env
                                  ))) +
    scale_x_reverse(breaks = 66:72, minor_breaks = seq(59.9, 73, .1)) +
    ## scale_colour_viridis_d() +
    ## scale_colour_brewer(type = "qual", guide = "none") +
    scale_alpha_continuous(range = c(1, .5)) +
    ## geom_vline(aes(xintercept = kpg_age * 0.001), colour = "red") +
    geom_vline(aes(xintercept = age1),
               colour = "red",
               data = kpg_ages |>
                  filter(sln != "La11") |>
                 rename(sol = sln)) +
    labs(x = "Age (Ma)",
         y = "Normalized filtered proxy / Normalized astronomical solution",
         ## linetype = "405:100 kyr weighing",
         ## colour = "Age of the K/T boundary",
         ## colour = "Sedimentation rate (cm/kyr)",
         colour = "",
         alpha = "RMSD\n(lower = better)",
         ## title = "Zumaia (right) and Sopelana (left) Cretaceous proxies tuned to 3 orbital solutions",
         ## subtitle = str_wrap("Root mean square deviation (RMSD, opacity and numbers above respective lines) between normalized proxy 'eccentricity' construct (coloured lines, calculated as 0.5 * normalized 405 kyr filter + normalized 100 kyr filter) and normalized orbital solution (light gray lines), after anchoring 405-kyr minima identified in the field to 405 kyr minima in each orbital solution (black dots). Normalized 405 kyr filters of orbital solutions (light gray lines) and K/T age (red line) are shown.", width = 79)
         ) +
    theme(#legend.pos = c(.0381, .95),
      legend.pos = c(.1, .9),
      legend.background = element_blank(),
      legend.key.height = unit(.2, "mm")
          ## plot.title = element_text(hjust = 0.5),
          ## plot.subtitle = element_text(hjust = 0.5)
          )
#+end_src

#+attr_latex: :width 1.2\linewidth
#+name: fig:best-age
#+caption: *Zumaia (right) and Sopelana (left) Cretaceous proxies tuned to 3 orbital solutions.*
#+caption: Root mean square deviation (RMSD, numbers above respective lines) between normalized proxy `eccentricity' construct (coloured lines, calculated as scaled sum of normalized 405 kyr filter and normalized 100 kyr filter) and normalized orbital solution (light gray lines), after anchoring 405-kyr minima identified in the field to 405 kyr minima in each orbital solution (black dots). K/T age (red line) is shown.
#+caption: For now I've also quickly added a text annotation that says which detrend_type we've done (see cref:tab:detrend_types), which combination of 405 kyr and 100 kyr filtered signals we've created.
#+RESULTS:
[[file:imgs/best_fits_age.png]]

**** COMMENT plot data and orbital solution
:PROPERTIES:
:CREATED:  [2023-09-26 Tue 16:51]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_OS-ecc-vs-age.png :width 900
  smooth_ages |>
    filter(detrend_type != "value") |>
    ggplot(aes(x = age / 1e3, y = value, colour = site, group = site)) +
    facet_grid(rows = vars(proxy,sol), scales = "free_y") +
    geom_vline(aes(xintercept = age / 1e3), data = agem_simple) +
    geom_line(aes(group = detrend_type)) +
    geom_line(aes(x = age / 1e3, y = scl),
              inherit.aes = FALSE,
              colour = "gray",
              data = sln |> bind_rows(sln2) |> bind_rows(sln3) |>
                filter(age < 71300, age > 65800) |>
                rename (sol = sln)) +
    ## geom_line(aes(y = scl), colour = "gray", inherit.aes = FALSE, data = sln) +
    ## geom_line(aes(y = `405` + `100`, colour = "1:1 filt"), data = data_ecc) +
    ## geom_line(aes(y = `405` + .5 * `100`, colour = "1:0.5 filt"), data = data_ecc) +
    ## geom_line(aes(y = `405` + 2 * envelope, colour = "1:2 filt/hilbert"), data = data_ecc) +
    ## geom_line(aes(y = `405` + envelope, colour = "1:1 filt/hilbert"), data = data_ecc) +
    ## geom_line(aes(y = `405` + 0.5 * envelope, colour = "1:0.5 filt/hilbert"), data = data_ecc) +
    ## geom_line(aes(y = envelope + 5.5, group = site), colour = "red", data = hb_age_prec) +
    scale_x_reverse() +
    labs(x = "Age (Ma)", y = "Normalized filtered proxy",
         ## title = "Zumaia raw proxy record filters"
         ## title = "Zumaia fancy detrended proxy record filters"
         )
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_OS-ecc-vs-age.png]]

**** COMMENT do the same analysis with different ages for the K/T boundary
:PROPERTIES:
:CREATED:  [2023-09-26 Tue 16:52]
:END:
This slides the whole time series along the time axis and checks the RMSD w/ respect to ZB18a.

#+begin_src R :results output graphics file :file imgs/Zumaia_time-slider.png :width 900
  data_diffs |>
    ggplot(aes(x = kpg_age * 0.001, y = squared_diff,
               paste(site, proxy, name))) +
    geom_line() +
    facet_grid(rows = vars(site, proxy), cols = vars(comb, filt_env)) +
    labs(x = "Age of the K/T boundary", y = "RMSD")
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_time-slider.png]]
*** overall variable tie-points
:PROPERTIES:
:CREATED:  [2023-12-08 Fri 10:07]
:VISIBILITY: all
:END:
Ahhh after clarification from Richard, what he recommends in stead is:
1. apply the normal 405 kyr minima tiepoint age model from the field
2. tweak the youngest tiepoint depth iteratively, then compute RMSD for the whole record
3. pick the best tiepoint error and move on
4. use the previous results and repeat from step 2

**** [#A] wrap age model
:PROPERTIES:
:CREATED:  [2023-12-08 Fri 10:08]
:END:
***** the transcluded file
#+transclude: [[file:R/wrap_age_model.R]]  :src R
***** This is the latest attempt at doing things correctly.
1. input data in depth domain and age model depth long ecc minima.
2. apply a floating long ecc agemodel
3. linearly interpolate in age domain (closest multiple of AS timestep to median timestep of data, 1.8)
4. bandpass filter the record for long and short ecc in the time domain
5. construct "ecc" curve by normalizing and adding short/long ecc filters
6. set the K/T age
7. add age_slider uncertainty (+- 200 kyr at same timestep as data)
8. calculate abs age from K/T age + floating age + age slider
9. linearly interpolate AS to record abs age (note regular grid at multiple of AS timestep should minimize error here)
10. calculate the squared difference between data ecc construct and AS ecc
11. for each age slider, summarize to calculate root mean of squared diffs
12. filter out the lowest RMSD from the age sliders
13. add tiepoint uncertainty in the depth domain:
    1. for each long ecc minimum from the field
       1. for each tiepoint depth error (\pm4 metre, higher res near field-based depth)
          1. apply the new age model to the record to get floating age
          2. linearly interpolate -> we don't want to skip this, time domain changes!
          3. bandpass filter for long and short ecc in the time domain
          4. compute "eccentricity" construct by combining the normalized filters
          5. get abs age by adding K/T age + best age slider from above to the floating age
          6. interpolate AS to the record's timesteps
          7. calculate SD for each timestep
          8. calculate SD
          9. summarize to calculate RMSD
       2. filter out the lowest RMSD score, get the best tie_error for this 405 kyr minimum
14. move on to next youngest 405 kyr minimum and repeat from step 2.

This algorithm will be a bit slower, since it has to do linear interpolation and bandpass filtering for each iteration so let's first apply it rather sparingly to only one combination of site/proxy/sol.

# it's useful to write to separate file, because then the debugger will jump from line to line :)
# so we can tangle it to there and then source
***** CANC new approach after talking to Luc
CLOSED: [2024-01-12 Fri 09:44]
:PROPERTIES:
:CREATED:  [2024-01-09 Tue 16:28]
:END:

1. apply the agemodel from the field to the detrended record
2. for the youngest 405 kyr tiepoint
   1. for each tiepoint depth error
      1. apply the new age model to the record
      2. apply a 405 and 100 kyr filter (based on general depth filter ranges determined before)
      3. interpolate orbital solution to the record's timesteps
      4. compute "eccentricity" construct by combining the normalized filters
      5. calculate SD for each timestep compared to the 405 kyr
      6. calculate SD for each timestep compared to the 100 kyr
      6. calculate SD for each timestep compared to the "eccentricity" construct
      7. calculate RMSD
   2. filter out the lowest RMSD score, get the best tie_error for this 405 kyr minimum
3. move on to next youngest 405 kyr minimum and repeat from step 2.

This is not an improvement! Typically, it is the 100-kyr cycle that forces it in a specific bin because the 405 kyr cycle isn't very strong in this record.

**** call it and debug wrap_age_model
:PROPERTIES:
:CREATED:  [2023-12-08 Fri 10:09]
:END:
***** enable debugging
:PROPERTIES:
:CREATED:  [2023-12-22 Fri 20:45]
:END:
#+begin_src R
  ## source("R/wrap_age_model.R")
  devtools::load_all()
  debug(wrap_age_model)
  undebug(wrap_age_model)
#+end_src

#+RESULTS:
***** [#A] Zumaia tests
:PROPERTIES:
:CREATED:  [2023-12-22 Fri 16:17]
:END:
:LOGBOOK:
- Note taken on [2024-01-09 Tue 17:42] \\
  adapted to Lstar and MS for new linear detrend + very wide ranges + wrap_age_model now matches solution 405 kyr filter first
:END:
#+begin_src R
  devtools::load_all()
  ## debug(wrap_age_model)
  tst1 <- data_ecc_age |>
    filter(
      proxy == "Lstar",
      detrend_type == "lin_scl_med",
      ## site == "Zumaia",
      ## depth_chunk=="depth < 109.26",
      depth_chunk == "full record",
      ## depth <= 115, # note sedrate switch from 17 m to 12 m.
      comb == "1:1") |>
    wrap_age_model(
      agemodel = agem_indep,
      astronomical_solution = slns |> filter(sln == "ZB20b"),
      proxy_phase = -1, # -1 for Lstar and d13C, +1 for MS
      eccentricity_weights = c(1, 1),
      tiepoint_uncertainty = #seq(-20, 20, 0.5),
        c(-5, -4, -3, -2, -1.8, -1.6, -1.4, -1.2, -1.0, -0.8, -0.6, -0.4, -0.2,
          0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2, 3, 4, 5),
      target_periods = c("405 kyr" = 405, "100 kyr" = 110),
      frequency_fraction = 0.2,
      bandpass_window = 1,
      ## taner_roll = 1e10,
      max_error_range = 1.6, #1.6, # 10% of 16 m 405 kyr cycle
      RMSD_threshold = 0.005,
      genplot = TRUE, output = "full")

  ## tst1 |>
    ## write_rds("out/tst1_lin-scl_MS_ZB18a.rds")
    ## write_rds("out/tst1_lin-scl_Lstar_ZB18a.rds")
  ## tst1 <-
  ##   read_rds("out/tst1_lin-scl_MS_ZB18a.rds")
  ## tst1 <-
  ##   read_rds("out/tst1_lin-scl_Lstar_ZB18a.rds")

  ## tst1 <- rolling_age_optim$the_best[[1]]
  ## tst1 <- rolling_age_optim$the_best[[2]]
  ## tst1 <- rolling_age_optim$the_best[[3]]
#+end_src


#+RESULTS:

#+begin_src R
  tst1$full |>
    select(-SD, -SD_405, -SD_100) |>
    pivot_longer(c(value, ecc_sln,
                   `405 kyr`, ecc_sln_405,
                   `100 kyr`, ecc_sln_100,
                   ecc)) |>
    ggplot(aes(x = age, y = value, colour = name)) +
    facet_grid(rows = vars(name)) +
    scale_x_reverse() +
    geom_line()


  data_ecc_age |>
    filter(proxy == "Lstar",
           detrend_type == "lin_scl", comb == "1:1", sol == "ZB18a") |>
    ggplot(aes(x = age, y = scale(value)[, 1])) +
    geom_line(colour = "purple", alpha = .6) +
    geom_line(aes(y = scale(ecc)[, 1]), data = slns |> filter(sln == "ZB18a"))
    geom_line(aes(y = scale(filter)[, 1], colour = target),
              data = sln_filters |> filter(sln == "ZB18a", target != "23 kyr")) +
      coord_cartesian(xlim = c(69.8e3, 65.5e3)) +
      labs(x = "Age (Ma)")
#+end_src

#+RESULTS:
: Warning messages:
: 1: In the_best_summary$tie_err[the_best_summary$n == tiepoint] <- tb$error :
:   number of items to replace is not a multiple of replacement length
: 2: In the_best_summary$RMSD_cum[the_best_summary$n == tiepoint] <- tb$RMSD_tie :
:   number of items to replace is not a multiple of replacement length

#+begin_src R
  # looking for better ways to find the "optimal" error
  tst1$plot +
    geom_line(aes(y = deriv),
              colour = "red",
              data = \(d) d |>
                          mutate(deriv = RMSD_tie - lag(RMSD_tie), .by = n)) +
    geom_line(aes(y = deriv_deriv), colour = "purple",
              data = \(d) d |>
                          mutate(deriv = RMSD_tie - lag(RMSD_tie), .by = n) |>
                          mutate(deriv_deriv = deriv - lag(deriv), .by = n))
#+end_src

#+RESULTS:
: Warning messages:
: 1: Removed 1 row containing missing values (`geom_line()`).
: 2: Removed 2 rows containing missing values (`geom_line()`).

#+begin_src R :results output graphics file :file imgs/Zumaia_MS_overall.png :width 2200 :height 1200 :res 300
  tst1$plot
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_MS_overall.png]]

new nice overview plot
#+begin_src R :results output graphics file :file imgs/tst1_output_plot.png :width 900 :height 500
  tst1$matched |>
    ggplot(aes(x = age * 1e-3, y = value)) +
    scale_x_reverse() +
    labs(x = "Age (Ma)", y = "Scaled Value") +
    geom_ribbon(aes(ymin = -20,
                    ymax = SD - 20),
                position = "identity", fill = "red", alpha = .7) +
    geom_line(alpha = .3) +
    geom_line(aes(y = `100 kyr`), colour = "orange") +
    geom_line(aes(y = `405 kyr`), colour = "blue") +
    geom_ribbon(aes(ymin = ecc_sln - 4, ymax = -ecc - 4),
                position = "identity", fill = "red",
                alpha = .2) +
    geom_line(aes(y = -ecc - 4), colour = "brown", linewidth = 1) +
    geom_line(aes(y = ecc_sln - 4), linewidth = 1)
#+end_src

#+RESULTS:
[[file:imgs/tst1_output_plot.png]]

***** [#A] Sopelana tests
:PROPERTIES:
:CREATED:  [2024-01-17 Wed 14:24]
:END:
#+begin_src R
  devtools::load_all()
  ## debug(wrap_age_model)
  tst2 <- data_ecc_age |>
    filter(
      proxy == "Lstar",
      detrend_type == "lin_scl_fine",
      ## site == "Sopelana",
      depth_chunk == "full record",
      ## depth <= 115, # note sedrate switch from 17 m to 12 m.
      comb == "1:1" # this doesn't deterimine it, I construct ecc below anyway.
      ) |>
    wrap_age_model(
      agemodel = agem_indep,
      astronomical_solution = slns |> filter(sln == "ZB18a"),
      proxy_phase = -1, # -1 for Lstar and d13C, +1 for MS
      eccentricity_weights = c(1, 1),
      tiepoint_uncertainty = #seq(-20, 20, 0.5),
        c(-5, -4, -3, -2, -1.8, -1.6, -1.4, -1.2, -1.0, -0.8, -0.6, -0.4, -0.2,
          0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2, 3, 4, 5),
      max_error_range = 1.6, # 10% of 16 m 405 kyr cycle
      RMSD_threshold = 0.005,
      genplot = TRUE, output = "full")

  ## tst1 |>
    ## write_rds("out/tst1_lin-scl_MS_ZB18a.rds")
    ## write_rds("out/tst1_lin-scl_Lstar_ZB18a.rds")
  ## tst1 <-
  ##   read_rds("out/tst1_lin-scl_MS_ZB18a.rds")
  ## tst1 <-
  ##   read_rds("out/tst1_lin-scl_Lstar_ZB18a.rds")

  ## tst1 <- rolling_age_optim$the_best[[1]]
  ## tst1 <- rolling_age_optim$the_best[[2]]
  ## tst1 <- rolling_age_optim$the_best[[3]]
#+end_src


#+RESULTS:

#+begin_src R :results output graphics file :file imgs/tst2.png :width 2200 :height 1200 :res 300
  tst2$plot
#+end_src

#+RESULTS:
[[file:imgs/tst2.png]]
***** COMMENT Zumaia d13C subs
#+begin_src R
  tst3 <- data_ecc |>
    filter(proxy == "d13C", detrend_type == "lin_scl_fine", comb == "1:1",
           site=="Zumaia",
           depth_chunk == "full record"
           ) |>
    wrap_age_model(
      agem_indep,
      astronomical_solution = slns |> filter(sln == "ZB18a"),
      ## tiepoint_uncertainty = seq(-2.5, 2.5, 0.5),
      genplot = TRUE, output = "full")
#+end_src

#+RESULTS:

#+begin_src R
  # looking for better ways to find the "optimal" error
  tst2$plot +
    geom_line(aes(y = deriv),
              colour = "red",
              data = \(d) d |>
                          mutate(deriv = RMSD_tie - lag(RMSD_tie), .by = n)) +
    geom_line(aes(y = deriv_deriv), colour = "purple",
              data = \(d) d |>
                          mutate(deriv = RMSD_tie - lag(RMSD_tie), .by = n) |>
                          mutate(deriv_deriv = deriv - lag(deriv), .by = n))
#+end_src

#+RESULTS:
: Warning messages:
: 1: Removed 1 row containing missing values (`geom_line()`).
: 2: Removed 2 rows containing missing values (`geom_line()`).

#+begin_src R :results output graphics file :file imgs/Zumaia_fixed_d13C_overall.png :width 2200 :height 1200 :res 300
  tst2$plot
#+end_src

#+attr_latex: :width \textwidth
#+caption: How does the RMSD evolve for the new rolling tiepoint uncertainty as we change the error on each tiepoint iteratively? (0 is the youngest tiepoint at the K/T boundary, 9 is the oldest one at the base of the Zumaia section). This is for d13C. *NOTE:* issue with tiepoints 8 and 9, which are quite close together and get lumped as close together as possible here.
#+RESULTS:
[[file:imgs/Zumaia_fixed_d13C_overall.png]]
***** COMMENT Sopelana MS ZB18a scl filter 0.5:1
#+begin_src R
  ## source("R/wrap_age_model.R")
  tst3 <- data_ecc |>
    filter(proxy == "MS",
           detrend_type == "scl",
           comb == "1:1",
           ## filt_env == "filter",
           site == "Sopelana") |>
    wrap_age_model(agem_sol |> filter(sol == "ZB18a"),
                   astronomical_solution = slns |> filter(sln == "ZB18a"),
                   genplot = TRUE, output = "full")
#+end_src

#+RESULTS:

#+begin_src R :results output graphics file :file imgs/Sopelana_fixed_MS_overall.png :width 1700 :height 1200 :res 300
  tst3$plot
#+end_src

#+caption: Second example for Sopelana MS scl 1:1 vs. ZB18a.
#+RESULTS:
[[file:imgs/Sopelana_fixed_MS_overall.png]]

***** [#A] COMMENT Zumaia MS lin_gam_det 1:1 vs La10b
#+begin_src R
  tst4 <- data_ecc |>
    filter(proxy == "MS",
           detrend_type == "lin_gam_det",
           comb == "1:1",
           ## filt_env == "filter",
           site == "Zumaia") |>
    wrap_age_model(
      agem_sol |> filter(sol == "La10b"),
      astronomical_solution = slns |> filter(sln == "La10b"),
      genplot = TRUE, output = "full")
#+end_src

#+RESULTS:

#+begin_src R :results output graphics file :file imgs/Zumaia_fixed_MS_La10b_lgd_overall_new.png :width 900 :height 400
  tst4$plot
#+end_src

#+caption: Zumaia MS lin_gam_det 1:1 vs. La10b using the new filtery approach.
#+RESULTS:
[[file:imgs/Zumaia_fixed_MS_La10b_lgd_overall_new.png]]


#+caption: Zumaia MS lin_gam_det 1:1 vs. La10b using the old squishy approach.

[[file:imgs/Zumaia_fixed_MS_La10b_lgd_overall.png]]

***** COMMENT Zumaia d13C
#+begin_src R
  ## source("R/wrap_age_model.R")
  ## debug(wrap_age_model)
  # WARNING: still slow, but slightly less so
  tst5 <-
    data_ecc |>
      filter(site == "Zumaia", proxy == "d13C", detrend_type == "gam_det", comb == "1:1"## , filt_env == "filter"
             ) |>
    wrap_age_model(
      agem_sol |> filter(sol == "ZB20a"),
      astronomical_solution = slns |> filter(sln == "ZB20a"),
      tiepoint_uncertainty = seq(-4, 4, .5), # default
      ## tiepoint_uncertainty = seq(-2, 2, .5), # smaller range
      genplot = TRUE, output = "full")
#+end_src

#+RESULTS:

#+begin_src R :results output graphics file :file imgs/Zumaia_d13C_overall_ZB20a.png :width 2400 :height 1200 :res 300
  tst5$plot
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_d13C_overall_ZB20a.png]]

see if we can plot this better/figure out how to not mess up Ma_{405}7,8
#+begin_src R
  ZC20$details |>
    ## glimpse()
    ggplot(aes(x = strat_bot + error, y = RMSD_tie)) +
    geom_vline(aes(xintercept = strat_bot), colour = "gray",
               data = ZC20$summary) +
    geom_line(aes(group = n)) +
    geom_point(aes(x = strat_bot + tie_err, y = RMSD_cum),
               colour = "red",
               data = ZC20$summary)
#+end_src

***** best range to find local minima?
:PROPERTIES:
:CREATED:  [2023-12-22 Fri 20:51]
:END:
#+begin_src R
  rng <- 2.6

  ## tst1$plot + # this seems to work
  ## tst2$plot + # this would need to be narrower for Ma405-1, but an improvement otherwise
  ## tst3$plot + # is already fine
  tst4$plot + # might fix 3 and 9?
    geom_vline(aes(xintercept=strat_bot - rng), data = agem_simple) +
    geom_vline(aes(xintercept=strat_bot + rng), data = agem_simple)
#+end_src

#+RESULTS:

***** profile
:PROPERTIES:
:CREATED:  [2023-12-19 Tue 16:40]
:END:
#+begin_src R
  pr2 <- profvis(
      data_ecc |>
        filter(site == "Zumaia", proxy == "d13C", detrend_type == "gam_det", comb == "1:1"## , filt_env == "filter"
               ) |>
      wrap_age_model(
        agem_sol |> filter(sol == "ZB18a"),
        astronomical_solution = slns |> filter(sln == "ZB18a"),
        genplot = TRUE, output = "full"))
#+end_src

#+RESULTS:

**** plot_wrap_output
:PROPERTIES:
:CREATED:  [2024-01-12 Fri 13:56]
:END:
#+begin_src R
  #' Plot the full output of wrap_age_model
  #'
  #' @param data List. Output of `wrap_age_model(output = "full")`.
  #' @param sol Character(1) Name of the Astronomical solution.
  #' @param site Character(1) Name of the site.
  #' @param sign Real(1) Vector to multiply the 405+100 kyr filter by.
  plot_wrap_output <- function(data, sol, site, sign) {
  (
    data$plot +
    labs(colour = "Tiepoint", title = paste(sol, site)) +
    coord_cartesian(xlim = c(150, 0)) +
    geom_vline(xintercept = agem_sol[agem_sol$sol == sol & agem_sol$site == site, ]$strat_bot)
  ) / (
    data$matched |>
    ggplot(aes(depth, ecc)) +
    scale_x_reverse("Depth (m)") +
    labs(y = "Normalized filter & Solution") +
    coord_cartesian(xlim = c(150, 0)) +
    geom_vline(xintercept = agem_sol[agem_sol$sol == sol & agem_sol$site == site, ]$strat_bot) +
    ## geom_line(aes(y = ecc_sln), linewidth = 2, colour = "gold") +
    geom_line(aes(y = value), colour = "gray") +
    geom_line(linewidth = 2, alpha = .8)
  ) / (
    data$matched |>
    ggplot(aes(age * 1e-3, sign * ecc)) +
    coord_cartesian(xlim = c(69.9, 65.9)) +
    scale_x_reverse("Age (Ma)") +
    labs(y = "Normalized filter & Solution") +
    geom_vline(xintercept = agem_sol[agem_sol$sol == sol & agem_sol$site == site, ]$age * 1e-3) +
    geom_line(aes(y = ecc_sln), linewidth = 2, colour = "gold") +
    ## geom_line(aes(y = scale(filter)[, 1]),
    ##           colour = "gold3", linewidth = 2,
    ##           data = sln_filters |>
    ##             filter(sln == sol) |>
    ##             filter(age > 65.7e3 & age <= 70e3) |>
    ##             filter(target == "405 kyr")) +
    geom_line(linewidth = 2, alpha = .8)
  ) +
    plot_layout(axes = "collect")
  }
#+end_src

#+RESULTS:

**** [#A] wrap_age_model for all
:PROPERTIES:
:CREATED:  [2023-12-08 Fri 14:47]
:END:
#+begin_src R :eval never
  ## devtools::build()
  ## devtools::install() # MUST install locally for furrr to work
  ## devtools::load_all() # ok that still didn't work, doing it the dumb way
  source("R/construct_eccentricity.R")
  source("R/bandpass_filter.R")
  source("R/taner_filter.R")
  source("R/wrap_age_model.R")
  plan(multisession, workers = 4) # set up 4 cores
  nw <- lubridate::now()
  message("current time: ", nw)
  mw <- function(d, s, s405, s100, sign) {
    d |>
      wrap_age_model(
        agemodel = agem_indep,
        astronomical_solution = slns |> filter(sln == s),
        proxy_phase = sign,
        tiepoint_uncertainty =
          ## c(-5, -4, -3, -2, -1.8, -1.6, -1.4, -1.2, -1.0, -0.8, -0.6, -0.4, -0.2,
          ##   0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2, 3, 4, 5),
          ## c(seq(-5, 0, 0.5), seq(0.5, 5, 0.5)),
          c(seq(-10, 0, 0.5), seq(0.5, 10, 0.5)),
        target_periods = c("405 kyr" = 405, "100 kyr" = 110),
        frequency_fraction = 0.3, # old default
        ## frequency_fraction = 0.1, # sensitivity
        ## frequency_fraction = 0.2, # sensitivity
        ## frequency_fraction = 0.25, # sensitivity -> new default
        ## frequency_fraction = 0.22, # sensitivity
        ## frequency_fraction = 0.23, # sensitivity
        ## frequency_fraction = 0.24, # sensitivity
        ## frequency_fraction = 0.245, # sensitivity
        ## bandpass_window = 0, # rectangular
        ## bandpass_window = 1, # gaussian
        bandpass_window = 999, # taner new default
        ## taner_roll = 1e10, # taner default
        ## taner_roll = 1e3, # for sensitivity
        taner_roll = 1e4, # for sensitivity
        ## taner_roll = 1e6, # for sensitivity
        ## taner_roll = 1e8, # for sensitivity
        ## taner_roll = 1e100, # for sensitivity
        ## taner_roll = 1e12, # for sensitivity
        eccentricity_weights = c(s405, s100),
        ## age_slider = 200, # default
        age_slider = 300,
        ## age_slider = 400,
        kpg_age = 65.9e3,
        max_error_range = 1.6, # ~ 10% of 16m cycle default
        ## max_error_range = 3, # way larger
        ## max_error_range = 4, # way way larger
        ## max_error_range = 5, # way way larger
        ## max_error_range = 10, # way way way larger -> crashes
        ## max_error_range = 7.5, # way way way larger
        RMSD_threshold = 0.005,
        genplot = TRUE,
        output = "full")
  }
  rolling_age_optim <-
    data_ecc_age |> # I use age because it already has sol's and combs etc.
    # the first full run for all the best-performing detrend_type
    ## filter(detrend_type == "lin_scl_fine",
    ##        comb == "1:1") |>
    # the second run, for all different detrend_types
    ## filter(detrend_type != "lin_scl_fine", proxy == "Lstar", site == "Zumaia",
           ## comb == "1:1") |>
    ## filter(detrend_type == "lin_scl_fine", proxy == "Lstar", site == "Zumaia",
    ##        comb == "1:0.5") |>
    ## filter(detrend_type == "lin_scl_fine", proxy == "Lstar", site == "Zumaia",
    ##        comb == "0.5:1") |>
    ## filter(detrend_type == "lin_scl_med", site == "Zumaia", comb == "1:1") |>
    ## filter(detrend_type == "lin_scl_med", comb == "1:1") |>
    ## filter(detrend_type == "scl", comb == "1:1") |>
    ## filter(!(site == "Zumaia" & proxy == "Lstar")) |>
    ## filter(!(site == "Zumaia" & proxy == "Lstar")) |>
    ## filter(site == "Sopelana" & proxy == "Lstar") |>
    ## filter(!detrend_type %in% c("scl", "lin_scl_med")) |>
    # the second run, which adds some of the other detrend_types for the main case
    ## filter(!detrend_type %in% c("lin_scl_fine", "gam_scl", "value"),
    ##        proxy == "Lstar", site == "Zumaia", comb == "1:1") |> # 28 more
    # the third run, which adds the highpass filter
    ## filter(detrend_type == "hp_scl",
    ##        proxy == "Lstar", site == "Zumaia", comb == "1:1") |> # 7 more
    ## filter(detrend_type == "lin_scl_fine",
           ## site == "Sopelana", comb == "1:1") |> # this adds another 14
    ## filter(detrend_type == "lin_scl_fine",
    ##        comb == "1:1", site == "Zumaia",
    ##        ## depth >= 109.26) |> # this is for the lower part with a different sedrate
    ##        depth < 109.26) |> # this is for the upper part
    filter(comb == "1:1") |> # default
    filter(proxy == "Lstar") |> # default
    ## filter(proxy != "Lstar") |>
    ## filter(proxy != "Lstar") |>
    ## filter(site == "Zumaia") |>
    ## filter(comb != "1:1") |>
    ## filter(!detrend_type %in% c("scl", "lin_scl_med")) |>
    filter(detrend_type == "lin_scl_med") |> # default
    ## filter(detrend_type == "lin_scl_fine") |> # sensitivity
    filter(depth_chunk == "full record") |> # new default
    ## filter(detrend_type == "lin_scl_fine") |>
    ## filter(detrend_type == "scl") |>
    nest(.by = c(proxy, site,
                 detrend_type, depth_chunk, comb,
                 s405, s100,
                 sign_405, sign_100)) |>
    ## slice(1:3) |>
    mutate(sol = list(target_astronomical_solutions)) |>
    unnest(sol) |>
    ## anti_join(rolling_age_optim) |>
    mutate(the_best = furrr::future_pmap(
             .l = list(d = data, s = sol, s405 = s405, s100 = s100, sign = sign_405),
             .f = mw,
             .progress = TRUE)) |>
    select(-"data") |>
    ## write_rds("out/2023-12-08_rolling_age_optim.rds") # only lin_gam_det (hilbert, 1:0.5), 20 rows
    ## write_rds("out/2023-12-08_rolling_age_optim_nld.rds") # remainder of detrend_type (no lin_gam_det, only hilbert, 1:0.5), 80 additional rows
    ## write_rds("out/2023-12-08_rolling_age_optim_combs.rds") # some additional combs
    ## write_rds("out/2023-12-08_rolling_age_optim_combs2.rds") # some additional combs
    ## write_rds("out/2023-12-22_rolling_age_optim_1-1_details.rds") # after refactor
    ## write_rds("out/2024-01-02_rolling_age_optim_1-1_details.rds") # including ZB20b-d
    ## write_rds("out/2024-01-12_rolling_age_optim_full.rds") # after making it a package
    ## write_rds("out/2024-01-12_rolling_age_optim_Zumaia_Lstar_detrend_types.rds") # more detrend types, only for 1:1 Lstar
    ## write_rds("out/2024-01-12_rolling_age_optim_Zumaia_Lstar_hp.rds") # add highpass for 1:1 Lstar
    ## write_rds("out/2024-01-17_rolling_age_optim_Sopelana_Lstar_lin-scl-fine.rds") # add Sopelana Lstar lin_scl_fine
    ## write_rds("out/2024-01-19_rolling_age_optim_Zumaia_lin-scl-fine_lower.rds") # different sedrate for this interval, same filters b/c time domain
    ## write_rds("out/2024-01-19_rolling_age_optim_Zumaia_lin-scl-fine_upper.rds") # upper part
    ## write_rds("out/2024-02-14_rolling_age_optim_full_indep.rds") # independent from AS, using floating age and sliding along K/T age
    ## write_rds("out/2024-02-14_rolling_age_optim_full_indep_detrend.rds") # all additional detrend_types
    ## write_rds("out/2024-02-15_rolling_age_optim_comb.rds") # all additional detrend_types
    ## write_rds("out/2024-02-15_rolling_age_optim_comb_0.5-1.rds") # all additional detrend_types
    ## write_rds("out/2024-02-15_rolling_age_optim_lin-scl-med.rds")
    ## write_rds("out/2024-02-21_rolling_age_optim_lin-scl-med_sopelana.rds")
    ## write_rds("out/2024-02-21_rolling_age_optim_lin-scl-med_gaussian.rds")
    ## write_rds("out/2024-02-21_rolling_age_optim_scl_gaussian.rds")
    ## write_rds("out/2024-02-21_rolling_age_optim_scl_rectangular_addition.rds")
    ## write_rds("out/2024-02-21_rolling_age_optim_scl_rectangular_addition.rds")
    ## SOMEDAY write_rds("out/2024-02-21_rolling_age_optim_all_rectangular_addition.rds")
    ## write_rds("out/2024-02-21_rolling_age_optim_all_Sopelana_rectangular.rds")
    ## write_rds("out/2024-02-21_rolling_age_optim_all_Sopelana_gaussian.rds")
    ## write_rds("out/2024-02-24_rolling_age_optim_all_remainder_gaussian.rds")
    ## write_rds("out/2024-02-24_rolling_age_optim_all_remainder_rectangular.rds")
    ## write_rds("out/2024-02-25_rolling_age_optim_all_Lstar_detrend-types_rectangular.rds")
    ## write_rds("out/2024-02-25_rolling_age_optim_all_Lstar_detrend-types_rectangular.rds")
    ## write_rds("out/2024-03-21_rolling_age_optim_all_other-proxies_one-type_taner.rds")
    ## write_rds("out/2024-03-21_rolling_age_optim_Lstar_scl_taner.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e3.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-fine_taner.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e6.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e12.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e8.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e100.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-fine_taner.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.1.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.2.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.22.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_gauss_narrow-0.22.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.23.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.24.rds")
    ## write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.245.rds")
    ## write_rds("out/2024-03-28_rolling_age_optim_Lstar_lin-scl-med_gauss.rds")
    ## write_rds("out/2024-03-28_rolling_age_optim_Lstar_lin-scl-med_gauss_2x.rds")
    ## write_rds("out/2024-03-28_rolling_age_optim_Lstar_lin-scl-med_gauss_3x.rds")
    ## write_rds("out/2024-03-28_rolling_age_optim_Lstar_lin-scl-med_gauss_narrow-0.25_3x.rds")
    ## write_rds("out/2024-03-28_rolling_age_optim_d13C-MS_lin-scl-med_gauss_narrow-0.25_3x.rds")
    ## write_rds("out/2024-03-28_rolling_age_optim_d13C_MS_lin-scl-med_taner_narrow-0.25.rds")
    ## write_rds("out/2024-04-08_rolling_age_optim_d13C_MS_Lstar_lin-scl-med_taner_narrow-0.25_all-comb.rds")
    ## write_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_large-tie-error_slide-300.rds")
    ## write_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_large-tie-error_slide-200.rds")
    ## write_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error4_slide-200.rds")
    ## write_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error5_slide-300.rds")
    ## write_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error10_slide-300.rds")
    ## write_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error10f_slide-300.rds") -> failed
    ## write_rds("out/2024-04-21_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error7.5_slide-300.rds")
    ## write_rds("out/2024-05-06_rolling_age_optim_Lstar_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300.rds")
    ## write_rds("out/2024-05-06_rolling_age_optim_d13C-MS_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300.rds")
    ## write_rds("out/2024-05-07_rolling_age_optim_Lstar-d13C-MS_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300.rds")
    ## write_rds("out/2024-05-07_rolling_age_optim_Lstar-d13C-MS_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300_tweak.rds") # 2.1227x (new value found after playing around with sim)
    # a few of the previous results where I messed around with frequency_fraction were WRONG! Overwriting the one from today
    ## write_rds("out/2024-05-08_rolling_age_optim_Lstar-d13C-MS_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300_alpha5.rds") # 2.1227x (new value found after playing around with sim)
    ## write_rds("out/2024-05-08_rolling_age_optim_all_Lstar-d13C-MS_rectangular_0.25.rds") # redo rect
    ## write_rds("out/2024-05-09_rolling_age_optim_Lstar-d13C-MS_lin-scl-med_gauss_0.3_tie-error-1.6_slide-300_alpha5.rds") # 2.1227x shit the rect and all the taner filters are at 0.3 not at 0.25
    write_rds("out/2024-05-09_rolling_age_optim_Lstar_lin-scl-med_taner_1e4.rds")
  message("current time: ", lubridate::now())
  message("duration: ", round(lubridate::now() - nw, 2))
  ## rm(wrap_age_model) # rm so we can get back the one from the package
  ## rm(taner_filter) # rm so we can get back the one from the package
  ## rm(bandpass_filter)
  ## rm(construct_eccentricity)
#+end_src

current time: 2023-12-22 22:26:18.565137
current time: 2023-12-22 22:49:15.228392
ah so ~23 minutes total!

current time: 2024-01-02 15:28:17.623498
current time: 2024-01-02 15:59:42.869229
~31 minutes

current time: 2024-01-12 11:49:01.819418
current time: 2024-01-12 13:15:41.2829
this is 315 rows rather than 100, and saves way more results. so might be quite a bit slower/bigger.
whew, total of 1:26 hours! :O

new run with only 21 rows, different detrend_types for Zumaia Lstar comb 1:1 for all solutions.
current time: 2024-01-12 15:31:47.010587
current time: 2024-01-12 15:47:51.137767
about 16 minutes.

added another 7 sims for the highpass filter

and another 10 for the Sopelana runs after fixing the ~matched~ output
current time: 2024-01-17 15:37:52.284324
current time: 2024-01-17 15:40:28.043286

add another 21 sims for Zumaia lin_scl_fine all proxies at depth >= 109.26 b/c different sedimentation rate
current time: 2024-01-19 11:54:41.574574
current time: 2024-01-19 11:56:54.211265

redid the whole thing after major revision of the algorithm
current time: 2024-02-14 13:37:36.143642
current time: 2024-02-14 14:11:12.126742

add detrend_types for Zumaia Lstar
current time: 2024-02-14 14:49:05.541456
current time: 2024-02-14 15:53:28.545184

add some Zumaia 1:0.5 combs to show how they differ?
current time: 2024-02-15 11:44:00.003439
current time: 2024-02-15 11:59:07.462499

add Zumaia 0.5:1 for combleteness?
current time: 2024-02-15 13:19:16.268525
current time: 2024-02-15 13:32:25.06223

.. some more that I didn't write down

out/2024-02-21_rolling_age_optim_lin-scl-med_sopelana.rds

all lin_scl_med 1:1 combs for both sites, now with gaussian bandpass filter windows.
out/2024-02-21_rolling_age_optim_lin-scl-med_gaussian.rds
current time: 2024-02-21 14:32:43.678088
current time: 2024-02-21 15:15:38.131599

out/2024-02-21_rolling_age_optim_scl_gaussian.rds
current time: 2024-02-21 15:51:12.456357
current time: 2024-02-21 16:31:49.176135

adding all the other proxies and depth_chunks with rectangular window for scl
out/2024-02-21_rolling_age_optim_scl_rectangular_addition.rds
current time: 2024-02-21 16:40:54.723448
current time: 2024-02-21 17:04:18.265115

out/2024-02-21_rolling_age_optim_all_Sopelana_rectangular.rds
current time: 2024-02-21 17:22:54.669639
current time: 2024-02-21 17:37:30.798659

out/2024-02-21_rolling_age_optim_all_Sopelana_gaussian.rds
current time: 2024-02-21 17:38:51.230929
-- put laptop to sleep
finished after

I used anti_join to find the rows I hadn't done yet, 245 rows
out/2024-02-21_rolling_age_optim_all_remainder_gaussian.rds
current time: 2024-02-24 15:13:23.862064
-- crash and restart
current time: 2024-02-24 18:59:27.583944

out/2024-02-21_rolling_age_optim_all_remainder_rectangular.rds
current time: 2024-02-24 21:19:54.827457
-- crash
restart current time: 2024-02-24 23:20:43.677337
current time: 2024-02-25 00:46:06.913805

out/2024-02-25_rolling_age_optim_all_Lstar_detrend-types_rectangular.rds
current time: 2024-02-25 11:53:47.724441
current time: 2024-02-25 12:49:15.223617

out/2024-03-21_rolling_age_optim_all_Lstar_one-type_taner.rds
current time: 2024-03-21 15:16:48.231657
current time: 2024-03-21 15:36:10.811143
20 minutes for all of that

so expect 40 minutes for the remainder of proxies

write_rds("out/2024-03-21_rolling_age_optim_all_other-proxies_one-type_taner.rds")
> current time: 2024-03-21 16:51:29.667351
> current time: 2024-03-21 17:15:04.751889

I wanted to see how the taner filter behaves on the raw data
write_rds("out/2024-03-21_rolling_age_optim_Lstar_scl_taner.rds")
> current time: 2024-03-25 10:25:42.58027
> current time: 2024-03-25 10:40:41.550386

write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e3.rds")
> current time: 2024-03-27 10:47:49.047946
> current time: 2024-03-27 11:05:19.495115

write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-fine_taner.rds")
> current time: 2024-03-27 11:10:40.794065
> current time: 2024-03-27 11:25:06.879896

note that I also limited this one to only depth_chunk == full record
write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e6.rds")
> current time: 2024-03-27 11:50:24.519551
> current time: 2024-03-27 12:00:03.291885

write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e12.rds")
> current time: 2024-03-27 13:55:22.262323
> current time: 2024-03-27 14:05:07.991531

write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e8.rds")
> current time: 2024-03-27 14:09:41.44469
> current time: 2024-03-27 14:22:57.205202

near-rectangular
write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e100.rds")
> current time: 2024-03-27 15:46:07.169938
> current time: 2024-03-27 15:55:53.183246

was I wrong to switch from lin_scl_fine to lin_scl_med? -> No, it's same pattern, slightly worse scores for ZB20b and ZB20c, slightly better for La10c and ZB18a
well within bootstrapped uncertainties
write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-fine_taner.rds")
> current time: 2024-03-27 17:53:31.175274
> current time: 2024-03-27 18:02:57.783143

what if my filters are just too wide?
write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.1.rds")
> current time: 2024-03-27 18:24:53.102549
> current time: 2024-03-27 18:34:25.361577

write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.2.rds")
> current time: 2024-03-27 18:47:54.281992
> current time: 2024-03-27 19:35:43.329698

this makes ZB18a the best

write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25.rds")
> current time: 2024-03-27 20:52:55.667946
> current time: 2024-03-27 21:00:11.768722
> duration: 7.27

above is almost identical to 0.3, but slightly better overall

write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.22.rds")
> current time: 2024-03-27 21:06:45.1201
> current time: 2024-03-27 21:14:14.969444
> duration: 7.5

write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_gauss_narrow-0.22.rds")
> current time: 2024-03-27 22:21:04.636116
> current time: 2024-03-27 22:28:43.671436
> duration: 7.65


write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.23.rds")
> current time: 2024-03-27 22:45:16.250716
> current time: 2024-03-27 22:52:52.755793
> duration: 7.61

write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.24.rds")
> current time: 2024-03-27 22:57:29.267337
> current time: 2024-03-27 23:05:01.12837
> duration: 7.53

write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.245.rds")
> current time: 2024-03-27 23:08:27.725414
> current time: 2024-03-27 23:16:01.02046
> duration: 7.55

write_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_gauss_narrow-0.25.rds")
> current time: 2024-03-27 23:40:37.241927
> current time: 2024-03-27 23:47:54.894761
> duration: 7.29

write_rds("out/2024-03-28_rolling_age_optim_Lstar_lin-scl-med_gauss.rds")
> current time: 2024-03-28 10:34:15.21319
> current time: 2024-03-28 10:48:10.330067
> duration: 13.92

write_rds("out/2024-03-28_rolling_age_optim_Lstar_lin-scl-med_gauss_2x.rds")
> current time: 2024-03-28 11:40:52.386071
> current time: 2024-03-28 11:51:41.623894
> duration: 10.82


write_rds("out/2024-03-28_rolling_age_optim_Lstar_lin-scl-med_gauss_3x.rds")
> current time: 2024-03-28 13:45:33.133161
> current time: 2024-03-28 13:57:51.903795
> duration: 12.31


write_rds("out/2024-03-28_rolling_age_optim_Lstar_lin-scl-med_gauss_narrow-0.25_3x.rds")
> current time: 2024-03-28 14:39:23.519434
> current time: 2024-03-28 14:48:21.607654
> duration: 8.97

write_rds("out/2024-03-28_rolling_age_optim_d13C-MS_lin-scl-med_gauss_narrow-0.25_3x.rds")
> current time: 2024-03-28 16:34:01.319319
> current time: 2024-03-28 16:46:11.94088
> duration: 12.18

write_rds("out/2024-03-28_rolling_age_optim_d13C_MS_lin-scl-med_taner_narrow-0.25.rds")
> current time: 2024-03-28 17:27:02.656529
> current time: 2024-03-28 17:41:35.271726
> duration: 14.54

write_rds("out/2024-04-08_rolling_age_optim_d13C_MS_Lstar_lin-scl-med_taner_narrow-0.25_all-comb.rds")
> current time: 2024-04-08 15:35:01.913837
fail, removed comb 1:1
> current time: 2024-04-15 11:49:46.500872
> current time: 2024-04-15 14:28:34.353611
> duration: 2.65 hours

write_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_large-tie-error.rds") 3 m
> current time: 2024-04-18 12:56:17.903647
> current time: 2024-04-18 13:04:45.365039
> duration: 8.46
don't load this one, it will collide with the default of 1.6 m
also, it definitely shifted some stuff around by more than 400 kyr
write_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_large-tie-error_slide-300.rds")
> current time: 2024-04-18 13:28:01.93302
> current time: 2024-04-18 13:38:15.995121
> duration: 10.23

write_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_large-tie-error_slide-200.rds")
> current time: 2024-04-18 13:40:12.004125
> current time: 2024-04-18 13:50:34.890714
> duration: 10.38

write_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error4_slide-200.rds")
> current time: 2024-04-18 14:12:27.414634
> current time: 2024-04-18 14:20:40.585779
> duration: 8.22

this might take a bit longer, many tie-errors
write_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error5_slide-300.rds")
> current time: 2024-04-19 17:31:16.717029
> current time: 2024-04-19 17:42:47.689047
> duration: 11.52
write_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error10_slide-300.rds")
> current time: 2024-04-21 12:13:12.668745
> current time: 2024-04-21 12:32:37.521443
> duration: 19.41

write_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error10f_slide-300.rds")
> current time: 2024-04-21 12:39:27.650907
Caused by error in `mutate()` at R/taner_filter.R:7:3:
ℹ In argument: `lt = purrr::map(...)`.
looks like it selected overlapping tiepoints here
> current time: 2024-04-21 12:52:09.533604
> duration: 12.7

write_rds("out/2024-04-21_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error7.5_slide-300.rds")
> current time: 2024-04-21 14:28:53.658001
> current time: 2024-04-21 14:48:51.09094
> duration: 19.96

this is after revising the gaussian rescaling within the wrap_age_model function! from a factor of 3 to 2.
write_rds("out/2024-05-06_rolling_age_optim_Lstar_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300.rds")
> current time: 2024-05-06 16:08:55.319355 -- this was with 2x
> current time: 2024-05-06 16:54:46.554988 -- this was with 1.96 x (but the real number)
> current time: 2024-05-06 17:06:22.763287
> duration: 11.6
> current time: 2024-05-06 17:25:12.768384 -- too soon, it must be 1.5x
> current time: 2024-05-06 17:38:09.749078
> duration: 12.95

write_rds("out/2024-05-06_rolling_age_optim_d13C-MS_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300.rds")
> current time: 2024-05-06 21:44:25.433238
> current time: 2024-05-06 21:59:42.593299
> duration: 15.29

mess around with the gaussian scaling width so it matches the taner 1e4 filter.
write_rds("out/2024-05-07_rolling_age_optim_Lstar-d13C-MS_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300.rds")
> current time: 2024-05-07 13:44:40.418748
> current time: 2024-05-07 14:11:47.42014
> duration: 27.12

write_rds("out/2024-05-07_rolling_age_optim_Lstar-d13C-MS_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300_tweak.rds") # 2.1227x (new value found after playing around with sim)
> current time: 2024-05-07 17:06:55.311298
> current time: 2024-05-07 17:35:25.45052
> duration: 28.5

write_rds("out/2024-05-08_rolling_age_optim_Lstar-d13C-MS_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300_alpha5.rds") # 2.1227x (new value found after playing around with sim)
> current time: 2024-05-08 14:35:12.4611
> current time: 2024-05-08 14:59:29.666715
> duration: 24.29
whoops frequency_fraction was OFFFF redoing it! 3x was still OK
> current time: 2024-05-08 15:42:59.393914
> current time: 2024-05-08 16:07:51.436514
> duration: 24.87

seems like I don't have a rect with 0.25 frac yet
write_rds("out/2024-05-08_rolling_age_optim_all_Lstar-d13C-MS_rectangular_0.25.rds") # redo rect
> current time: 2024-05-08 16:25:40.820305
> current time: 2024-05-08 16:48:27.987701
> duration: 22.79

whoops the taner filter sensitivity is at 0.3 not 0.25
write_rds("out/2024-05-09_rolling_age_optim_Lstar-d13C-MS_lin-scl-med_gauss_0.3_tie-error-1.6_slide-300_alpha5.rds") # 2.1227x shit the rect and all the taner filters are at 0.3 not at 0.25
> current time: 2024-05-09 10:26:10.92991
> current time: 2024-05-09 10:51:50.39291
> duration: 25.66

I wanted to verify that rescaled gauss is similar to taner roll 1e4: note only Lstar
write_rds("out/2024-05-09_rolling_age_optim_Lstar_lin-scl-med_taner_1e4.rds")
-> shit I broke the taner_filter function
maybe now I fixed it?
> current time: 2024-05-09 17:19:16.027822
try again after tweaking taner_filter func
> current time: 2024-05-10 10:28:36.350382
and some more tweaking
> current time: 2024-05-10 10:36:29.262773
ok now?
> current time: 2024-05-10 10:40:24.708112
> current time: 2024-05-10 10:54:13.249264
> duration: 13.81

**** [#B] load cached results
:PROPERTIES:
:CREATED:  [2023-12-12 Tue 10:59]
:END:
***** COMMENT old
#+begin_src R :eval never
  # I ran this in some smaller batches in order of importance
  rolling_age_optim_old <- bind_rows(
    read_rds("out/2023-12-08_rolling_age_optim.rds"),
    read_rds("out/2023-12-08_rolling_age_optim_nld.rds"),
    read_rds("out/2023-12-08_rolling_age_optim_combs.rds"),
    read_rds("out/2023-12-08_rolling_age_optim_combs2.rds"),
  )
#+end_src

#+RESULTS:

***** COMMENT second old
#+begin_src R :eval never
  rolling_age_optim <-
    #read_rds("out/2023-12-22_rolling_age_optim_1-1_details.rds")
    ## read_rds("out/2024-01-02_rolling_age_optim_1-1_details.rds") # including ZB20b-d
    bind_rows(

      read_rds("out/2024-01-12_rolling_age_optim_full.rds") |>
      # filter out these runs because they have NA matched entries
      filter(site != "Sopelana") |>
      mutate(date = lubridate::ymd("2024-01-12"),
             exp = "all after package"),
     read_rds("out/2024-01-12_rolling_age_optim_Zumaia_Lstar_detrend_types.rds") |>
     mutate(date = lubridate::ymd("2024-01-12"),
            exp = "Zumaia Lstar detrend types 1:1"),
     read_rds("out/2024-01-12_rolling_age_optim_Zumaia_Lstar_hp.rds") |>
     mutate(date = lubridate::ymd("2024-01-12"),
            exp = "Zumaia Lstar subtract lowpass 1:1"),
     read_rds("out/2024-01-17_rolling_age_optim_Sopelana_Lstar_lin-scl-fine.rds") |>
     mutate(date = lubridate::ymd("2024-01-17"),
            exp = "Sopelana Lstar lin_scl_fine 1:1"),

     read_rds("out/2024-01-19_rolling_age_optim_Zumaia_lin-scl-fine_lower.rds") |>
     mutate(date = lubridate::ymd("2024-01-19"),
            exp = "Zumaia lin_scl_fine lower-portion 1:1"),

     read_rds("out/2024-01-19_rolling_age_optim_Zumaia_lin-scl-fine_upper.rds") |>
     mutate(date = lubridate::ymd("2024-01-19"),
            exp = "Zumaia lin_scl_fine upper-portion 1:1"),
    ) |>

    # I renamed these
    mutate(detrend_type = ifelse(detrend_type == "lin_scl_old",
                                 "lin_scl_rw",
                                 detrend_type))
#+end_src

#+RESULTS:

***** rolling_age_optim_old: gaussian and rectangular filters
#+begin_src R
  ## gauss_corr <- 1 / 1.5 # the gaussian filters reflect the full range, so if I want to make a fair
  # comparison to rectangular and taner filters,
  # I should narrow the frac by a factor of 1.5 to arrive at the edges of the 95% CI

  gauss_corr <- 1 / 2.1227 # this will scale it so it's similar to a taner filter with roll of ~1e5
  rolling_age_optim_old <-
    # first read all the rectangular filtered output
    bind_rows(
      read_rds("out/2024-02-14_rolling_age_optim_full_indep.rds") |> mutate(date = ymd("2024-02-14"), .before = "proxy"),
      read_rds("out/2024-02-14_rolling_age_optim_full_indep_detrend.rds") |> mutate(date = ymd("2024-02-14"), .before = "proxy"),
      read_rds("out/2024-02-15_rolling_age_optim_comb.rds") |> mutate(date = ymd("2024-02-15"), .before = "proxy"), # 1:0.5
      read_rds("out/2024-02-15_rolling_age_optim_comb_0.5-1.rds") |> mutate(date = ymd("2024-02-15"), .before = "proxy"),
      read_rds("out/2024-02-15_rolling_age_optim_lin-scl-med.rds") |> mutate(date = ymd("2024-02-15"), .before = "proxy"),
      read_rds("out/2024-02-21_rolling_age_optim_lin-scl-med_sopelana.rds") |> mutate(date = ymd("2024-02-21"), .before = "proxy"),
      read_rds("out/2024-02-21_rolling_age_optim_scl_rectangular_addition.rds") |> mutate(date = ymd("2024-02-21"), .before = "proxy"),
      read_rds("out/2024-02-21_rolling_age_optim_all_Sopelana_rectangular.rds") |> mutate(date = ymd("2024-02-21"), .before = "proxy"),
      read_rds("out/2024-02-24_rolling_age_optim_all_remainder_rectangular.rds") |> mutate(date = ymd("2024-02-24"), .before = "proxy"),
      read_rds("out/2024-02-25_rolling_age_optim_all_Lstar_detrend-types_rectangular.rds") |> mutate(date = ymd("2024-02-25"), .before = "proxy"),
      ) |>
    mutate(window = "rectangular", frac = 0.3) |>
    bind_rows(
      read_rds("out/2024-05-08_rolling_age_optim_all_Lstar-d13C-MS_rectangular_0.25.rds") |> mutate(date = ymd("2024-05-08"), .before = "proxy") |>
        mutate(window = "rectangular", frac = 0.25)
    ) |>
    # then read all the gauss filtered output
    bind_rows(
      bind_rows(
        # frac as the astrochron::bandpass(win = 1) gets it! different from all the others
        read_rds("out/2024-02-21_rolling_age_optim_lin-scl-med_gaussian.rds") |> mutate(frac = 0.3 * gauss_corr) |> mutate(date = ymd("2024-02-21"), .before = "proxy"),
        read_rds("out/2024-02-21_rolling_age_optim_scl_gaussian.rds") |> mutate(frac = 0.3 * gauss_corr) |> mutate(date = ymd("2024-02-21"), .before = "proxy"),
        read_rds("out/2024-02-21_rolling_age_optim_all_Sopelana_gaussian.rds") |> mutate(frac = 0.3 * gauss_corr) |> mutate(date = ymd("2024-02-21"), .before = "proxy"),
        read_rds("out/2024-02-24_rolling_age_optim_all_remainder_gaussian.rds") |> mutate(frac = 0.3 * gauss_corr) |> mutate(date = ymd("2024-02-24"), .before = "proxy"),
        ## read_rds("out/2024-02-25_rolling_age_optim_all_Lstar_detrend-types_rectangular.rds"), # this was here before! :O moved up
        read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_gauss_narrow-0.22.rds") |> mutate(frac = 0.22 * gauss_corr) |> mutate(date = ymd("2024-03-27"), .before = "proxy"), # I don't recall if this was tweaked already or not...
        read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_gauss_narrow-0.25.rds") |> mutate(frac = 0.25 * gauss_corr) |> mutate(date = ymd("2024-03-27"), .before = "proxy"),
        read_rds("out/2024-03-28_rolling_age_optim_Lstar_lin-scl-med_gauss.rds") |> mutate(frac = 0.3 * 0.5 * gauss_corr) |> mutate(date = ymd("2024-03-28"), .before = "proxy"), # I think this was accidentally at 0.5x because I had my logic reversed
        read_rds("out/2024-03-28_rolling_age_optim_Lstar_lin-scl-med_gauss_2x.rds") |> mutate(frac = 0.3 * 2 * gauss_corr) |> mutate(date = ymd("2024-03-28"), .before = "proxy"), # this was for sure at 2x
        read_rds("out/2024-03-28_rolling_age_optim_Lstar_lin-scl-med_gauss_3x.rds") |> mutate(frac = 0.3 * 3 * gauss_corr) |> mutate(date = ymd("2024-03-28"), .before = "proxy"), # I think 3x is the key!
        read_rds("out/2024-03-28_rolling_age_optim_Lstar_lin-scl-med_gauss_narrow-0.25_3x.rds") |> mutate(frac = 0.25 * 3 * gauss_corr) |> mutate(date = ymd("2024-03-28"), .before = "proxy"), # still 3x
        read_rds("out/2024-03-28_rolling_age_optim_d13C-MS_lin-scl-med_gauss_narrow-0.25_3x.rds") |> mutate(frac = 0.25 * 3 * gauss_corr) |> mutate(date = ymd("2024-03-28"), .before = "proxy"), # still 3x
        # ignoring the below since they are WRONG
        ## read_rds("out/2024-05-06_rolling_age_optim_Lstar_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300.rds") |> mutate(frac = 0.25 * 1.5 * gauss_corr) |> mutate(date = ymd("2024-05-06"), .before = "proxy"), # scaled by 1.5x
        ## read_rds("out/2024-05-06_rolling_age_optim_d13C-MS_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300.rds") |> mutate(frac = 0.25 * 1.5 * gauss_corr) |> mutate(date = ymd("2024-05-06"), .before = "proxy"), # 1.5x
        ## read_rds("out/2024-05-07_rolling_age_optim_Lstar-d13C-MS_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300.rds") |> mutate(frac = 0.25 * 2.15 * gauss_corr) |> mutate(date = ymd("2024-05-07"), .before = "proxy"), # 2.15x
        ## read_rds("out/2024-05-07_rolling_age_optim_Lstar-d13C-MS_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300_tweak.rds") |> mutate(frac = 0.25 * 2.1227 * gauss_corr) |> mutate(date = ymd("2024-05-07"), .before = "proxy"), # 2.1227x (new value found after playing around with sim)
        read_rds("out/2024-05-08_rolling_age_optim_Lstar-d13C-MS_lin-scl-med_gauss_0.25_tie-error-1.6_slide-300_alpha5.rds") |> mutate(frac = 0.25) |> mutate(date = ymd("2024-05-08"), .before = "proxy"), # notice no gauss corr b/c I don't know how to do this
        read_rds("out/2024-05-09_rolling_age_optim_Lstar-d13C-MS_lin-scl-med_gauss_0.3_tie-error-1.6_slide-300_alpha5.rds") |> mutate(frac = 0.3) |> mutate(date = ymd("2024-05-09"), .before = "proxy"),
      ) |>
      mutate(window = "gaussian")) |>
    # turn into factors so that plotting is in the correct order
    mutate(detrend_type = as_factor(detrend_type) |>
             fct_relevel(names(detrend_colours))) |>
    mutate(comb = as_factor(comb) |>
             fct_relevel(c("1:0", "1:0.25", "1:0.5", "1:0.75",
                           "1:1", "0.75:1", "0.5:1", "0.25:1", "0:1"))) |>
    mutate(depth_chunk = as_factor(depth_chunk) |>
             fct_relevel(c("full record", "depth >= 109.26", "depth < 109.26"))) |>
    mutate(window = as_factor(window) |> fct_relevel(c("rectangular", "gaussian", "taner")))
#+end_src

#+RESULTS:
: Warning messages:
: 1: There was 1 warning in `mutate()`.
: ℹ In argument: `comb = fct_relevel(...)`.
: Caused by warning:
: ! 6 unknown levels in `f`: 1:0, 1:0.25, 1:0.75, 0.75:1, 0.25:1, and 0:1
: 2: There was 1 warning in `mutate()`.
: ℹ In argument: `window = fct_relevel(as_factor(window), c("rectangular", "gaussian", "taner"))`.
: Caused by warning:
: ! 1 unknown level in `f`: taner

***** rolling_age_optim: taner filters
new runs after changing to a taner filter currently with roll = 1e10.
#+begin_src R :results none
  rolling_age_optim <-
    bind_rows(
      read_rds("out/2024-03-21_rolling_age_optim_all_Lstar_one-type_taner.rds") |> mutate(date = ymd("2024-03-21"), roll = 1e10),
      read_rds("out/2024-03-21_rolling_age_optim_all_other-proxies_one-type_taner.rds") |> mutate(date = ymd("2024-03-21"), roll = 1e10),
      read_rds("out/2024-03-21_rolling_age_optim_Lstar_scl_taner.rds") |> mutate(date = ymd("2024-03-21"), roll = 1e10),
      read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e3.rds") |> mutate(date = ymd("2024-03-27"), roll = 1e3),
      read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-fine_taner.rds") |> mutate(date = ymd("2024-03-27"), roll = 1e10),
      read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e6.rds") |> mutate(date = ymd("2024-03-27"), roll = 1e6),
      read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e12.rds") |> mutate(date = ymd("2024-03-27"), roll = 1e12),
      read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e8.rds") |> mutate(date = ymd("2024-03-27"), roll = 1e8),
      read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_1e100.rds") |> mutate(date = ymd("2024-03-27"), roll = 1e100),
      read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-fine_taner.rds") |> mutate(date = ymd("2024-03-27"), roll = 1e10)) |>
    mutate(frac = 0.3) |>
    bind_rows(
      read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.1.rds") |> mutate(date = ymd("2024-03-27"), roll = 1e10, frac = 0.1),
      read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.2.rds") |> mutate(date = ymd("2024-03-27"), roll = 1e10, frac = 0.2),
      read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25.rds") |> mutate(date = ymd("2024-03-27"), roll = 1e10, frac = 0.25),
      read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.22.rds") |> mutate(date = ymd("2024-03-27"), roll = 1e10, frac = 0.22),
      read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.23.rds") |> mutate(date = ymd("2024-03-27"), roll = 1e10, frac = 0.23),
      read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.24.rds") |> mutate(date = ymd("2024-03-27"), roll = 1e10, frac = 0.24),
      ## read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.245.rds") |> mutate(roll = 1e10, frac = 0.245), # this might be excessive
      read_rds("out/2024-03-28_rolling_age_optim_d13C_MS_lin-scl-med_taner_narrow-0.25.rds") |> mutate(date = ymd("2024-03-28"), roll = 1e10, frac = 0.25),
      read_rds("out/2024-04-08_rolling_age_optim_d13C_MS_Lstar_lin-scl-med_taner_narrow-0.25_all-comb.rds") |> mutate(date = ymd("2024-03-28"), roll = 1e10, frac = 0.25),
      read_rds("out/2024-05-09_rolling_age_optim_Lstar_lin-scl-med_taner_1e4.rds") |> mutate(date = ymd("2024-03-28"), roll = 1e4, frac = 0.3)
    ) |>
    mutate(window = as_factor("taner") |> fct_relevel(c("rectangular", "gaussian", "taner"))) |>
    mutate(detrend_type = as_factor(detrend_type) |>
             fct_relevel(names(detrend_colours))) |>
    mutate(comb = as_factor(comb) |>
             fct_relevel(c("1:0", "1:0.25", "1:0.5", "1:0.75",
                           x = "1:1", "0.75:1", "0.5:1", "0.25:1", "0:1"))) |>
    mutate(depth_chunk = as_factor(depth_chunk) |>
             fct_relevel(c("full record", "depth >= 109.26", "depth < 109.26")))
#+end_src

***** check max_age_slider and tiepoint_error
:PROPERTIES:
:CREATED:  [2024-04-18 Thu 13:29]
:END:

#+begin_src R :results none
  rolling_age_optim <-
    bind_rows(
      read_rds("out/2024-03-27_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25.rds") |>
        mutate(max_age_slider = 200, tiepoint_error = 1.6),
      # 400 is for sure too much
      read_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_large-tie-error.rds") |>
        mutate(max_age_slider = 400, tiepoint_error = 3.0),
      read_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_large-tie-error_slide-300.rds") |>
        mutate(max_age_slider = 300, tiepoint_error = 3.0),
      read_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_large-tie-error_slide-200.rds") |>
        mutate(max_age_slider = 200, tiepoint_error = 3.0),
      read_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error4_slide-200.rds") |>
        mutate(max_age_slider = 200, tiepoint_error = 4.0),
      read_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error5_slide-300.rds") |>
        mutate(max_age_slider = 300, tiepoint_error = 5.0),
      read_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error10_slide-300.rds") |>
      # oh shit I set it to calculate up to 10 m but limited the search to 5 m
        mutate(max_age_slider = 300, tiepoint_error = 5.0),
     ## read_rds("out/2024-04-18_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error10f_slide-300.rds") |>
        ## mutate(max_age_slider = 300, tiepoint_error = 10.0),
     read_rds("out/2024-04-21_rolling_age_optim_Lstar_lin-scl-med_taner_narrow-0.25_tie-error7.5_slide-300.rds") |>
        mutate(max_age_slider = 300, tiepoint_error = 7.5),
     ) |>
     # these all use the new defaults
     mutate(
       frac = 0.25,
       roll = 1e10,
       window = as_factor("taner") |> fct_relevel(c("rectangular", "gaussian", "taner")),
       detrend_type = as_factor(detrend_type) |> fct_relevel(names(detrend_colours)),
       comb = as_factor(comb) |>
         fct_relevel(c("1:0", "1:0.25", "1:0.5", "1:0.75",
                       "1:1", "0.75:1", "0.5:1", "0.25:1", "0:1")),
       depth_chunk = as_factor(depth_chunk) |>
         fct_relevel(c("full record", "depth >= 109.26", "depth < 109.26")))
#+end_src

**** extract proxy, depth chunk, and site RMSD_start and RMSD
:PROPERTIES:
:CREATED:  [2023-12-12 Tue 10:57]
:END:
#+begin_src R
  best_age_optim <- rolling_age_optim |>
    tidylog::filter(detrend_type != "value") |>
    ## tidylog::filter(detrend_type != "scl") |>
    # pull out the best RMSD score
    # for error = 0, tiepoint is the first (i.e. without tweaks)
    mutate(RMSD_start = map_dbl(the_best,
                          \(x) x$details |>
                               filter(error == 0) |>
                               arrange(n) |>
                               slice(1) |>
                               pull(RMSD_tie))) |>
    # for the last, i.e. after tweaking all the tiepoints
    mutate(RMSD = map_dbl(the_best,
                          \(x) x$summary |>
                               arrange(rev(n)) |>
                               slice(1) |>
                               pull(RMSD_cum))) |>
    # I may have accidentally included multiple copies of the same sim?
    tidylog::filter(RMSD == min(RMSD),
                    .by = c(sol, site, proxy, detrend_type, depth_chunk, comb, window, roll, frac,
                            ## tiepoint_error, max_age_slider # temp?
                            ))
  rm(rolling_age_optim) # less chance of running out of memory
#+end_src

#+RESULTS:
: filter: no rows removed
: filter: no rows removed

**** single best for each site, proxy, depth_chunk, comb
:PROPERTIES:
:CREATED:  [2024-02-21 Wed 23:11]
:END:
out of all the detrend types and gaussian/rectangular filters (window)
#+begin_src R
  best_age_optim_one <- best_age_optim |>
    tidylog::filter(RMSD == min(RMSD),
                    .by = c(sol, proxy, site, comb, depth_chunk, frac,
                            ## tiepoint_error, max_age_slider # temp?
                            ))
#+end_src

#+RESULTS:
: filter: removed 150 rows (24%), 466 rows remaining

**** recompute RMSD for the full stack
:PROPERTIES:
:CREATED:  [2024-02-28 Wed 13:55]
:END:
#+begin_src R
  # find youngest age of the sopelana site, so we can filter out
  # Zumaia's oldest part
  cutoff <- best_age_optim |>
    filter(site == "Sopelana") |>
    mutate(match = map(the_best, "matched")) |>
    unnest(match) |>
    summarize(max_age_sopelana = min(age),
              .by = c(proxy, detrend_type, depth_chunk, comb, sol, window, frac,
                      ## tiepoint_error, max_age_slider # temp?
                      ))

  # get summary
  overall_sd <- best_age_optim |>
    mutate(match = map(the_best, "matched")) |>
    filter(depth_chunk == "full record") |>
    unnest(match) |>
    left_join(cutoff) |>
    # have to explicitly NOT filter out d13C because we only have it for Zumaia
    # so no age max_age_sopelana there!
    tidylog::filter(proxy == "d13C" | site == "Sopelana" |
                    (site == "Zumaia" & age < max_age_sopelana))

  rm(cutoff)
  rm(best_age_optim)

  overall_best <- overall_sd |>
    summarize(RMSD = sqrt(mean(SD)),
              .by = c(proxy, detrend_type,
                      comb, sol, window, roll, frac,
                      ## tiepoint_error, max_age_slider # temp?
                      ))

  overal_best_sol <- overall_best |>
    tidylog::filter(RMSD == min(RMSD), .by = c(sol, proxy))
#+end_src

#+RESULTS:
: Joining with `by = join_by(proxy, detrend_type, depth_chunk, comb, sol, frac, window)`
: filter: removed 5,991 rows (1%), 427,460 rows remaining
: filter: removed 280 rows (93%), 21 rows remaining

**** recompute RMSD for all the other detrend types etc.
:PROPERTIES:
:CREATED:  [2024-03-25 Mon 10:01]
:END:
#+begin_src R
  # find youngest age of the sopelana site, so we can filter out
  # Zumaia's oldest part
  cutoff <- rolling_age_optim_old |>
    filter(site == "Sopelana") |>
    mutate(match = map(the_best, "matched")) |>
    unnest(match) |>
    summarize(max_age_sopelana = min(age),
              .by = c(proxy, # NOT SITE
                      detrend_type, depth_chunk, comb, sol, window, frac
                      ))

  # get summary
  overall_sd_old <- rolling_age_optim_old |>
    mutate(match = map(the_best, "matched")) |>
    filter(depth_chunk == "full record") |>
    unnest(match) |>
    left_join(cutoff) |>
    # have to explicitly NOT filter out d13C because we only have it for Zumaia
    # so no age max_age_sopelana there!
    tidylog::filter(proxy == "d13C" | site == "Sopelana" |
                    (site == "Zumaia" & age < max_age_sopelana))

  # less chance of running out of memory
  rm(cutoff)
  rm(rolling_age_optim_old)

  overall_best_old <- overall_sd_old |>
    summarize(RMSD = sqrt(mean(SD)),
              .by = c(proxy, detrend_type, depth_chunk, comb, sol, window, frac))

  overal_best_sol_old <- overall_best_old |>
    tidylog::filter(RMSD == min(RMSD), .by = c(sol, proxy))
#+end_src

#+RESULTS:
: Joining with `by = join_by(proxy, detrend_type, depth_chunk, comb, sol, window, frac)`
: filter: removed 24,839 rows (4%), 570,715 rows remaining
: filter: removed 417 rows (95%), 24 rows remaining

**** [#B] inspect the tiepoint optimization plots
:PROPERTIES:
:CREATED:  [2024-04-18 Thu 17:02]
:END:
this will create new plots for each solution, we can analyze them quickly to see if any of them go terribly wrong somewhere
and identify the ones where this happens based on the table that I put in
#+begin_src R
  library(ggpmisc)

  print(best_age_optim, n = Inf)
  ## for (i in seq_along(best_age_optim)) {# everything all at once, a bit too much

  # First all the sopelana chunks:
  sopelana_ids <- c(8, 22, 36, 50, 64, 78, 92, 106)
  zumaia_ids <- c(1, 15, 29, 43, 57, 71, 85, 99)

  ## for (i in sopelana_ids) {# sopelana Lstar La10b # shift of 200, 300, 400 all fine, this shifts 13 a lot but doesn't result in a different fit...
  ## for (i in sopelana_ids + 1) {# sopelana Lstar La10c # shift 300 and 400 are off by a lot, larger error better
  ## for (i in sopelana_ids + 2) {# sopelana Lstar ZB18a # shift doesn't matter, visually error doesn't matter but you do get a better RMSD score if you make it large... ???
  ## for (i in sopelana_ids + 3) {# sopelana Lstar ZB20a # 400 shift too much, the rest identical
  ## for (i in sopelana_ids + 4) {# sopelana Lstar ZB20b # 400 shift too much, the rest visually identical with >3 m better RMSD
  ## for (i in sopelana_ids + 5) {# sopelana Lstar ZB20c # 400 shift too much, 1.6 visually better but worse score
  ## for (i in sopelana_ids + 6) {# sopelana Lstar ZB20d # 400 shift too much, >1.6 better but somehow 4 puts 13 all the way to the left, resulting in a way better RMSD without changing anything visually (1.09 vs 1.06)
  # now the Zumaia chunks
  ## for (i in zumaia_ids) {# zumaia Lstar La10b # shift 400 too much, rest fine, greater tie err is better but maybe I prefer the other local minimum for tiepoint 7? (but this never gets selected, also not with 1.6)
  ## for (i in zumaia_ids + 1) {# zumaia Lstar La10b # 400 too much, 6 is very /-like, this one might actually get wrecked by anything >1.6 (better score, visually worse match). tiepoint 4 should not move this much.
  ## for (i in zumaia_ids + 2) {# zumaia Lstar ZB18a # even 400 is fine! larger def better 3 is fine, 4 identical but better RMSD (only tiepoint 10 shifts)
  for (i in zumaia_ids + 3) {# zumaia Lstar ZB20a # 400 bad, 3 or 4 m shifts tiepoint 5 by quite a bit making the fit way nicer
  ## for (i in zumaia_ids + 4) {# zumaia Lstar ZB20b # 400 bad, 1.6 ugly, 3 fine, 4 m best
  ## for (i in zumaia_ids + 5) {# zumaia Lstar ZB20c # 400 same, 3 m makes younger part better? 4 might also be ok? these are all very different!
  ## for (i in zumaia_ids + 6) {# zumaia Lstar ZB20d # 400 bad, rest very subtle visually but better with 4 m. 0 m goes \ though... I'd prefer 6 to jump to the other side maybe?
    # create a new plot
    x11()
    # gotta print it if called from a for-loop
    ## i <- 45 # of interest
    i <- 10
    ## i <- 52 # of interest
    print(
      # it's a combination of two subplots (from patchwork)
      (
        # plot the tiepoint optimizations
        best_age_optim$the_best[[i]]$plot +
        scale_colour_viridis_d() +
        labs(colour = "Ma405") +
        coord_cartesian(xlim = rev(range(best_age_optim$the_best[[i]]$summary$strat_bot)) * c(1.02, 0.98)) +
        # with ggpmisc we can annotate a table so we know exactly which one we're looking at
        annotate("table", x = Inf, y = Inf, hjust = 0,
                 label = best_age_optim[i, c(1:5, 10, 12:18)])
      ) / (
        # plot the ecc construct in the time domain
        best_age_optim$the_best[[i]]$matched |>
        ggplot(aes(x = age * 1e-3, y = -ecc)) +
        labs(x = "Age (Ma)", y = "Norm. eccentricity and filtered proxy") +
        scale_x_reverse() +
        # add the new optimized tiepoint ages
        geom_vline(aes(xintercept = 1e-3 * (kpg_age + age_floating + age_slider)),
                   colour = "gray", data = best_age_optim$the_best[[i]]$summary) +
        # add the solution
        geom_line(aes(y = ecc_sln), colour = "gold", linewidth = 2) +
        # add the eccentricity construct
        geom_line() #+
        ## annotate("table", x = -Inf, y = Inf, hjust = 1, label = best_age_optim[i,] |> select(-"the_best"))
        )
    ) + plot_layout(guides = "collect")
    ## ggsave() # SOME
  }
#+end_src

#+RESULTS:
#+begin_src R
  ggsave("imgs/tiepoint_RMSD_optima.png", width = 12, height = 6)
#+end_src

#+RESULTS:

conclusions: I think I can increase the shift to 300 and the
**** COMMENT plot improvement after optimization after algorithm revision
# #+begin_src R :results output graphics file :file imgs/new_rolling_improvement.png :width 2400 :height 2000 :res 300
#+begin_src R :results output graphics file :file imgs/new_rolling_improvement.pdf :width 8 :height 5
  best_age_optim |>
    ## filter(comb == "1:1") |>
    ## filter(proxy == "Lstar") |>
    ## filter(detrend_type == "lin_scl_med") |>
    ## filter(detrend_type == "scl") |>
    ## filter(detrend_type %in% c("scl", "lin_scl_med")) |>
    ggplot(aes(x = sol, y = RMSD, colour = detrend_type,
               ## shape = window,
               ## size = detrend_type,
               group = paste(site, proxy, comb,
                             detrend_type, depth_chunk
                             ## window
                             ))) +
    labs(
      x = "Astronomical solution",
      y = "Root Mean Square Deviation (RMSD)",
      ## shape = "Bandpass window",
      ## alpha = "Bandpass window",
      linetype = "Age model") +
    facet_grid(cols = vars(proxy, ## window,
                           comb),
               rows = vars(site, depth_chunk),
               scales = "free_y", space = "free_y",
               ) +
    theme(## strip.text.y = element_text(size = 8),
      axis.text.x = element_text(angle = 90, vjust = 0.5)
          ) +
    scale_colour_manual(values = detrend_colours) +
    ## scale_shape_manual(values = c("Field" = '●', "Optimized" = '▼')) +
    scale_shape_manual(values = c("gaussian" = "circle",
                                  "rectangular" = "square")) + # ▬◀
    ## scale_alpha_manual(values = c("gaussian" = 1,
    ##                               "rectangular" = .3)) +
    scale_linetype_manual(values = c("Field" = "dashed", "Optimized" = "solid")) +
    scale_y_continuous(breaks = c(1, 1.2, 1.4, 1.5, 2),
                       minor_breaks = seq(0,2,.1)) +
    ## geom_point(aes(y = RMSD_start, shape = "Field"), size = 3) +
    geom_point(## aes(alpha = window),
               ) +
    geom_path(aes(y = RMSD_start, linetype = "Field")) +
    geom_path(aes(x = sol, y = RMSD, ## alpha = window,
                  linetype = "Optimized")) #+
    ## geom_segment(arrow=arrow(type = "closed", length = unit(0.1, "inches")))+
    ## geom_linerange(aes(ymin = RMSD_start, ymax = RMSD),
    ##                alpha = .2)
  ## +
    ## geom_point(size = .3, colour = "black", data = best_age_optim_one)
#+end_src

#+RESULTS:
[[file:imgs/new_rolling_improvement.pdf]]

**** COMMENT compare overall RMSD scores
:PROPERTIES:
:CREATED:  [2023-12-08 Fri 15:39]
:END:
limit to comb == "1:1" and don't show the lin_scl_rw.

# #+begin_src R :results output graphics file :file imgs/rolling_age_overview_new.png :width 1700 :height 1700 :res 300
#+begin_src R :results output graphics file :file imgs/rolling_age_overview_new.pdf :width 5 :height 5
  best_age_optim |>
    filter(comb == "1:1") |>
    filter(detrend_type != "value") |>
    ## filter(detrend_type == "lin_scl_med") |>
    ## filter(detrend_type == "scl") |>
    ## filter(detrend_type %in% c("scl", "lin_scl_med") |
    ##        (depth_chunk == "depth < 109.26" & detrend_type == "lin_scl_fine") |
    ##        (depth_chunk == "depth >= 109.26" & detrend_type == "lin_scl_coarse")) |>
    filter(proxy == "Lstar") |>
    ggplot(aes(x = sol, y = RMSD, #colour = detrend_type,
               ## shape = window,
               ## size = detrend_type,
               group = paste(site, proxy, comb,
                             detrend_type, depth_chunk## ,
                             ## window
                             ))) +
    labs(
      x = "Astronomical solution",
      y = "RMSD",
      ## shape = "Bandpass window",
      ## alpha = "Bandpass window",
      linetype = "Age model") +
    facet_grid(cols = vars(## proxy,
                           ## window## , comb
                           ),
               rows = vars(site, depth_chunk),
               scales = "free_y", space = "free_y",
               ) +
    ## theme(## strip.text.y = element_text(size = 8),
    ##   axis.text.x = element_text(angle = 90, vjust = 0.5)
    ##       ) +
    ## scale_colour_manual(values = detrend_colours) +
    ## scale_shape_manual(values = c("Field" = '●', "Optimized" = '▼')) +
    ## scale_shape_manual(values = c("gaussian" = '●',
    ##                               "rectangular" = '■')) + # ▬◀
    ## scale_shape_manual(values = c("gaussian" = "circle",
    ##                               "rectangular" = "square")) +
    ## scale_alpha_manual(values = c("gaussian" = 1,
    ##                               "rectangular" = .5)) +
    ## scale_linetype_manual(values = c("Field" = "dashed", "Optimized" = "solid")) +
    scale_y_continuous(breaks = c(0.9, 1.1, 1, 1.2, 1.3, 1.4, 1.5, 2),
                       ## minor_breaks = seq(0,2,.1)
    ) +
    ## geom_point(aes(y = RMSD_start), size = 0.7) +
    ## geom_path(aes(y = RMSD_start, linetype = "Field")) +
    geom_point(## aes(alpha = window),
               size = 1) +
    geom_path(aes(x = sol, y = RMSD, ## alpha = window,
                  ## linetype = "Optimized"
                  )) #+
    ## geom_segment(arrow=arrow(type = "closed", length = unit(0.1, "inches")))+
    ## geom_linerange(aes(ymin = RMSD_start, ymax = RMSD),
    ##                alpha = .2) ## +
    ## geom_point(size = .3, colour = "black", data = best_age_optim_one)
#+end_src

#+RESULTS:
[[file:imgs/rolling_age_overview_new.pdf]]


old
#+begin_src R :results output graphics file :file imgs/rolling_age_overview_new.png :width 1700 :height 1700 :res 300
  best_age_optim |>
    mutate(depth_chunk = factor(depth_chunk, levels = c("full record", "depth >= 109.26", "depth < 109.26"))) |>
    filter(comb == "1:1") |>
    ## filter(detrend_type != "lin_scl_rw") |>
    filter(detrend_type %in% c("lin_scl_fine",
                               "lin_scl_med",
                               "lin_scl_coarse")) |>
    filter(proxy == "Lstar") |>
    ggplot(aes(x = sol, y = RMSD, colour = detrend_type,
               ## alpha = exp == "all after package",
               group = paste(site, proxy, comb,
                             detrend_type))) +
    labs(x = "Astronomical solution",
         y = "Root Mean Square Deviation (RMSD)",
         shape = "Age model", linetype = "Age model",
         ## alpha = "lower / full record"
         ) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
    ## scale_alpha_manual(values = c("TRUE" = 0.5, "FALSE" = 1)) +
    facet_grid(cols = vars(proxy),
               rows = vars(site, depth_chunk)) +
    scale_y_continuous(breaks = c(0, 1, 1.5, 2),
                       minor_breaks = seq(0,3,.1)) +
    ## scale_shape_manual(values = c("Field" = '●', "Optimized" = '◀')) +
    scale_linetype_manual(values = c("Field" = "dashed", "Optimized" = "solid")) +
    scale_shape_manual(values = c("Field" = '●', "Optimized" = '▼')) + # ◀
    geom_point(aes(y = RMSD_start, shape = "Field"), size = 3) +
    geom_point(aes(fill = detrend_type, shape = "Optimized"), size = 3) +
    geom_path(aes(y = RMSD_start, linetype = "Field")) +
    geom_path(aes(linetype = "Optimized")) +
    ## geom_segment(arrow=arrow(type = "closed", length = unit(0.1, "inches")))
    geom_linerange(aes(ymin = RMSD_start, ymax = RMSD),
                   alpha = .6)
#+end_src

#+name: fig:rolling-rmsd
#+attr_latex: :width 1.2\textwidth
#+caption: Best RMSD scores for different astronomical solutions (x-axis), sites (column panels), detrend types (colours), and proxies (row panels) in different ~comb~'s (shape, linetype). This analysis relies on iteratively shifting the tiepoints by small increments up to \pm4 m and calculating the RMSD for the whole record at each iteration to decide which tiepoint error gives the best fit. *NOTE:* Zumaia d13C records are not correct, they miss a 405 kyr cycle!
#+RESULTS:
[[file:imgs/rolling_age_overview_new.png]]

**** COMMENT show only the best matches
:PROPERTIES:
:CREATED:  [2024-02-26 Mon 11:38]
:END:
#+begin_src R :results output graphics file :file imgs/rolling_age_overview_best.pdf :width 6 :height 5
  pl_best <- best_age_optim_one |>
    filter(comb == "1:1") |>
    ## filter(detrend_type != "value") |>
    ## filter(detrend_type == "lin_scl_med") |>
    ## filter(detrend_type == "scl") |>
    ## filter(detrend_type %in% c("scl", "lin_scl_med") |
    ##        (depth_chunk == "depth < 109.26" & detrend_type == "lin_scl_fine") |
    ##        (depth_chunk == "depth >= 109.26" & detrend_type == "lin_scl_coarse")) |>
    filter(proxy == "Lstar") |>
    ## filter(site == "Zumaia" & depth_chunk == "full record") |>
    ggplot(aes(x = sol, y = RMSD, #colour = detrend_type,
               ## shape = window,
               ## size = detrend_type,
               group = paste(site, proxy, comb,
                             detrend_type, depth_chunk## ,
                             ## window
                             ))) +
    labs(
      x = "Astronomical solution",
      y = "RMSD",
      ## shape = "Bandpass window",
      ## alpha = "Bandpass window"
    ) +
    facet_grid(## cols = vars(proxy
               ##             ## window## , comb
               ##             ),
               rows = vars(site, depth_chunk),
               scales = "free_y", space = "free_y",
               ) +
    ## theme(## strip.text.y = element_text(size = 8),
      ## axis.text.x = element_text(angle = 90, vjust = 0.5)
          ## ) +
    ## scale_colour_manual(values = detrend_colours) +
    ## scale_shape_manual(values = c("Field" = '●', "Optimized" = '▼')) +
    ## scale_shape_manual(values = c("gaussian" = '●',
    ##                               "rectangular" = '■')) + # ▬◀
    scale_shape_manual(values = c("gaussian" = "circle",
                                  "rectangular" = "square")) +
    ## scale_alpha_manual(values = c("gaussian" = 1,
    ##                               "rectangular" = .5)) +
    scale_y_continuous(breaks = c(1, 1.2, 1.4, 1.5, 2),
                       minor_breaks = seq(0,2,.1)) +
    ## geom_point(aes(y = RMSD_start), size = 0.7) +
    ## geom_path(aes(y = RMSD_start, linetype = "Field")) +
    geom_line(aes(x = sol, y = RMSD, group = "all"),
              ## linewidth = .5,
              alpha = .3,
              colour = "black")  +
    geom_point() #+
    ## geom_point(data = best_age_optim |> filter(comb == "1:1", proxy == "Lstar", window == "rectangular", detrend_type == "lin_scl_med"))
    ## geom_segment(arrow=arrow(type = "closed", length = unit(0.1, "inches")))+
    ## geom_linerange(aes(ymin = RMSD_start, ymax = RMSD),
    ##                alpha = .2) ## +
    ## geom_line(linewidth = .3, alpha = .2,
    ##           data = best_age_optim |> filter(proxy == "Lstar",
    ##                                           comb == "1:1")) +
    ## geom_point(size = .3, alpha = .2,
    ##            data = best_age_optim |> filter(proxy == "Lstar",
    ##                                            comb == "1:1")) ## +
    ## geom_line(linewidth = .5,
    ##           data = best_age_optim |> filter(proxy == "Lstar",
    ##                                           comb == "1:1",
    ##                                           detrend_type == "lin_scl_med"## ,
    ##                                           ## window == "rectangular"
    ##                                    ))
  pl_best
#+end_src

#+RESULTS:
[[file:imgs/rolling_age_overview_best.pdf]]

#+begin_src R
  readr::write_rds(pl_best, "out/2024-03-06_pl_best.rds")
#+end_src

#+RESULTS:

**** COMMENT recompute RMSD for the ~scl~ taner filter
:PROPERTIES:
:CREATED:  [2024-03-25 Mon 11:10]
:END:
#+begin_src R
  best_age_optim_scl <- read_rds("out/2024-03-21_rolling_age_optim_Lstar_scl_taner.rds") |>
    mutate(detrend_type = as_factor(detrend_type) |>
             fct_relevel(names(detrend_colours))) |>
    mutate(comb = as_factor(comb) |>
             fct_relevel(c("1:0", "1:0.25", "1:0.5", "1:0.75",
                           x = "1:1", "0.75:1", "0.5:1", "0.25:1", "0:1"))) |>
    mutate(depth_chunk = as_factor(depth_chunk) |>
             fct_relevel(c("full record", "depth >= 109.26", "depth < 109.26")))

  # find youngest age of the sopelana site, so we can filter out
  # Zumaia's oldest part
  cutoff <- best_age_optim_scl |>
    filter(site == "Sopelana") |>
    mutate(match = map(the_best, "matched")) |>
    unnest(match) |>
    summarize(max_age_sopelana = min(age),
              .by = c(proxy, detrend_type, depth_chunk, comb, sol## , window
                      ))

  # get summary
  overall_sd_scl <- best_age_optim_scl |>
    mutate(match = map(the_best, "matched")) |>
    filter(depth_chunk == "full record") |>
    unnest(match) |>
    left_join(cutoff) |>
    # have to explicitly NOT filter out d13C because we only have it for Zumaia
    # so no age max_age_sopelana there!
    tidylog::filter(proxy == "d13C" | site == "Sopelana" |
                    (site == "Zumaia" & age < max_age_sopelana))

  overall_best_scl <- overall_sd_scl |>
    summarize(RMSD = sqrt(mean(SD)),
              .by = c(proxy, detrend_type, comb, sol## , window
                      ))
#+end_src

#+RESULTS:
#+begin_example
Warning messages:
1: There was 1 warning in `mutate()`.
ℹ In argument: `detrend_type = fct_relevel(as_factor(detrend_type), names(detrend_colours))`.
Caused by warning:
! 7 unknown levels in `f`: gam_scl, hp_scl, lin_scl_rw, lin_scl_fine, lin_scl_med, lin_scl_coarse, and value
2: There was 1 warning in `mutate()`.
ℹ In argument: `comb = fct_relevel(...)`.
Caused by warning:
! 8 unknown levels in `f`: 1:0, 1:0.25, 1:0.5, 1:0.75, 0.75:1, 0.5:1, 0.25:1, and 0:1
Joining with `by = join_by(proxy, detrend_type, depth_chunk, comb, sol)`
filter: removed 88 rows (1%), 11,917 rows remaining
#+end_example

**** complicated plot RMSD vs solution for all variables
#+begin_src R :results output graphics file :file imgs/full_RMSD_complex.pdf :width 11 :height 4
  overall_best |>
    bind_rows(overall_best_old) |>
    ggplot(aes(
      x = sol,
      y = RMSD,
      colour = detrend_type,
      shape = window, # we're panelling these anyway
      ## shape = factor(frac),
      ## alpha = frac
    )) +
    scale_colour_manual(values = detrend_colours) +
    ## scale_alpha_binned() +
    facet_grid(
      ## cols = vars(proxy),
      cols = vars(proxy, comb),
      rows = vars(window),
      space = "free_y", scales = "free_y") +
    scale_shape_manual(values = c("gaussian" = "triangle",
                                  "rectangular" = "square",
                                  "taner" = "circle")) +
    labs(x = "Astronomical Solution",
         shape = "Bandpass Filter type",
         colour = "Detrending strategy") +
    geom_line(aes(group = paste(detrend_type, comb, proxy, window, roll, frac))) +
    geom_point() +
    geom_text(aes(label = frac,
                  group = paste(detrend_type, comb, proxy, window, roll, frac)),
              nudge_x = .4,
              data = \(x) x |>
                          filter(sol == "ZB20d") |>
                          distinct(sol, detrend_type, comb, proxy, window, roll, frac, RMSD)) +
    geom_text(aes(label = roll,
                  group = paste(detrend_type, comb, proxy, window, roll, frac)),
              nudge_x = -.4,
              data = \(x) x |>
                          filter(sol == "La10a") |>
                          distinct(sol, detrend_type, comb, proxy, window, roll, frac, RMSD))
#+end_src

#+RESULTS:
[[file:imgs/full_RMSD_complex.pdf]]

**** simple plot of RMSD vs solution
:LOGBOOK:
- Note taken on [2024-04-22 Mon 11:01] \\
  outdated, would need to reload the other data quickly
:END:
#+begin_src R :results output graphics file :file imgs/full_RMSD_scores.pdf :width 5 :height 2
  pl_rmsd_full <- overall_best |>
    filter(comb == "1:1") |>
    filter(detrend_type == "lin_scl_med") |>
    filter(roll == 1e10) |>
    filter(frac == 0.25) |> # new default
    ggplot(aes(x = sol, y = RMSD,
               colour = proxy,
               )) +
    labs(x = "Astronomical Solution",
         colour = ""
         ) +
    geom_line(aes(group = paste(detrend_type, proxy, window, roll, frac, max_age_slider, tiepoint_error)),
                  alpha = .3) +
    scale_colour_viridis_d() +
    geom_point() +
    theme(legend.position.inside = c(.13, .92),
          legend.position = "inside",
          legend.background = element_blank(),
          legend.key.height = unit(1, "mm"))
  pl_rmsd_full
#+end_src

#+RESULTS:
[[file:imgs/full_RMSD_scores.pdf]]

**** bootstrapped RMSD
:PROPERTIES:
:CREATED:  [2024-03-22 Fri 14:34]
:END:
***** do the boostrapping
#+begin_src R :eval never
  boot_RMSD <- function(data, indices) {
    d <- data[indices, ]
    sqrt(mean(d$SD))
  }

  bootstrapped_best <- overall_sd |>
    select(proxy, sol, SD) |>
    nest(.by = c(sol, proxy)) |>
    mutate(boot = purrr::map(data,
                             \(d) boot::boot(d, statistic = boot_RMSD, R = 1e5)$t[, 1]))

  bootstrapped_best |>
    write_rds("out/bootstrapped_best.rds")
#+end_src

#+begin_src R
  bootstrapped_best <- read_rds("out/bootstrapped_best.rds")

  bootstrapped_summary <- bootstrapped_best |>
    ggdist::median_qi(boot,
                      .width =
                        seq(0, .95, .05)
                      ## c(.68, .95)
                      )
#+end_src

#+RESULTS:

***** plot of boostrapped RMSD scores
#+begin_src R :results output graphics file :file imgs/full_RMSD_boot.png :width 1000 :height 600 :res 300
  pl_rmsd_boot <-
    bootstrapped_summary |>
    ggplot(aes(x = sol, y = boot,
               colour = proxy, fill = proxy,
               )) +
    labs(x = "Astronomical Solution",## , shape = "Bandpass Filter type"
         y = "RMSD",
         colour = "", fill = ""
         ) +
    theme(legend.position = "inside",
          legend.position.inside = c(.12, .99),
          legend.background = element_blank(),
          legend.key.height = unit(1, "mm")) +
    ## facet_grid(rows = vars(proxy), scales = "free_y", space = "free_y") +
    ggdist::geom_lineribbon(aes(ymin = .lower,
                                ymax = .upper,
                                group = paste(proxy, .width)),
                            alpha = .03
                            ## alpha = .1
                            ) +
    ## ggdist::stat_gradientinterval(data = bootstrapped_best |> unnest(boot)) +
    ## geom_line(aes(group = proxy), alpha = .3) +
    geom_point() #+
    # is the bootstrapped RMSD the same as the single-estimate? -> YES, not so sensitive
    ## geom_point(aes(y = RMSD), colour = "black", size = .3, data = overall_best)
    ## ggdist::geom_pointinterval(aes(ymin = .lower, ymax = .upper))
  # what if we compute the average RMSD for each solution based on all the proxies (this is bad, not weighted by measurement numbers!)
    ## stat_summary(aes(group = sol), geom = "pointrange", colour = "black")

  pl_rmsd_boot
#+end_src

#+RESULTS:
[[file:imgs/full_RMSD_boot.png]]

another attempt to visualize if the RMSD scores differ significantly between solutions
#+begin_src R :results output graphics file :file imgs/bootstrapped_halfeyes.png :width 1700 :height 800 :res 150
  library(ggdist)
  bootstrapped_best |>
    unnest(boot) |>
    ggplot(aes(x = sol, y = boot, fill = proxy)) +
    facet_grid(cols = vars(proxy)) +
    stat_halfeye(position = position_dodge(width = .4)) #+
    ## stat_halfeye(aes(group = sol), fill = "gray") # how do they add up? to weird bivariate distributions
#+end_src

#+RESULTS:
[[file:imgs/bootstrapped_halfeyes.png]]

***** bootstrapped average RMSD scores of all proxies
:PROPERTIES:
:CREATED:  [2024-05-06 Mon 11:49]
:END:
#+begin_src R
  overall_summ <- bootstrapped_best |>
    unnest(boot) |>
    group_by(sol) |>
    ggdist::median_qi(boot, .width = c(.68, .95, .99))


  overall_summ_noC <- bootstrapped_best |>
    filter(proxy != "d13C") |>
    unnest(boot) |>
    group_by(sol) |>
    ggdist::median_qi(boot, .width = c(.68, .95, .99))
#+end_src

#+begin_src R :results output graphics file :file imgs/bootstrapped_average.png :width 2200 :height 1900 :res 300
  scl <- c("d13C" = "red", "Lstar" = "green", "MS" = "blue")
  (
  bootstrapped_best |>
    unnest(boot) |>
    ggplot(aes(x = sol, y = boot)) +
    ggdist::stat_slab() +
    ggdist::stat_halfeye(aes(fill = proxy, colour = proxy), position = position_dodge(width = .2), alpha = .2) +
    ggdist::geom_pointinterval(aes(ymin = .lower, ymax = .upper), data = overall_summ) +
    scale_fill_manual(values = scl) + scale_colour_manual(values = scl)
  ) / (
  bootstrapped_best |>
    filter(proxy != "d13C") |>
    unnest(boot) |>
    ggplot(aes(x = sol, y = boot)) +
    ggdist::stat_slab() +
    ggdist::stat_halfeye(aes(fill = proxy, colour = proxy), position = position_dodge(width = .2), alpha = .2) +
    ggdist::geom_pointinterval(aes(ymin = .lower, ymax = .upper), data = overall_summ_noC) +
    scale_fill_manual(values = scl) + scale_colour_manual(values = scl)
  ) + plot_layout(axes = "collect", guides = "collect")
#+end_src

#+RESULTS:
[[file:imgs/bootstrapped_average.png]]

NOT SHOWN
**** plot of RMSD vs solution: tiepoint depth adjustments
perhaps max_age_slider = 200 + tiepoint_error = 3 is best?
#+begin_src R :results output graphics file :file imgs/full_RMSD_tiepoint-error.pdf :width 5 :height 2
  pl_rmsd_tie <- overall_best |>
    filter(max_age_slider < 400) |> # this is off by 400 kyr often
    filter(tiepoint_error < 7.5) |> # this is sometimes merging a full LEC
    filter(comb == "1:1") |>
    filter(detrend_type == "lin_scl_med") |>
    filter(roll == 1e10) |>
    filter(frac == 0.25) |> # new default
    ggplot(aes(x = sol, y = RMSD,
               ## colour = proxy,
               colour = factor(tiepoint_error),
               ## linetype = factor(max_age_slider),
               )) +
    labs(x = "Astronomical Solution",
         colour = ""
         ) +
    geom_line(aes(group = paste(detrend_type, proxy, window, roll, frac, max_age_slider, tiepoint_error)),
                  alpha = .3) +
    scale_colour_viridis_d() +
    geom_point() +
    theme(legend.position.inside = c(.13, .92),
          legend.position = "inside",
          legend.background = element_blank(),
          legend.key.height = unit(.1, "mm")
          )
  pl_rmsd_tie
#+end_src

#+RESULTS:
[[file:imgs/full_RMSD_tiepoint-error.pdf]]

**** plot of RMSD vs frac: filter window size
:PROPERTIES:
:CREATED:  [2024-03-27 Wed 22:40]
:END:
#+begin_src R :results output graphics file :file imgs/full_RMSD_frac.pdf :width 5 :height 3
  pl_rmsd_frac <- overall_best |>
    filter(comb == "1:1") |>
    filter(detrend_type == "lin_scl_med") |>
    filter(roll == 1e10) |>
    bind_rows(
      overall_best_old |>
      filter(comb == "1:1") |>
      filter(detrend_type == "lin_scl_med") #|>
      ## filter(proxy == "Lstar")
              ) |>
    filter(proxy == "Lstar") |>
    ## filter(detrend_type == "lin_scl_med", window == "gaussian") |>
    ## filter(RMSD == min(RMSD), .by = c(sol, proxy)) |> # only the best
    ggplot(aes(x = sol, y = RMSD,
               colour = factor(round(frac, 2)),
               shape = window,
               ## colour = detrend_type## , shape = window
               )) +
    scale_colour_viridis_d() +
    labs(x = "Astronomical Solution",## , shape = "Bandpass Filter type"
         colour = ""
         ) +
    facet_grid(
      cols = vars(proxy),
      rows = vars(window),
      scales = "free_y", space = "free_y"
    ) +
    scale_shape_manual(values = c("gaussian" = "triangle",
                                  "rectangular" = "square",
                                  "taner" = "circle")) +
    ## geom_line(aes(group = paste(detrend_type, proxy, comb## , window
    ##                             )),
    ##           alpha = .1) +
    ## ## geom_point(alpha = .05) +
    geom_line(aes(group = paste(detrend_type, proxy, window, roll, frac)),
                  alpha = .3) +
    geom_point() #+
    ## geom_text(aes(label = frac)) +
    ## geom_text(aes(label = detrend_type)) +
    ## theme(legend.position.inside = c(.13, .8),
    ##       legend.position = "inside",
    ##       legend.background = element_blank(),
    ##       legend.key.height = unit(1, "mm")) #+
  # what if we compute the average RMSD for each solution based on all the proxies (this is bad, not weighted by measurement numbers!)
    ## stat_summary(aes(group = sol), geom = "pointrange", colour = "black")

  pl_rmsd_frac
#+end_src

#+RESULTS:
[[file:imgs/full_RMSD_frac.pdf]]


#+begin_src R :results output graphics file :file imgs/full_RMSD_frac_old.pdf :width 4 :height 2
  pl_rmsd_full_old <- overall_best_old |>
    filter(comb == "1:1") |>
    filter(detrend_type == "lin_scl_med") |>
    filter(proxy == "Lstar") |>
    ## filter(window == "gaussian") |>
    ## filter(detrend_type == "lin_scl_med", window == "gaussian") |>
    ## filter(RMSD == min(RMSD), .by = c(sol, proxy)) |> # only the best
    ## bind_rows(
    ##   overall_best |>
    ##   filter(comb == "1:1") |>
    ##   filter(detrend_type == "lin_scl_med") |>
    ##   filter(roll == 1e10) |>
    ##   filter(proxy == "Lstar")
    ## ) |>
    ggplot(aes(x = sol, y = RMSD,
               colour = factor(frac),
               shape = window,
               ## colour = detrend_type## , shape = window
               )) +
    scale_colour_viridis_d() +
    labs(x = "Astronomical Solution",## , shape = "Bandpass Filter type"
         colour = ""
         ) +
    ## facet_grid(cols = vars(proxy)) +
    scale_shape_manual(values = c("gaussian" = "triangle",
                                  "rectangular" = "square",
                                  "taner" = "circle")) +
    ## geom_line(aes(group = paste(detrend_type, proxy, comb## , window
    ##                             )),
    ##           alpha = .1) +
    ## ## geom_point(alpha = .05) +
    geom_line(aes(group = paste(detrend_type, proxy, window, frac)),
                  alpha = .3) +
    geom_point() +
    ## geom_text(aes(label = frac)) +
    ## geom_text(aes(label = detrend_type)) +
    theme(legend.position.inside = c(.13, .8),
          legend.position = "inside",
          legend.background = element_blank(),
          legend.key.height = unit(1, "mm")) #+
  # what if we compute the average RMSD for each solution based on all the proxies (this is bad, not weighted by measurement numbers!)
    ## stat_summary(aes(group = sol), geom = "pointrange", colour = "black")

  pl_rmsd_full_old
#+end_src

#+RESULTS:
[[file:imgs/full_RMSD_frac_old.pdf]]

**** RMSD vs age_slider
:PROPERTIES:
:CREATED:  [2024-04-18 Thu 13:38]
:END:

#+begin_src R :results output graphics file :file imgs/full_RMSD_age_slider.pdf :width 5 :height 2
  pl_rmsd_full <- overall_best |>
    ggplot(aes(x = sol, y = RMSD,
               colour = factor(max_age_slider),
               )) +
    labs(x = "Astronomical Solution",
         colour = ""
         ) +
    geom_line(aes(group = paste(max_age_slider, tiepoint_error)),
                  alpha = .3) +
    geom_point() +
    theme(legend.position.inside = c(.13, .95),
          legend.position = "inside",
          legend.background = element_blank(),
          legend.key.height = unit(1, "mm"))
  pl_rmsd_full
#+end_src

#+RESULTS:
[[file:imgs/full_RMSD_age_slider.pdf]]

**** COMMENT compare detrend_types and filters
:PROPERTIES:
:CREATED:  [2024-03-25 Mon 11:08]
:END:
everything
#+begin_src R :results output graphics file :file imgs/full_RMSD_boot_comparison.png :width 2600 :height 700 :res 300
  pl_rmsd_detrend_types <- pl_rmsd_full +
    ggnewscale::new_scale_color() +
    scale_colour_manual(values = detrend_colours) +
    geom_line(aes(y = RMSD, colour = detrend_type,
                  group = paste(detrend_type)),
              data = overall_best |>
                filter(detrend_type == "scl"),
              alpha = .3) +
    geom_point(aes(y = RMSD),
               data = overall_best |>
                 filter(detrend_type == "scl")) +
    facet_grid(cols = vars(proxy)) +
    scale_linetype_manual(values = c("gaussian" = "dashed", "rectangular" = "dotted")) +
    geom_line(aes(y = RMSD, colour = detrend_type, linetype = window,
                  group = paste(proxy, detrend_type, window)),
              data = overall_best_old) +
    scale_shape_manual(values = c("gaussian" = "triangle", "rectangular" = "square")) +
    geom_point(aes(y = RMSD, colour = detrend_type, shape = window),
             data = overall_best_old)
  pl_rmsd_detrend_types
#+end_src

#+RESULTS:
[[file:imgs/full_RMSD_boot_comparison.png]]

**** [#B] simple comparison of taner roll parameter
#+begin_src R :results output graphics file :file imgs/full_RMSD_roll_comparison.pdf :width 3.3 :height 2
  pl_rmsd_taner <- overall_best |>
    filter(comb == "1:1") |>
    filter(detrend_type == "lin_scl_med") |>
    filter(proxy == "Lstar") |>
    filter(near(frac, 0.3)) |>
    ## filter(detrend_type == "lin_scl_med", window == "gaussian") |>
    ## filter(RMSD == min(RMSD), .by = c(sol, proxy)) |> # only the best
    ggplot(aes(x = sol, y = RMSD,
               ## colour = proxy
               colour = factor(format(roll, scientific = TRUE)),
               ## colour = detrend_type## , shape = window
               )) +
    ## scale_colour_manual(values = detrend_colours) +
    labs(x = "Astronomical Solution",## , shape = "Bandpass Filter type"
         colour = "Taner roll",
         alpha = ""
         ) +
    ## facet_grid(cols = vars(proxy)) +
    ## facet_grid(rows = vars(proxy), scales = "free_y", space = "free_y") +
    ## scale_shape_manual(values = c("gaussian" = "circle",
    ##                               "rectangular" = "square")) +
    ## geom_line(aes(group = paste(detrend_type, proxy, comb## , window
    ##                             )),
    scale_colour_viridis_d() +
    ##           alpha = .1) +
    ## geom_point(alpha = .05) +
    # manual fiddling to add rect
    geom_line(aes(group = "all"), colour = "darkgray",
              data = overall_best_old |>
                filter(detrend_type == "lin_scl_med", proxy == "Lstar", window == "rectangular", near(frac, 0.3))) +
    geom_point(colour = "darkgray", shape = "square",
               data = overall_best_old |>
                 filter(detrend_type == "lin_scl_med", proxy == "Lstar", window == "rectangular", near(frac, 0.3))) +

    # manual fiddling to add gauss
    geom_line(aes(group = "all"), colour = "darkred",
              data = overall_best_old |>
                filter(detrend_type == "lin_scl_med", proxy == "Lstar", window == "gaussian", near(frac, 0.3))) +
    geom_point(colour = "darkred", shape = "triangle",
               data = overall_best_old |>
                filter(detrend_type == "lin_scl_med", proxy == "Lstar", window == "gaussian", near(frac, 0.3))) +

    # add original narrow gauss
    ## geom_line(aes(group = "all"), colour = "darkred",
    ##           data = overall_best_old |>
    ##             filter(detrend_type == "lin_scl_med", proxy == "Lstar", window == "gaussian", near(frac, 0.25 * gauss_corr))) +
    ## geom_point(colour = "darkred", shape = "triangle",
    ##            data = overall_best_old |>
    ##              filter(detrend_type == "lin_scl_med", proxy == "Lstar", window == "gaussian", near(frac, 0.25 * gauss_corr))) +

    # all the taner filters
    geom_line(aes(group = paste(detrend_type, proxy, window, roll))) +
    geom_point() +

    theme(legend.position.inside = c(.85, .32),
          legend.position = "inside",
          legend.background = element_blank(),
          legend.key.height = unit(1, "mm")) #+
  # what if we compute the average RMSD for each solution based on all the proxies (this is bad, not weighted by measurement numbers!)
    ## stat_summary(aes(group = sol), geom = "pointrange", colour = "black")
  pl_rmsd_taner
#+end_src

#+RESULTS:
[[file:imgs/full_RMSD_roll_comparison.pdf]]

**** [#B] simplified comparison of windows: rect vs. gauss vs. taner
:PROPERTIES:
:CREATED:  [2024-03-27 Wed 08:57]
:END:
#+begin_src R :results output graphics file :file imgs/full_RMSD_filter_comparison.png :width 2600 :height 700 :res 300
  pl_rmsd_detrend_types <- overall_best |>
    filter(comb == "1:1") |>
    filter(detrend_type == "lin_scl_med") |>
    filter(roll == 1e10) |>
    filter(frac == 0.25) |>
    ggplot(aes(x = sol, y = RMSD,
               ## colour = factor(format(frac, scientific = TRUE)),
               shape = window,
               )) +
    ## scale_colour_manual(values = detrend_colours) +
    labs(x = "Astronomical Solution",## , shape = "Bandpass Filter type"
         colour = "roll",
         alpha = ""
         ) +
    facet_grid(cols = vars(proxy)) +
    ## facet_grid(rows = vars(proxy), scales = "free_y", space = "free_y") +
    scale_shape_manual(values = c("gaussian" = "triangle",
                                  "rectangular" = "square",
                                  "taner" = "circle")) +
    ## scale_colour_viridis_d() +

    # manual fiddling to add rect
    geom_line(aes(group = paste(proxy, detrend_type, comb, window, frac)), colour = "darkgray",
              data = overall_best_old |>
                filter(detrend_type == "lin_scl_med", window == "rectangular", near(frac, 0.25))) +
    geom_point(aes(shape = window), colour = "darkgray",
               data = overall_best_old |>
                 filter(detrend_type == "lin_scl_med", window == "rectangular", near(frac, 0.25))) +
    # manual fiddling to add gauss
    geom_line(aes(group = frac), colour = "darkred",
              data = overall_best_old |>
                filter(detrend_type == "lin_scl_med",
                       window == "gaussian",
                       near(frac, 0.25))) +
    # I think in the paper I don't want to show the narrow ones too here
    geom_point(aes(shape = window), colour = "darkred",
               data = overall_best_old |>
                 filter(detrend_type == "lin_scl_med",
                        window == "gaussian",
                        near(frac, 0.25))) +

    # this performs worse somehow
    ## # this is the gaussian where I upscaled the width so it should be comparable to a taner with roll = 1e4
    ## geom_line(aes(group = frac), colour = "darkred",
    ##           data = overall_best_old |>
    ##             filter(detrend_type == "lin_scl_med",
    ##                    window == "gaussian",
    ##                    near(frac, 0.25 * gauss_corr, 0.01))) +
    ## geom_point(aes(shape = window), colour = "darkred",
    ##            data = overall_best_old |>
    ##              filter(detrend_type == "lin_scl_med",
    ##                     window == "gaussian",
    ##                     near(frac, 0.25 * gauss_corr, 0.001))) +

    # all the taner filters
    geom_line(aes(group = paste(proxy, detrend_type, comb, window, roll, frac)),
                  alpha = .3) +
    geom_point() +
    ## # other roll parameters
    ## geom_line(aes(group = paste(proxy, detrend_type, comb, window, roll, frac)),
    ##           alpha = .3,
    ##           data = overall_best |>
    ##             filter(comb == "1:1") |>
    ##             filter(detrend_type == "lin_scl_med") #|>
    ##             ## filter(frac == 0.25)
    ##           ) +

    theme(legend.position.inside = c(.1, .32),
          legend.position = "inside",
          legend.background = element_blank(),
          legend.key.height = unit(1, "mm")) #+

  pl_rmsd_detrend_types
#+end_src

#+RESULTS:
[[file:imgs/full_RMSD_filter_comparison.png]]

**** simplified comparison of filter widths: frac
:PROPERTIES:
:CREATED:  [2024-03-28 Thu 16:37]
:END:
#+begin_src R :results output graphics file :file imgs/full_RMSD_frac_comparison.png :width 2600 :height 700 :res 300
  pl_rmsd_frac <- overall_best |>
    filter(comb == "1:1") |>
    filter(detrend_type == "lin_scl_med") |>
    filter(roll == 1e10) |>
    ggplot(aes(x = sol, y = RMSD,
               colour = factor(frac),
               shape = window,
               )) +
    ## scale_colour_manual(values = detrend_colours) +
    labs(x = "Astronomical Solution",## , shape = "Bandpass Filter type"
         colour = "frac",
         alpha = ""
         ) +
    facet_grid(cols = vars(proxy)) +
    scale_shape_manual(values = c("gaussian" = "triangle",
                                  "rectangular" = "square",
                                  "taner" = "circle")) +
    scale_colour_viridis_d() +

    ## # manual fiddling to add rect
    ## geom_line(aes(group = paste(proxy, detrend_type, comb, window, frac)), colour = "darkgray",
    ##           data = overall_best_old |>
    ##             filter(detrend_type == "lin_scl_med", window == "rectangular")) +
    ## geom_point(aes(shape = window), colour = "darkgray",
    ##            data = overall_best_old |>
    ##              filter(detrend_type == "lin_scl_med", window == "rectangular")) +
    ## # manual fiddling to add gauss
    ## geom_line(aes(group = "all"), colour = "darkred",
    ##           data = overall_best_old |>
    ##             filter(detrend_type == "lin_scl_med",
    ##                    window == "gaussian",
    ##                    frac == 0.25)) +
    ## geom_point(aes(shape = window), colour = "darkred",
    ##            data = overall_best_old |>
    ##              filter(detrend_type == "lin_scl_med",
    ##                     window == "gaussian",
    ##                     frac == 0.25)) +

    # all the taner filters
    geom_line(aes(group = paste(proxy, detrend_type, comb, window, roll, frac)),
                  alpha = .3) +
    geom_point() +

    theme(legend.position.inside = c(.85, .82),
          legend.position = "inside",
          legend.background = element_blank(),
          legend.key.height = unit(1, "mm")) #+

  pl_rmsd_frac
#+end_src

#+RESULTS:
[[file:imgs/full_RMSD_frac_comparison.png]]

**** simplified comparison of detrend_types
:PROPERTIES:
:CREATED:  [2024-03-27 Wed 09:05]
:END:
rectangular only
#+begin_src R :results output graphics file :file imgs/full_RMSD_detrend_comparison.png :width 2600 :height 700 :res 300
  pl_rmsd_detrend_types <- pl_rmsd_full +
    ## aes(colour = detrend_type) +
    scale_colour_discrete(guide = FALSE) +
    ggnewscale::new_scale_color() +
    scale_colour_manual(values = detrend_colours) +
    labs(shape = "", linetype = "", colour = "") +
    facet_grid(cols = vars(proxy)) +
    geom_line(aes(y = RMSD, colour = detrend_type,
                  group = paste(proxy, detrend_type, window)),
              data = overall_best_old |>
                filter(window == "rectangular", detrend_type != "value")) +
    geom_point(aes(y = RMSD, colour = detrend_type),
               shape = "square",
               data = overall_best_old |>
                 filter(window == "rectangular", detrend_type != "value")) +
    theme(legend.position.inside = c(.4, .999))
  pl_rmsd_detrend_types
#+end_src

#+RESULTS:
[[file:imgs/full_RMSD_detrend_comparison.png]]

**** simplified comparison of combs
:PROPERTIES:
:CREATED:  [2024-04-15 Mon 14:59]
:END:
#+begin_src R :results output graphics file :file imgs/comb_bars.png :width 600 :height 200
  pl_bars <- overall_best |>
    filter(detrend_type == "lin_scl_med") |>
    filter(roll == 1e10) |>
    filter(frac == 0.25) |>
    filter(window == "taner") |>
    separate(comb, into = c("f405", "f100"), sep = ":", remove = FALSE) |>
    mutate(f405 = parse_double(f405),
           f100 = parse_double(f100)) |>
    mutate(comb_frac = f405 / (f405 + f100)) |>
    ggplot() +
    geom_col(aes(x = comb, y = 1), fill = "orange", alpha = .3, width = 0.3) +
    geom_col(aes(x = comb, y = comb_frac), fill = "navyblue", alpha = .3, width = 0.3) +
    facet_grid(cols = vars(proxy)) +
    labs(x = "Relative weight of long- and short eccentricity") +
    theme(axis.title.y = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.line = element_blank(),
          strip.background = element_blank(),
          strip.text = element_blank())
  pl_bars
#+end_src

#+RESULTS:
[[file:imgs/comb_bars.png]]

#+begin_src R :results output graphics file :file imgs/full_RMSD_comb_comparison.png :width 2600 :height 1000 :res 300
  (
  overall_best |>
    filter(detrend_type == "lin_scl_med") |>
    filter(roll == 1e10) |>
    filter(frac == 0.25) |>
    filter(window == "taner") |>
    ## filter(proxy == "Lstar") |>
    ggplot(aes(
      ## x = sol,
      x = comb,
      y = RMSD,
      ## colour = comb,
      colour = sol,
      ## shape = window,
      )) +
    ## scale_colour_manual(values = detrend_colours) +
    labs(
      x = "Relative weight of long- and short eccentricity",
      ## x = "Astronomical Solution",## , shape = "Bandpass Filter type"
      colour = "Solution",
      alpha = ""
    ) +
    ## facet_grid(rows = vars(sol), scales = "free_y", space = "free_y") +
    facet_grid(cols = vars(proxy)) +
    scale_y_continuous(breaks = seq(0, 1.5, 0.1)) +
    scale_colour_brewer(palette = "Paired") +
    ## annotate("rect", xmin = 4.5, xmax = 5.5, ymin = -Inf, ymax = Inf, fill = "red", alpha = .2, colour = NA) +
    # all the taner filters
    geom_line(aes(group = paste(sol, proxy, detrend_type, window, roll, frac)),
                  alpha = .3) +
    geom_point() +
    ## geom_point(size = 3, colour = "red", data = \(x) filter(x, comb == "1:1")) +
    theme(legend.position.inside = c(.06, .9),
            ## c(0.17, 0.22),
          legend.position = "inside",
          legend.background = element_blank(),
          legend.key.height = unit(1, "mm"),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(), axis.line.x = element_blank()
          ) #+
  ) / pl_bars + plot_layout(heights = c(10, 2), axes = "collect")
#+end_src

#+RESULTS:
[[file:imgs/full_RMSD_comb_comparison.png]]

**** improvement in RMSD score after tie-point optimization
:PROPERTIES:
:CREATED:  [2024-03-25 Mon 17:16]
:END:
#+begin_src R :results output graphics file :file imgs/sol_SD_tie.png :width 2600 :height 700 :res 300
  best_age_optim |>
    filter(depth_chunk == "full record") |> # ignore the other depth chunks I tried
    filter(comb == "1:1") |>
    filter(detrend_type == "lin_scl_med") |>
    filter(site == "Zumaia") |>
    left_join(overall_best |> rename(full_RMSD = RMSD)) |>
    arrange(proxy, detrend_type, sol) |> # this is so we can see why full_RMSD is not the same as RMSD
    ggplot(aes(x = sol## , colour = site
               )) +
    labs(x = "", y = "RMSD", linetype = "", shape = "", colour = "") +
    theme(legend.position = "inside",
          legend.key.height = unit(2, "mm"),
          legend.background = element_blank(),
          legend.position.inside = c(.2, .65)) +
    facet_grid(cols = vars(proxy)) +
    scale_linetype_manual(values = c("Field-based" = "dashed", "Optimized" = "solid")) +
    scale_shape_manual(values = c("Field-based" = "square", "Optimized" = "circle")) +
    geom_line(aes(y = RMSD_start, group = paste(site, depth_chunk),
                  linetype = "Field-based")) +
    geom_point(aes(y = RMSD_start, shape = "Field-based")) +
    geom_line(aes(y = RMSD, group = paste(site, depth_chunk),
                  linetype = "Optimized")) +
    geom_point(aes(y = RMSD, shape = "Optimized")) #+
  ## geom_line(aes(y = full_RMSD, group = paste(depth_chunk)), colour = "black") +
  ## geom_point(aes(y = full_RMSD), colour = "black")
#+end_src

#+RESULTS:
[[file:imgs/sol_SD_tie.png]]

**** [#B] simple plot of records vs. solutions
:PROPERTIES:
:CREATED:  [2024-03-08 Fri 14:19]
:END:
***** Lstar
#+begin_src R :results output graphics file :file imgs/sol_SD.pdf :width 7 :height 7
  pl_age_matches <- overall_sd |>
    filter(depth_chunk == "full record") |>
    filter(detrend_type == "lin_scl_med", window == "taner", comb == "1:1") |>
    ## filter(max_age_slider == 200, tiepoint_error == 4.0) |>
    filter(roll == 1e10, frac == 0.25) |>
    filter(proxy == "Lstar") |>
    ggplot(aes(x = age * 1e-3)) +
    facet_grid(rows = vars(sol## , max_age_slider, tiepoint_error
                           )) +
    scale_x_reverse(breaks = seq(66, 73, 1)) +
    scale_y_continuous(breaks = seq(-4, 4, 4)) +
    scale_colour_manual(name = "",
                        values = c("Zumaia" = "purple",
                                   "Sopelana" = "orange",
                                   "Solution" = "black")) +
    # attempt to get it in the plot itself somewhere
    theme(legend.position.inside = c(.9, .99),
          legend.location = "inside",
          legend.key.height = unit(2, "mm"),
          ## legend.background = element_rect(colour = "black")
          legend.background = element_blank(),
          panel.border = element_blank(),
          axis.line = element_line()
          ) +
    labs(x = "Age (Ma)", y = "Scaled Proxy/Solution") +
    ## geom_ribbon(aes(ymin = ecc_sln, ymax = -ecc), fill = "red", alpha = .3) +
    ## geom_line(aes(y = dt * 50)) +
    ## geom_ribbon(aes(ymin = min(scale(SD)[, 1]) - 8,
    ##                 ymax = scale(SD)[, 1] - 8),
    ##             fill = "black", alpha = .3) +
    geom_vline(aes(xintercept = age * 1e-3, colour = site),
               alpha = .15,
               data = \(d) d |>
                      distinct(proxy, site, sol, detrend_type, depth_chunk, the_best) |>
                      mutate(summary = map(the_best, "summary")) |>
                      unnest(summary) |>
                      mutate(age = kpg_age + age_floating + age_slider)) +
    geom_line(aes(y = -ecc, colour = site, group = paste(site## , max_age_slider, tiepoint_error
                                                         ))) +
    geom_line(aes(y = ecc_sln, colour = "Solution"))
  pl_age_matches
#+end_src

#+RESULTS:
[[file:imgs/sol_SD.pdf]]
***** d13C
same for d13C
#+begin_src R :results output graphics file :file imgs/sol_SD_d13C.pdf :width 7 :height 7
  pl_age_matches_d13C <- overall_sd |>
    tidylog::inner_join(best_age_optim_one |> select(-the_best)) |>
    ## filter(proxy == "Lstar") |>
    filter(proxy == "d13C") |> filter(depth_chunk == "full record") |>
    ggplot(aes(x = age * 1e-3)) +
    facet_grid(rows = vars(sol)) +
    scale_x_reverse(breaks = seq(66, 73, 1)) +
    scale_y_continuous(breaks = seq(-4, 4, 4)) +
    scale_colour_manual(name = "",
                        values = c("Zumaia" = "purple",
                                   "Sopelana" = "orange",
                                   "Solution" = "black")) +
    # attempt to get it in the plot itself somewhere
    theme(legend.position = c(.9, .99),
          legend.location = "inside",
          legend.key.height = unit(2, "mm"),
          ## legend.background = element_rect(colour = "black")
          legend.background = element_blank(),
          panel.border = element_blank(),
          axis.line = element_line()
          ) +
    labs(x = "Age (Ma)", y = "Scaled Proxy/Solution") +
    ## geom_ribbon(aes(ymin = ecc_sln, ymax = -ecc), fill = "red", alpha = .3) +
    ## geom_line(aes(y = dt * 50)) +
    ## geom_ribbon(aes(ymin = min(scale(SD)[, 1]) - 8,
    ##                 ymax = scale(SD)[, 1] - 8),
    ##             fill = "black", alpha = .3) +
    geom_vline(aes(xintercept = age * 1e-3, colour = site),
               alpha = .15,
               data = \(d) d |>
                      distinct(proxy, site, sol, detrend_type, depth_chunk, the_best) |>
                      mutate(summary = map(the_best, "summary")) |>
                      unnest(summary) |>
                      mutate(age = kpg_age + age_floating + age_slider)) +
    geom_line(aes(y = -ecc, group = site, colour = site)) +
    geom_line(aes(y = ecc_sln, colour = "Solution"))
  pl_age_matches_d13C
#+end_src

#+RESULTS:
[[file:imgs/sol_SD_d13C.pdf]]

***** MS
and for MS
#+begin_src R :results output graphics file :file imgs/sol_SD_MS.pdf :width 7 :height 7
  pl_age_matches_MS <- overall_sd |>
    tidylog::inner_join(best_age_optim_one |> select(-the_best)) |>
    ## filter(proxy == "Lstar") |>
    ## filter(proxy == "d13C") |> filter(depth_chunk == "full record") |>
    filter(proxy == "MS") |> #filter(depth_chunk == "full record") |>
    ggplot(aes(x = age * 1e-3)) +
    facet_grid(rows = vars(sol)) +
    scale_x_reverse(breaks = seq(66, 73, 1)) +
    scale_y_continuous(breaks = seq(-4, 4, 4)) +
    scale_colour_manual(name = "",
                        values = c("Zumaia" = "purple",
                                   "Sopelana" = "orange",
                                   "Solution" = "black")) +
    # attempt to get it in the plot itself somewhere
    theme(legend.position = c(.9, .99),
          legend.location = "inside",
          legend.key.height = unit(2, "mm"),
          ## legend.background = element_rect(colour = "black")
          legend.background = element_blank(),
          panel.border = element_blank(),
          axis.line = element_line()
          ) +
    labs(x = "Age (Ma)", y = "Scaled Proxy/Solution") +
    ## geom_ribbon(aes(ymin = ecc_sln, ymax = -ecc), fill = "red", alpha = .3) +
    ## geom_line(aes(y = dt * 50)) +
    ## geom_ribbon(aes(ymin = min(scale(SD)[, 1]) - 8,
    ##                 ymax = scale(SD)[, 1] - 8),
    ##             fill = "black", alpha = .3) +
    geom_vline(aes(xintercept = age * 1e-3, colour = site),
               alpha = .15,
               data = \(d) d |>
                      distinct(proxy, site, sol, detrend_type, depth_chunk, the_best) |>
                      mutate(summary = map(the_best, "summary")) |>
                      unnest(summary) |>
                      mutate(age = kpg_age + age_floating + age_slider)) +
    geom_line(aes(
      ## y = -ecc,
      y = ecc, # for MS
      group = site, colour = site)) +
    geom_line(aes(y = ecc_sln, colour = "Solution"))
  pl_age_matches_MS
#+end_src

#+RESULTS:
[[file:imgs/sol_SD_MS.pdf]]

**** cumulative SD from young to old
:PROPERTIES:
:CREATED:  [2024-03-21 Thu 16:14]
:END:
don't know why Lstar sopelana is off-rails now
#+begin_src R :results output graphics file :file imgs/cumulative_rRMSD_all.pdf :width 5 :height 6
  overall_sd |>
    ## tidylog::inner_join(best_age_optim_one |> select(-the_best)) |>
    ## filter(proxy == "Lstar") |>
    tidylog::filter(depth_chunk == "full record") |>
    tidylog::filter(roll == 1e10,
                    #frac == 0.25
                    frac == 0.3,
                    window == "taner",
                    detrend_type == "lin_scl_med",
           ) |>
    arrange(age) |>
    mutate(rRMSD = sqrt(cumsum(SD)),
           .by = c(proxy, detrend_type, depth_chunk, comb, sol)) |>
    ggplot(aes(x = age * 1e-3)) +
    labs(x = "Age (Ma)",
         y = "cumulative RMSD",
         colour = "Orbital\nSolution") +
    scale_colour_brewer(type = "qual", palette = 3) +
    facet_grid(rows = vars(proxy),
               space = "free_y", scales = "free_y") +
    scale_x_reverse(breaks = seq(75, 55, -1)) +
    scale_y_continuous(breaks = seq(0, 50, 10), sec.axis = sec_axis(transform = \(x) x)) +
    geom_line(aes(y = rRMSD, colour = sol,
                  group = paste(sol, proxy))) +
    theme(strip.placement = "outside")
#+end_src

#+RESULTS:
[[file:imgs/cumulative_rRMSD_all.pdf]]

**** cumulative SD with matches
:PROPERTIES:
:CREATED:  [2024-05-06 Mon 11:15]
:END:
#+begin_src R
  (pl_age_matches +
   coord_cartesian(xlim = c(71, 66)))/
    (
      overall_sd |>
      ## tidylog::inner_join(best_age_optim_one |> select(-the_best)) |>
      ## filter(proxy == "Lstar") |>
      tidylog::filter(depth_chunk == "full record") |>
      tidylog::filter(roll == 1e10,
                      frac == 0.25,
                      ## frac == 0.3,
                      window == "taner",
                      detrend_type == "lin_scl_med",
                      comb == "1:1",
                      proxy == "Lstar",
             ) |>
      arrange(age) |>
      mutate(rRMSD = sqrt(cumsum(SD)),
             .by = c(proxy, detrend_type, depth_chunk, comb, sol)) |>
      ggplot(aes(x = age * 1e-3)) +
      labs(x = "Age (Ma)",
           y = "cumulative RMSD",
           colour = "Orbital\nSolution") +
      scale_colour_brewer(type = "qual", palette = 3) +
      ## facet_grid(rows = vars(proxy),
      ##            space = "free_y", scales = "free_y") +
      scale_x_reverse(breaks = seq(75, 55, -1)) +
      scale_y_continuous(breaks = seq(0, 50, 10)) +
      geom_line(aes(y = rRMSD, colour = sol,
                    group = paste(sol, proxy))) +
      geom_vline(aes(xintercept = age * 1e-3, colour = sol),
                 alpha = .15,
                 data = \(d) d |>
                        distinct(proxy, site, sol, detrend_type, depth_chunk, the_best) |>
                        mutate(summary = map(the_best, "summary")) |>
                        unnest(summary) |>
                        mutate(age = kpg_age + age_floating + age_slider)) +
      theme(strip.placement = "outside") +
       coord_cartesian(xlim = c(71, 66))) +
    plot_layout(guides = "collect", axes = "collect")

#+end_src
**** simplified plot of matched records and solutions
:PROPERTIES:
:CREATED:  [2024-01-15 Mon 15:22]
:END:
# #+begin_src R :results output graphics file :file imgs/Zumaia_Lstar_1-1_solutions_simple.png :width 2400 :height 2000 :res 300
# #+begin_src R :results output graphics file :file imgs/Zumaia_d13C_1-1_solutions_simple.pdf :width 9.6 :height 8
# #+begin_src R :results output graphics file :file imgs/Zumaia_MS_1-1_solutions_simple.pdf :width 9.6 :height 8
#+begin_src R
  my_filt <- \(x) x |>
                    filter(comb == "1:1") |>
                    filter(proxy == "Lstar") |>
                    ## filter(proxy == "MS") |>
                    ## filter(proxy == "d13C") |>
                    # I think I may have re-run the ZB20a < 109 lin_scl_fine
                    tidylog::distinct(sol, site, proxy, depth_chunk, comb,
                                      detrend_type, #window,
                             .keep_all = TRUE) |>
                    ## filter(window == "gaussian") |>
                    filter(depth_chunk == "full record")

  baoo <- best_age_optim_one |>
    my_filt() |>
    mutate(m = map(the_best, "matched")) |>
    unnest(m)
#+end_src

#+RESULTS:
: distinct: no rows removed

#+begin_src R :results output graphics file :file imgs/Zumaia_Lstar_1-1_solutions_simple.pdf :width 9.6 :height 8
  another <- best_age_optim |>
  ## rolling_age_optim |>
    my_filt() |>
    mutate(m = map(the_best, "matched")) |>
    unnest(m)

  another_crit <- another |>
    filter(site == "Sopelana") |>
    summarize(min_age = min(age),
              .by = c(proxy, sol))

  another <- another |>
    tidylog::left_join(another_crit) |>
    tidylog::filter(!(site == "Zumaia" & age > min_age))

  another |>
    ggplot(aes(x = age * 1e-3,
               y = sign_405 * ecc,
               ## colour = site,
               ## colour = detrend_type,
               ## colour = paste(site, depth_chunk),
               ## linetype = window,
               group = paste(sol,
                             site, proxy,
                             detrend_type,
                             depth_chunk## ,
                             ## window
                             ))) +
    facet_grid(rows = vars(sol)) +
    labs(x = "Age (Ma)", y = "Norm. Filter & Solution",
         colour = "") +
    ## theme(legend.pos = c(.64, .864),
    ##       legend.direction = "horizontal") +
    scale_x_reverse(breaks = seq(80, 50, -1),
                    minor_breaks = seq(80, 50, -0.1)) +
    scale_y_continuous(breaks = c(-4, 0, 4)) +
    scale_linewidth_continuous(range = c(1.2, 0.8)) +
    scale_alpha_continuous(range = c(1, 0.4)) +
    scale_colour_manual(values = c("Astronomical Solution" = "black",
                                   "Data"="purple"),
                        guide = guide_legend(override.aes = list(alpha = 1))) +
    geom_vline(aes(xintercept = age1),
               colour = "darkgray",
               data = kpg_ages |>
                 filter(sln != "La11") |>
                 rename(sol = sln)) +
    # plot all fits as thin lines
    ## geom_line(linewidth = .1, alpha = .3) +
    # add the BEST fits for each segment/proxy/solution
    geom_line(aes(## linewidth = RMSD,
                  ## alpha = SD,
                  colour = "Data"
                  ), data = baoo) +

    # annotate astronomical solution
    geom_line(aes(x = age * 1e-3, y = scl, group = sol,
                  colour = "Astronomical Solution"),
              inherit.aes = FALSE,
              data = slns |>
                filter(sln != "La11") |>
                filter(age > 65800) |>
                filter(age < 71300) |>
                rename(sol = sln)) #+
    # this has some ugly dups
    ## geom_line(aes(y = ecc_sln, colour = "Astronomical Solution"),
    ##           data = \(x) x |>
    ##                       distinct(sol, proxy, comb, age, depth_chunk, ecc_sln, .keep_all = TRUE) |>
    ##                       filter(depth_chunk == "full record",
    ##                              proxy == "Lstar",
    ##                              comb == "1:1")) +
    ## geom_line(aes(y = SD, linewidth = RMSD, alpha = RMSD)) +

    ## # annotate overall best fit scores
    ## geom_errorbar(aes(xmin = 71.1, xmax = 65.9, x = 71, y = 9,
    ##                   group = sol),
    ##               colour = "gray",
    ##               data = overal_best_sol |>
    ##                 filter(proxy == "Lstar", comb == "1:1")) +
    ## geom_text(aes(x = 65.9 + (71.1 - 65.9) / 2, y = 10,
    ##               label = round(RMSD, 3), group = sol),
    ##           colour = "black",
    ##           size = 2, show.legend = FALSE,
    ##           data = overal_best_sol |>
    ##                 filter(proxy == "Lstar", comb == "1:1")) +
    ## ## geom_text(aes(x = 65.9 + (71.1 - 65.9) / 2, y = 11,
    ## ##               label = paste(detrend_type, window), group = sol),
    ## ##           size = 2, show.legend = FALSE,
    ## ##           colour = "black",
    ## ##           data = overal_best_sol |>
    ## ##                 filter(proxy == "Lstar", comb == "1:1")) +

    ## # best fits for subsets of the data
    ## geom_errorbarh(aes(xmin = lwr * 1e-3,
    ##                    xmax = upr * 1e-3,
    ##                    y = -7 +
    ##                      14 * as.integer(depth_chunk == "full record") +
    ##                      -0.5 * as.integer(site == "Sopelana")),
    ##                height = 1, alpha = .4,
    ##                data = best_age_optim_one |>
    ##                  my_filt() |>
    ##                  mutate(
    ##                    age = map_dbl(the_best,
    ##                                  \(x) mean(x$matched$age,
    ##                                            na.rm = TRUE)),
    ##                    lwr = map_dbl(the_best,
    ##                                  \(x) min(x$matched$age,
    ##                                           na.rm = TRUE)),
    ##                    upr = map_dbl(the_best,
    ##                                  \(x) max(x$matched$age,
    ##                                           na.rm = TRUE)))) +
    ## ## geom_line(aes(y = -7 + 14 * as.integer(depth_chunk == "full record")),
    ## ##           linewidth = 1, alpha = .05,
    ## ##           data = \(x) x |> distinct(sol, proxy, site, depth_chunk, age, .keep_all = TRUE)) +
    ## geom_text(aes(x = age * 1e-3, y = -6 +
    ##                                 12 * as.integer(depth_chunk == "full record") +
    ##                                 -0.5 * as.integer(site == "Sopelana"),
    ##               label = round(RMSD, 3)),
    ##           size = 2, show.legend = FALSE,
    ##           data = best_age_optim_one |>
    ##             my_filt() |>
    ##             mutate(age = map_dbl(the_best,
    ##                                  \(x) mean(x$matched$age,
    ##                                              na.rm = TRUE)))) #+
    ## ## geom_text(aes(x = age * 1e-3, y = -8 +
    ## ##                                 16 * as.integer(depth_chunk == "full record") +
    ## ##                                 -0.5 * as.integer(site == "Sopelana"),
    ## ##               label = paste(site, detrend_type, window)),
    ## ##           size = 2, show.legend = FALSE,
    ## ##           data = best_age_optim_one |>
    ## ##             my_filt() |>
    ## ##             mutate(age = map_dbl(the_best,
    ## ##                                  \(x) mean(x$matched$age,
    ## ##                                              na.rm = TRUE)))) #+

    ## ## annotate ages of 405 kyr minima
    ## geom_point(aes(x = age * 1e-3, y = -3.5),
    ##            inherit.aes = FALSE,
    ##            data = sln_peaks |>
    ##              rename(sol = sln) |>
    ##              filter(sol != "La11") |>
    ##              filter(age > 65.8e3) |>
    ##              filter(age < 71.4e3)) +

    ## # annotate depths of tweaked tiepoints
    ## geom_point(aes(x = (age_floating + kpg_age + age_slider) * 1e-3, y = -4),
    ##            ## shape = ".",
    ##           data = best_age_optim |>
    ##             filter(comb == "1:1") |>
    ##             filter(proxy == "Lstar") |>
    ##             filter(detrend_type == "lin_scl_med") |>
    ##             filter(depth_chunk == "full record") |>
    ##             mutate(m = map(the_best, "summary")) |>
    ##             unnest(m))
    ## geom_text(aes(x = (age_floating + kpg_age + age_slider) * 1e-3, y = -4.5,
    ##               label = paste(strat_bot, tie_err)),
    ##           size = 1.8,
    ##           show.legend = FALSE,
    ##           data = best_age_optim |>
    ##             filter(comb == "1:1") |>
    ##             filter(proxy == "Lstar") |>
    ##             filter(detrend_type == "lin_scl_fine") |>
    ##             mutate(m = map(the_best, "summary")) |>
    ##             unnest(m))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_Lstar_1-1_solutions_simple.pdf]]

**** illustration of how different detrending results in different output
:PROPERTIES:
:CREATED:  [2024-03-25 Mon 15:27]
:END:
#+begin_src R :results output graphics file :file imgs/sol_SD_detrend.pdf :width 7 :height 7
  pl_age_matches +
    geom_line(aes(y = -ecc, group = site, colour = site),
              ## linetype = "dotted",
              alpha = .5,
              data = overall_sd |> filter(detrend_type == "scl")) +
    geom_vline(aes(xintercept = 1e-3 * (kpg_age + age_floating + age_slider),
                   colour = site),
               alpha = .05,
      data = overall_sd |>
        filter(detrend_type == "scl") |>
        mutate(sum = map(the_best, "summary")) |>
        distinct(sol, site, proxy, detrend_type, sum) |>
        unnest(sum)
    )
#+end_src

#+RESULTS:
[[file:imgs/sol_SD_detrend.pdf]]

**** illustration of how different filter widths affect output
:PROPERTIES:
:CREATED:  [2024-03-25 Mon 15:27]
:END:
#+begin_src R :results output graphics file :file imgs/sol_SD_filterwidth.pdf :width 7 :height 7
  pl_age_matches +
    geom_line(aes(y = -ecc, group = site, colour = site),
              alpha = .5,
              data = overall_sd |>
                filter(depth_chunk == "full record") |>
                filter(roll == 1e10, frac == 0.23) |>
                filter(proxy == "Lstar")) +
    geom_vline(aes(xintercept = 1e-3 * (kpg_age + age_floating + age_slider),
                   colour = site),
               alpha = .05,
      data = overall_sd |>
        filter(detrend_type == "scl") |>
        mutate(sum = map(the_best, "summary")) |>
        distinct(sol, site, proxy, detrend_type, sum) |>
        unnest(sum)
    )
#+end_src

#+RESULTS:
[[file:imgs/sol_SD_filterwidth.pdf]]

**** COMMENT SD as a function of time
:PROPERTIES:
:CREATED:  [2024-03-21 Thu 16:23]
:END:

#+begin_src R :results output graphics file :file imgs/sol_SD.pdf :width 9 :height 2
  overall_sd |>
    tidylog::inner_join(best_age_optim_one |> select(-the_best)) |>
    filter(proxy == "Lstar") |>
    ggplot(aes(x = age * 1e-3)) +
    ## facet_grid(rows = vars(sol)) +
    scale_x_reverse(breaks = seq(66, 73, 1)) +
    labs(x = "Age (Ma)", y = "Norm. Scaled Proxy") +
    ## geom_ribbon(aes(ymin = ecc_sln, ymax = -ecc), fill = "red", alpha = .3) +
    geom_line(aes(#ymin = min(scale(SD)[, 1]) - 8,
                    #ymax = scale(SD)[, 1] - 8),
      y = SD, colour = sol),
                ## fill = "black", alpha = .3
      )
#+end_src

#+RESULTS:
[[file:imgs/sol_SD.pdf]]

**** COMMENT rerun the best fits with detailed output
:PROPERTIES:
:CREATED:  [2023-12-13 Wed 10:56]
:END:
#+begin_src R
  best_age_details <- best_age_optim |>
    mutate(deets = furrr::future_map2(
                               .x = data, .y = sol,
                               .f = ~ .x |> wrap_age_model(
                                     agemodel = agem_sol |>
                                       filter(sol == .y),
                                     astronomical_solution = slns |>
                                       filter(sln == .y),
                                     ## tiepoint_uncertainty = ,
                                     # default -4, 4, .5
                                     output = "details"),
                               .progress = TRUE
                          )) |>
    write_rds("out/2023-12-13_best_age_details.rds")
#+end_src

**** COMMENT plot RMSD as a function of depth
#+begin_src R :results output graphics file :file imgs/rolling_age_vs_strat_bot.png :width 2400 :height 3200 :res 300
  # vs depth
  rolling_age_optim |>
    select(-sol) |>
    unnest(c(the_best)) |>
    ggplot(aes(x = strat_bot + error, y = RMSD_tie,
               shape = comb, linetype = comb,
               colour = detrend_type,
               group = paste(site, sol, proxy, comb, detrend_type))) +
    facet_grid(
      #cols = vars(## proxy,
      #sol),
      rows = vars(
        proxy,
        sol,
        #detrend_type
               )) +
    scale_x_reverse() +
    scale_linetype_manual(values = c("1:1" = "solid",
                                     "1:0.5" = "dashed",
                                     "0.5:1" = "dotted")) +
    geom_vline(aes(xintercept = strat_bot),
               data = \(x) x |>
                           distinct(n, strat_bot,
                                    site,proxy,comb,detrend_type,sol,comb)) +
    geom_line(aes(group = paste(n, proxy, site, detrend_type, comb))) +
    ## geom_point() +
    geom_point(aes(x = strat_bot, y = 0.8),
               size = 3,
               shape = "triangle",
               inherit.aes = FALSE,
               data = agem_sol |>
                 filter(comment == "well-defined"))
#+end_src

#+attr_latex: :width 1.2\textwidth
#+caption: Evolving RMSD scores as the next (towards the left) agemodel tiepoint (black lines) is adjusted by \pm4 m in order to get a better overall fit of the record to the astronomical solution for each proxy (row panels). Colours indicate different ways of detrending the record. Black triangles mark "well-defined" 405 kyr minima [cite:@Batenburg2012;@Batenburg2014]. Note that currently, the Sopelana records' top is not fixed to the optimal Zumaia record's bottom.
#+RESULTS:
[[file:imgs/rolling_age_vs_strat_bot.png]]

**** COMMENT plot best fits RMSD evolution vs depth
:PROPERTIES:
:CREATED:  [2023-12-13 Wed 15:15]
:END:
#+begin_src R :results output graphics file :file imgs/best_age_details_tiepoint_uncertainty.png :width 2400 :height 3200 :res 300
  ## best_age_details <- read_rds("out/2023-12-13_best_age_details.rds")
  ## best_age_details |>
  rolling_age_optim |>
    select(-sol) |>
    unnest(the_best) |>
    ggplot(aes(x = strat_bot + error,
               y = RMSD_tie, col = detrend_type, linetype = comb,
               group = paste(proxy,detrend_type,site,comb,sol,n))) +
    facet_grid(rows = vars(proxy, sol)) +
    labs(x = "Depth (m)", y = "RMSD") +
    geom_vline(aes(xintercept = strat_bot), colour = "gray", data = agem_sol) +
    scale_linetype_manual(values = c("1:1" = "solid",
                                     "1:0.5" = "dashed",
                                     "0.5:1" = "dotted")) +
    geom_line() +
    ## geom_line(aes(y = RMSD_tie, group = n), colour = "black", linetype = 1, data = tst4$details) +
    ## geom_line(aes(y = RMSD_tie, group = n), colour = "black", linetype = 1, data = tst2$details) +
    ## geom_point(aes(y = RMSD_cum), colour = "black", shape = 21, data = tst4$summary) +
    geom_point(colour = "red", size = .3,
               data = \(x) x |>
                           filter(RMSD_tie == min(RMSD_tie),
                                  .by = c(sol, proxy, site, detrend_type, comb, ## filt_env,
                                          n))) +
    scale_x_reverse()
#+end_src

#+name: fig:rolling-rmsd-improvement
#+attr_latex: :width 1.2\textwidth
#+caption: Tiepoint error RMSD score improvement for the best overall RMSD scores (larger triangles in cref:fig:rolling-rmsd). Vertical gray lines indicate tiepoints as identified in the field, red dots indicate "optimal" adjustments to these tiepoints when considering the whole record and the previous best fits (going from right to left, young to old). *NOTE:* the tiepoints for d13C merging at Ma_{405}8. *NOTE*: different optimal tiepoints for Zumaia (right) and Sopelana (left) in practically all solutions.
#+RESULTS:
[[file:imgs/best_age_details_tiepoint_uncertainty.png]]

**** COMMENT make a figure of the best records vs depth
:PROPERTIES:
:CREATED:  [2023-12-09 Sat 00:02]
:END:
#+begin_src R :results output graphics file :file imgs/rolling_age_best_records_depth.png :width 2400 :height 2200 :res 300
  best_age_optim |>
    unnest(data) |>
    ggplot(aes(x = depth, y = ecc,
               colour = detrend_type,
               shape = comb,
               linetype = comb#alpha = RMSD
               )) +
    facet_grid(rows = vars(proxy, sol)## , cols = vars(comb)
               ) +
    scale_x_reverse() +
    scale_y_continuous(breaks = c(-2, 0, 2)) +
    scale_linetype_manual(values = c("1:1" = "solid",
                                     "1:0.5" = "dashed",
                                     "0.5:1" = "dotted")) +
    # annotate tiepoints + uncertainty + best
    geom_vline(aes(xintercept = strat_bot), colour = "gray", data = agem_sol) +
    geom_point(aes(x = depth, y = -2),
               shape = ".",
               inherit.aes = FALSE,
               colour = "gray", data = agem_tie) +
    geom_point(aes(x = strat_bot, y = -2.6),
               size = 2,
               shape = "triangle",
               inherit.aes = FALSE,
               data = agem_sol |>
                 filter(comment == "well-defined")) +
    geom_point(aes(x = depth, y = -2),
               colour = "purple",
               data = \(x) x |> select(-depth, -sol) |> unnest(the_best)) +
    # the below is nice but a bit too messy
    ## geom_text(aes(x = depth, y = -2, label = round(RMSD_cum, 3)),
    ##            colour = "purple",
    ##            data = \(x) x |> select(-depth, -sol) |> unnest(the_best)) +
    ## scale_alpha_binned(range = c(1, .1)) +
    ## scale_linewidth_binned(range = c(3, .1)) +
    # annotate astronomical solution
    ## geom_line(aes(x = depth / 1e3, y = scl),
    ##           inherit.aes = FALSE, colour = "gray",
    ##           data = slns |>
    ##             filter(sln != "La11") |>
    ##             filter(age < 71.4e3, age > 65.8e3) |>
    ##             rename(sol = sln)) +
    # draw the best fits
    geom_line(aes(group = paste(proxy, site, sol, detrend_type, comb, filt_env, sol))) +
    # annotate RMSD score
    geom_text(aes(label = round(RMSD, 3)),
              position = position_jitter(height = 2.5, width = 0),
              hjust = 0, size = 3,
              data = \(x) x |> distinct(proxy, site, sol,
                                        detrend_type, comb,
                                        filt_env, sol, RMSD,
                                        .keep_all = TRUE)) +
    ## geom_point() +
    labs(x = "Depth (Ma)", y = "Normalized filtered record", colour = "Detrend type")
#+end_src

#+attr_latex: :width 1.2\textwidth
#+name: fig:rolling-depth
#+caption: *Best rolling tiepoint uncertainty fits in the depth domain.* Vertical gray lines show 405 kyr minima as identified in the field, with well-defined ones highlighted with a black triangle. Gray dots show all tiepoint uncertainties looked at (\pm4 m), with the optimal (lowest overal RMSD score) tiepoint marked in purple. Numbers indicate RMSD score for the adjacent fit. *NOTE*: mistake in the d13C record, where the uncertainties were so large that they allow the fitting function to skip a 405 kyr cycle. *NOTE*: Sopelana top is not linked to Zumaia base best tiepoint uncertainty.
#+RESULTS:
[[file:imgs/rolling_age_best_records_depth.png]]

**** COMMENT get the data vs time
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 14:16]
:END:
#+begin_src R
  smooth_optim_age <- rolling_age_optim |>
      ## slice(1) |>
      mutate(
        the_best = map(the_best,
                       \(b) b |>
                            mutate(depth = strat_bot + tie_err))) |>
      ## select(-sol) |> unnest(the_best)
      mutate(
        data = map2(data, the_best,
                    \(d, b) d |>
                            mutate(age = Hmisc::approxExtrap(b$depth, b$age, xout = depth)$y))) |>
      mutate(RMSD = map_dbl(the_best, \(x) x |>
                                           filter(n == max(n), .by = c(sol)) |>
                                           pull(RMSD_cum))) |>
      unnest(data) #|>
      ## tidylog::filter(RMSD == min(RMSD), .by = c(proxy, site, sol))
#+end_src

#+RESULTS:

**** COMMENT best records against age
#+begin_src R :results output graphics file :file imgs/rolling_age_best_records.png :width 2400 :height 2200 :res 300
  smooth_optim_age |>
    tidylog::filter(RMSD == min(RMSD), .by = c(proxy, site, sol)) |>
    ggplot(aes(x = age / 1e3, y = ecc,
               colour = detrend_type,
               shape = comb,# alpha = RMSD
               ## linetype = comb,
               alpha = comb,
               )) +
    facet_grid(rows = vars(proxy, sol)## , cols = vars(comb)
               ) +
    scale_x_reverse() +
    scale_y_continuous(breaks = c(-2, 0, 2)) +
    scale_alpha_manual(values = c("1:1" = 1,
                                  "1:0.5" = 0.7,
                                  "0.5:1" = 0.8)) +
    ## scale_linetype_manual(values = c("1:1" = "solid",
    ##                                  "1:0.5" = "dashed",
    ##                                  "0.5:1" = "dotted")) +
    # annotate astronomical solution
    geom_line(aes(x = age / 1e3, y = scl),
              inherit.aes = FALSE, colour = "gray",
              data = slns |>
                filter(sln != "La11") |>
                filter(age < 71.4e3, age > 65.8e3) |>
                rename(sol = sln)) +
    # draw the best fits
    geom_line(aes(group = paste(proxy, site, sol, detrend_type, comb, filt_env, sol))) +
    # annotate RMSD score
    geom_text(aes(label = round(RMSD, 3)),
              position = position_jitter(height = 2., width = 0),
              hjust = 0, size = 3,
              data = \(x) x |> distinct(proxy, site, sol,
                                        detrend_type, comb,
                                        filt_env, sol, RMSD,
                                        .keep_all = TRUE)) +
    ## geom_point() +
    labs(x = "Age (Ma)", y = "Normalized filtered record", colour = "Detrend type")
#+end_src

#+attr_latex: :width 1.2\textwidth
#+name: fig:rolling-age
#+caption: *The best filtered Zumaia/Sopelana matches using the rolling tweaked tiepoint uncertainty.* Numbers indicate RMSD score for the adjacent fit. *NOTE:* skipped cycle in the d13C, which is a result of the large input \pm4 m uncertainty on the 405 kyr minima as identified in the field. Will need fixing!
#+RESULTS:
[[file:imgs/rolling_age_best_records.png]]

**** calculate spectra in the time domain
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 14:15]
:END:
Here we use the new "optimal" age models and apply them to the raw data, then we do spectral analysis in the time domain on those new records.
***** COMMENT interpolate the original data back
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 14:33]
:END:
#+begin_src R
  smooth_optim_age_value <- smooth_optim_age |>
    # I think I need to interpolate because of previous linear interpolation?
    tidylog::left_join(
               smooth_pred |>
               select(-c(comment, colour, lin, lin_gam)) |>
               nest(data = c(depth, value))
             ) |>
    mutate(value = map2_dbl(depth, data, \(x, y) approx(y$depth, y$value, xout = x)$y)) |>
    select(-data)
#+end_src

#+RESULTS:
: Error: object 'smooth_optim_age' not found
***** extract the fitted data
:PROPERTIES:
:CREATED:  [2024-01-15 Mon 13:57]
:END:
#+begin_src R
  smooth_optim_age_value <- best_age_optim |>
    tidylog::filter(site == "Zumaia", comb == "1:1", depth_chunk == "full record") |>
    ## distinct(site, proxy)
    mutate(data = map(the_best, \(x) x$matched)) |>
    select(-the_best, -RMSD) |>
    unnest(data)
#+end_src

#+RESULTS:
: filter: removed 791 rows (74%), 280 rows remaining
***** remove the big bois
:PROPERTIES:
:CREATED:  [2024-03-06 Wed 15:42]
:END:
#+begin_src R
  rm(rolling_age_optim, best_age_optim, best_age_optim_one)
#+end_src
***** FFT periodogram
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 15:06]
:END:
#+begin_src R
  specs_fft_optim_age <- smooth_optim_age_value |>
    nest(.by = c("proxy", "site", "depth_chunk", "detrend_type", "sol", "comb", "window")) |>
    mutate(fft = map(data,
                      ~ . |>
                        select(age, value) |>
                        astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                        astrochron::periodogram(genplot = F, verbose = F, output = 1) |>
                        as_tibble()
                        )) |>
    select(-data) |>
    unnest(cols = c(fft)) |>
    rename(frequency = Frequency, amplitude = Amplitude, power = Power, phase = Phase)
#+end_src

#+RESULTS:

***** BT
:PROPERTIES:
:CREATED:  [2024-02-28 Wed 16:43]
:END:
#+begin_src R
    specs_optim_age_bt <- smooth_optim_age_value |>
       nest(.by = c("proxy", "site", "depth_chunk", "detrend_type", "sol", "comb", "window")) |>
       mutate(mtls = map(data,
                         ~ . |>
                           select(age, value) |>
                           astrochron::linterp(dt = 3, genplot = FALSE, verbose = FALSE) |>
                           pull(value) |>
                           TSAUMN::spec.bt(deltat = 3, q = 100,
                                           plot = FALSE, demean = TRUE, detrend = TRUE)
                         )) |>
       select(-data) |>
      mutate(frequency = map(mtls, "freq"),
             spectrum = map(mtls, "spec")) |>
      select(-mtls) |>
      unnest(c(frequency, spectrum))
#+end_src

  #+RESULTS:
  : Registered S3 method overwritten by 'quantmod':
  :   method            from
  :   as.zoo.data.frame zoo


#+begin_src R
    specs_optim_age_bt |>
      ## filter(site == "Zumaia", proxy == "Lstar", detrend_type == "scl") |>
      ggplot(aes(x = frequency, y = spectrum)) +
      geom_line(aes(group = paste(depth_chunk, window, detrend_type, comb, sol)))
#+end_src

#+RESULTS:

***** LS
:PROPERTIES:
:CREATED:  [2024-02-28 Wed 16:43]
:END:
#+begin_src R
  specs_optim_age_ls <- smooth_optim_age_value |>
    nest(.by = c("proxy", "site", "depth_chunk", "detrend_type", "sol", "comb", "window")) |>
    mutate(mtls = map(data,
                      ~ . |>
                        select(age, value) |>
                        TSAUMN::spec.ls(plot = FALSE,
                                        over = 5,
                                        demean = TRUE, detrend = TRUE) |>
                        as_tibble())) |>
    select(-data) |>
    unnest(mtls) |>
    rename(frequency = freq, power = spec)
#+end_src

  #+RESULTS:

***** mtm
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 15:06]
:END:
#+begin_src R
  specs_optim_age <- smooth_optim_age_value |>
    nested_spectral_analysis(nest = c("proxy", "site",  "depth_chunk", "detrend_type", "sol", "comb", "window"),
                      x = age, y = value)
#+end_src

#+RESULTS:

***** mtm with more tapers
:PROPERTIES:
:CREATED:  [2024-02-28 Wed 15:21]
:END:
#+begin_src R
  specs_optim_age_tap_10 <- smooth_optim_age_value |>
    nested_spectral_analysis(nest = c("proxy", "site", "depth_chunk", "detrend_type", "sol", "comb", "window"),
                             x = age, y = value,
                             ntap = 10)
#+end_src

#+RESULTS:

***** mtm with a power law
:PROPERTIES:
:CREATED:  [2024-02-28 Wed 15:29]
:END:
#+begin_src R
  specs_optim_age_pl <- smooth_optim_age_value |>
    nest(.by = c("proxy", "site", "depth_chunk", "detrend_type", "sol", "comb", "window")) |>
    mutate(mtm = map(data,
                     ~ . |>
                       select(age, value) |>
                       astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                       astrochron::mtmPL(genplot = FALSE,
                                         verbose = FALSE,
                                         output = 1,
                                         demean = TRUE, detrend = TRUE) |>
                       as_tibble() |>
                       tidyr::pivot_longer(c("PowerLaw_90_power",
                                             "PowerLaw_95_power",
                                             "PowerLaw_99_power"),
                                           names_to = c("PL", ".width"),
                                           names_pattern = "^(PowerLaw)_(9[950])",
                                           values_to = "powerlaw_power") |>
                       dplyr::select(-"PL") |>
                       dplyr::mutate(.width = readr::parse_double(paste0(".", .data$.width))) |>
        dplyr::rename(frequency = "Frequency",
                      power = "Power",
                      harmonic_cl = "Harmonic_CL",
                      powerlaw_cl = "PowerLaw_CL",
                      powerlaw_fit = "PowerLaw_fit")
                     )) |>
    select(-data) |>
    unnest(cols = c(mtm))
#+end_src

#+RESULTS:

***** mtmML96
:PROPERTIES:
:CREATED:  [2024-02-28 Wed 16:02]
:END:
#+begin_src R
  specs_optim_age_ML96 <- smooth_optim_age_value |>
    nest(.by = c("proxy", "site", "depth_chunk", "detrend_type", "sol", "comb", "window")) |>
    mutate(mtm = map(data,
                     ~ . |>
                       select(age, value) |>
                       astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                       astrochron::mtmML96(genplot = FALSE,
                                           verbose = FALSE,
                                           output = 1,
                                           demean = TRUE, detrend = TRUE) |>
                       as_tibble() |>
                       tidyr::pivot_longer(c("AR1_90_power",
                                             "AR1_95_power",
                                             "AR1_99_power"),
                                           names_to = c("AR1", ".width"),
                                           names_pattern = "^(AR1)_(9[950])",
                                           values_to = "ar1_power") |>
                       dplyr::select(-"AR1") |>
                       dplyr::mutate(.width = readr::parse_double(paste0(".", .data$.width))) |>
                       dplyr::rename(frequency = "Frequency",
                                     power = "Power",
                                     harmonic_cl = "Harmonic_CL",
                                     ar1_cl = "AR1_CL",
                                     ar1_fit = "AR1_fit")
                     )) |>
    select(-data) |>
    unnest(cols = c(mtm))
#+end_src

#+RESULTS:

***** mtmAR
:PROPERTIES:
:CREATED:  [2024-02-28 Wed 16:11]
:END:
#+begin_src R
  specs_optim_age_AR <- smooth_optim_age_value |>
    nest(.by = c("proxy", "site", "depth_chunk", "detrend_type", "sol", "comb", "window")) |>
    mutate(mtm = map(data,
                     ~ . |>
                       select(age, value) |>
                       astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                       astrochron::mtmAR(genplot = FALSE,
                                           verbose = FALSE,
                                           output = 1,
                                           demean = TRUE, detrend = TRUE) |>
                       as_tibble()
                     )) |>
    select(-data) |>
    unnest(cols = c(mtm))
#+end_src

#+RESULTS:

***** LOWSPEC
:PROPERTIES:
:CREATED:  [2024-02-28 Wed 15:49]
:END:
#+begin_src R
  specs_optim_age_lowspec <- smooth_optim_age_value |>
    nested_spectral_analysis(nest = c("proxy", "site", "depth_chunk", "detrend_type", "sol", "comb", "window"),
                             x = age, y = value,
                             method = "LOWSPEC")
#+end_src

#+RESULTS:

***** MTLS
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 15:06]
:END:
#+begin_src R :eval never
  specs_optim_age_mtls <- smooth_optim_age_value |>
    nest(.by = c("proxy", "site", "depth_chunk", "detrend_type", "sol", "comb", "window")) |>
    mutate(mtls = map(data,
                      ~ . |>
                        select(age, value) |>
                        # NOTE: no need to linearly interpolate!
                        # That's the point!
                        TSAUMN::spec.mtls(plot = FALSE,
                                          nw = 10, k = 2 * 10 - 1,
                                          demean = TRUE, detrend = TRUE) |>
                        as_tibble())) |>
    select(-data) |>
    unnest(mtls) |>
    rename(frequency = freq, power = spec) |>
    write_rds("out/specs_optim_age_mtls.rds")
#+end_src

  #+RESULTS:
#+begin_src R
    specs_optim_age_mtls <- read_rds("out/specs_optim_age_mtls.rds")
#+end_src

#+RESULTS:

***** redfit
:PROPERTIES:
:CREATED:  [2024-02-29 Thu 14:29]
:END:
this only works if you library it!
https://github.com/AndyBunn/dplR/issues/9

#+begin_src R :eval never
  library(dplR)
  # this takes a very long time
  specs_optim_age_redfit <- smooth_optim_age_value |>
    filter(detrend_type %in% c("scl", "lin_scl_med")) |>
    filter(comb == "1:1") |>
    filter(sol == "ZB20a") |>
    filter(window == "rectangular") |>
    filter(depth_chunk == "full record") |>
    nest(.by = c("proxy", "site", "depth_chunk", "detrend_type", "sol", "comb", "window")) |>
    mutate(mtls = map(data,
                      \(x) {
                        # NOTE: no need to linearly interpolate!
                        # That's the point!
                        rf <- redfit(x$value, x$age, nsim = 5000)
                        tibble(freq = rf$freq,
                               gxx = rf$gxx, gxxc = rf$gxxc,
                               ci_80 = rf$ci80, ci_90 = rf$ci90, ci_95 = rf$ci95, ci_99 = rf$ci99) |>
                          pivot_longer(cols = starts_with("ci_"),
                                       names_to = c("ci", ".width"),
                                       names_sep = "_") |>
                          mutate(.width = paste0(".", .width) |>
                                   parse_double())
                      })) |>
    select(-data) |>
    write_rds("out/specs_optim_age_redfit.rds")
#+end_src

#+begin_src R
  specs_optim_age_redfit <- read_rds("out/specs_optim_age_redfit.rds") |>
    unnest(mtls) |>
    rename(frequency = freq, power = gxxc)
#+end_src

#+RESULTS:

**** plot spectra
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 15:04]
:END:
# #+begin_src R :results output graphics file :file imgs/Zumaia_Sopelana_spectra_optimal.png :width 2400 :height 2200 :res 300
#+begin_src R :results output graphics file :file imgs/Zumaia_Sopelana_spectra_optimal.pdf :width 6 :height 5
  my_filter <- \(x) x |>
                      filter(sol == "ZB20a") |>
                      filter(site == "Zumaia") |>
                      filter(proxy == "Lstar") |>
                      filter(comb == "1:1") |>
                      filter(window == "rectangular") |>
                      ## filter(depth_chunk == "depth < 109.26") |>
                      ## filter(detrend_type == "lin_scl_fine") # only one so we can see different spectral analysis
                      filter(detrend_type == "scl")

  specs_optim_age |>
    my_filter() |>
    ggplot(aes(x = frequency, y = power,
               period = 1 / frequency
               )) +
    labs(x = "Frequency (cycles/kyr)", y = "Power (-)",
         colour = "Spectral Analysis",
         fill = "Bandpass Filters") +
    facet_grid(rows = vars(proxy, sol)) +
    coord_cartesian(
      xlim = c(0, .08),
      ylim = c(.00001, 250)
    ) +
    scale_x_continuous(
      sec.axis = sec_axis("Period (kyr)", transform = \(x) 1 / x,
                          breaks = c(405, 100, 50, 20, 10))) +
    scale_y_log10() +
    geom_rect(aes(xmin = flow, xmax = fhigh,
                  ymin = 1e-6, ymax = 500,
                  fill = ref),
              inherit.aes = FALSE,
              alpha = .1,
              data = bat_age_filters |> filter(proxy == "Lstar")) +
    geom_rect(aes(xmin = flow, xmax = fhigh,
                  ymin = 1e-6, ymax = 500,
                  fill = ref),
              inherit.aes = FALSE,
              alpha = .1,
              data = my_filt_age) +
    scale_fill_manual(values = c("This study" = "black",
                                 "Batenburg et al., 2014" = "green")) +
    ggnewscale::new_scale_fill() +
    labs(fill = "Spectral Analysis") +
    scale_colour_manual(values = c("FFT" = "gray",
                                   "BT" = "indianred",
                                   "LS" = "skyblue",
                                   "detrended MTM" = "darkgray",
                                   "MTM" = "black",
                                   "MTM ML96" = "orange",
                                   "PL" = "purple",
                                   "MTLS" = "navyblue",
                                   "LOWSPEC" = "darkgreen",
                                   "Redfit" = "red")) +

    scale_fill_manual(values = c("AR1" = "gray",
                                 "detrended AR1" = "darkgray",
                                 "PL" = "purple",
                                 "ML96" = "orange",
                                 "LOWSPEC" = "darkgreen",
                                 "Redfit" = "red")) +
    annotation_logticks(sides = "l") + #BREAK

    geom_line(aes(colour = "FFT",
                  group = paste(site, sol, proxy, window, detrend_type)),
              alpha = .4,
              data = specs_fft_optim_age |>
                my_filter()) +#BREAK
    geom_line(aes(colour = "LS",
                  group = paste(site, sol, proxy, window, detrend_type)),
              alpha = .4,
              data = specs_optim_age_ls |>
                my_filter()) + #BREAK
    geom_line(aes(x = frequency, y = spectrum, colour = "BT",
                  group = paste(site, sol, proxy, window, detrend_type)),
              data = specs_optim_age_bt |>
                my_filter()) + #BREAK
    geom_line(aes(colour = "MTM",
                  group = paste(site, sol, proxy, window, detrend_type))) + #BREAK
    geom_ribbon(aes(ymin = ar1_fit, ymax = ar1_power,
                    linetype = NULL, fill = "AR1",
                    group = paste(detrend_type, site, sol, window, proxy, .width)),
                  alpha = .4) +
    geom_line(aes(colour = "MTM",
                  group = paste(site, sol, proxy, window, detrend_type))) + #BREAK
    geom_line(aes(colour = "detrended MTM",
                  group = paste(site, sol, proxy, window, detrend_type)),
              data = specs_optim_age |>
                filter(site == "Zumaia") |>
                filter(sol == "ZB20a") |>
                filter(proxy == "Lstar") |>
                filter(comb == "1:1") |>
                filter(detrend_type == "lin_scl_med")) +
    geom_ribbon(aes(ymin = ar1_fit, ymax = ar1_power,
                    linetype = NULL, fill = "detrended AR1",
                    group = paste(detrend_type, site, sol, window, proxy, .width)),
                alpha = .1,
                data = specs_optim_age |>
                  filter(site == "Zumaia") |>
                  filter(sol == "ZB20a") |>
                  filter(proxy == "Lstar") |>
                  filter(comb == "1:1") |>
                  filter(detrend_type == "lin_scl_med")) + #BREAK

    geom_ribbon(aes(ymin = powerlaw_fit, ymax = powerlaw_power,
                    linetype = NULL, fill = "PL",
                    group = paste(detrend_type, site, sol, window, proxy, .width)),
                alpha = .1,
                data = specs_optim_age_pl |>
                  my_filter()) + #BREAK

    geom_ribbon(aes(ymin = ar1_fit, ymax = ar1_power,
                    linetype = NULL, fill = "ML96",
                    group = paste(detrend_type, site, sol, window, proxy, .width)),
                alpha = .1,
                data = specs_optim_age_ML96 |>
                  my_filter()) +
    geom_line(aes(y = Median_Smoothed_Power, colour = "MTM ML96",
                  group = paste(site, sol, proxy, window, detrend_type)),
              data = specs_optim_age_ML96 |> my_filter()) + #BREAK

    geom_line(aes(colour = "MTLS",
                  group = paste(site, sol, proxy, window, detrend_type)),
              data = specs_optim_age_mtls |> my_filter()) + #BREAK

    geom_line(aes(colour = "LOWSPEC",
                  group = paste(site, sol, proxy, window, detrend_type)),
              data = specs_optim_age_lowspec |> my_filter()) +
    geom_ribbon(aes(ymin = lowspec_fit, ymax = lowspec_power,
                    linetype = NULL, fill = "LOWSPEC",
                    group = paste(detrend_type, site, sol, window, proxy, .width)),
                alpha = .1,
                data = specs_optim_age_lowspec |>
                  my_filter()) + #BREAK
    geom_ribbon(aes(ymin = power, ymax = value,
                    linetype = NULL, fill = "Redfit",
                    group = paste(detrend_type, site, sol, proxy, .width)),
                alpha = .1,
                data = specs_optim_age_redfit |>
                  filter(frequency != 0) |>
                  my_filter()) +
    geom_line(aes(colour = "Redfit",
                  group = paste(site, sol, proxy, detrend_type)),
              data = specs_optim_age_redfit |>
                filter(frequency != 0) |>
                my_filter()) #BREAK
#+end_src

#+attr_latex: :width \linewidth
#+name: fig:specs-optim
#+caption: Zumaia/Sopelana spectral analysis after tuning each of the 405 kyr minima from the field [cite:@Batenburg2012] to 405 kyr mimima in each of the orbital solutions and adjusting them by \pm4 m to get the lowest RMSD score.
#+RESULTS:
[[file:imgs/Zumaia_Sopelana_spectra_optimal.pdf]]

**** a reprex to study how the filter window of the gaussian works
:PROPERTIES:
:CREATED:  [2024-05-09 Thu 10:15]
:END:
a taner filter with a roll of 1e4 is almost identical to a gaussian
#+begin_src R :tangle /tmp/reprex.R
  library(tidyverse)
#+end_src

#+begin_src R :tangle /tmp/reprex.R
  windows <- tibble(roll = c(
                      1e3,
                      1e4, # didn't include, very similar to upscaled gauss
                      ## 1e5, # didn't include these
                      1e6,
                      1e8,
                      1e10,
                      1e12,
                      1e100
                      ## 1e1000,
                    )) |>
    mutate(window = "taner")

  # using my own data
  ## simple <- smooth_ages |>
  ##   filter(detrend_type == "lin_scl_med") |>
  ##   filter(depth_chunk == "full record") |>
  ##   filter(proxy == "Lstar") |>
  ##   filter(site == "Zumaia")

  fac <- 0.25
  pl <- 405
  ps <- 110

  ll <- 1 / pl - fac * (1 / pl)
  hl <- 1 / pl + fac * (1 / pl)

  N <- 1e4 # I've found the best value using 1e5
  # using artificial data
  # make sure it's pretty big so that the astrochron window output is smoother
  ## simple <- tibble::tibble(age_floating = 1:1e5, value = rnorm(1e5))
  ## simple <- tibble::tibble(age_floating = seq_len(N) - 1,
  ##                          value = astrochron::cycles(
  ##                                                ## freqs = c(1 / pl, 1 / ps), # first example simple peak
  ##                                                freqs = c(1 / pl, 1 / c(95, 131)), # widest 100 kyr components
  ##                                                start = 0, end = N - 1,
  ##                                                genplot = FALSE)$value,
  ##                          noise = rnorm(N),
  ##                          res = value + noise)

  # use a real solution instead
  simple <- snvecR::get_solution("ZB20a") |>
    slice(1:N) |>
    rename(age_floating = time, value = ecc) |>
    mutate(noise = rnorm(N), res = scale(value)[, 1] + noise)
#+end_src

#+RESULTS:

#+begin_src R :tangle /tmp/reprex.R
  simple |>
    ggplot(aes(x = age_floating, y = scale(value)[, 1])) +
    ## geom_line(aes(y = noise), colour = "blue") +
    geom_line(aes(y = res), colour = "red", alpha = .2) +
    geom_line()
#+end_src

#+RESULTS:

#+begin_src R :tangle /tmp/reprex.R
  windows <- windows |>
    mutate(win = map(roll,
                     \(x) {
                       simple[, c("age_floating", "value")] |>
                         astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                         astrochron::taner(flow = ll,
                                           fhigh = hl,
                                           roll = x,
                                           genplot = FALSE, verbose = FALSE,
                                           output = 2) |>
                         rename(frequency = V1, amplitude = filter_pos)
                     })) |>
    mutate(target = "405 kyr")

  ls <- 1 / ps - fac * (1 / ps)
  hs <- 1 / ps + fac * (1 / ps)
  windows <- bind_rows(windows,
                       windows |>
    mutate(win = map(roll,
                     \(x) {
                     simple[, c("age_floating", "value")] |>
                     astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                       astrochron::taner(flow = ls,
                                         fhigh = hs,
                                       roll = x,
                                       genplot = FALSE, verbose = FALSE,
                                       output = 2) |>
                       rename(frequency = V1, amplitude = filter_pos)
                     })) |>
    mutate(target = "100 kyr")
    )
#+end_src

#+RESULTS:

meh
#+begin_src R :eval never
  # maybe precession will be higher res?
    pp <- 23
  lp <- 1 / pp - fac * (1 / pp)
  hp <- 1 / pp + fac * (1 / pp)
  precession_windows <- windows |>
    mutate(win = map(roll,
                     \(x) {
                     simple[, c("age_floating", "value")] |>
                     astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                       astrochron::taner(flow = lp,
                                         fhigh = hp,
                                       roll = x,
                                       genplot = FALSE, verbose = FALSE,
                                       output = 2) |>
                       rename(frequency = V1, amplitude = filter_pos)
                     })) |>
    mutate(target = "23 kyr")
    )

#+end_src

#+begin_src R :tangle /tmp/reprex.R
  # generate standard gaussian filter
  gfac <- 1
  orig_gauss <-
    bind_rows(
      simple[, c("age_floating", "value")] |>
      astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
      astrochron::bandpass(flow = 1/pl - fac * gfac *(1/pl),
                           fhigh = 1/pl + fac * gfac *(1/pl),
                           genplot = FALSE, verbose = FALSE,
                           alpha = 5,
                           win = 1, output = 2) |>
      mutate(window = "gaussian", target = "405 kyr") |>
      rename(frequency = bpfreq, amplitude = taper),
      simple[, c("age_floating", "value")] |>
      astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
      astrochron::bandpass(flow = 1/ps - fac * gfac * (1/ps),
                           fhigh = 1/ps + fac * gfac * (1 / ps),
                           ## alpha = 3, # default
                           ## alpha = 1, # ±1σ
                           alpha = 5, # ±1σ
                           genplot = FALSE, verbose = FALSE,
                           win = 1, output = 2) |>
      mutate(window = "gaussian", target = "100 kyr") |>
      rename(frequency = bpfreq, amplitude = taper))

  # investigate how the width of the gaussian is determined
  ## gfac <- 3 # what I started out with, this almost scales it up so that the boundaries are ±1σ
  ## gfac <- qnorm(1 - (1 - 0.95) / 2) / 2 # this is approximately 1.96
  ## gfac <- 1.5 # to get it to ±2σ
  gfac <- 2.1227 # to get it to intersect with taner and rect boundaries
  ## gfac <- 2 * sqrt(2 * log(2)) # this should be the half-width in terms of 1 σ
  gfac <- gfac / 3 * 5
  gauss <-
    bind_rows(
      simple[, c("age_floating", "value")] |>
      astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
      astrochron::bandpass(flow = 1/pl - fac * gfac *(1/pl),
                           fhigh = 1/pl + fac * gfac *(1/pl),
                           genplot = FALSE, verbose = FALSE,
                           ## alpha = 3, # default
                           alpha = 5,
                           win = 1, output = 2) |>
      mutate(window = "gaussian", target = "405 kyr") |>
      rename(frequency = bpfreq, amplitude = taper),
      simple[, c("age_floating", "value")] |>
      astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
      astrochron::bandpass(flow = 1/ps - fac * gfac * (1/ps),
                           fhigh = 1/ps + fac * gfac * (1 / ps),
                           genplot = FALSE, verbose = FALSE,
                           alpha = 5,
                           win = 1, output = 2) |>
      mutate(window = "gaussian", target = "100 kyr") |>
      rename(frequency = bpfreq, amplitude = taper))

  ## mfa <- my_filt_age[1:2, ] |>
  ##   mutate(range = 0.25 * f, flow = f - range, fhigh = f + range) |>
  ##   mutate(window = "rectangular") |>
  ##   pivot_longer(flow:fhigh)
  ## mfa <- bind_rows(mfa, mfa) |>
  ##   arrange(f) |>
  ##   mutate(y = rep(c(0, 1, 1, 0), 2))
#+end_src

#+RESULTS:

ok that's super weird, papa gauss still jumps all over the place.
maybe due to numerical issues where it approximates the shape?

let's look at the true normal distribution

we want the -2 \sigma and +2\sigma to be at the edges of the rectangular filter
#+begin_src R
  # show true normal distribution with flow and fhigh at ±2σ
  true_normal_l <- distributional::dist_normal(mean = 1/pl,
                                               sd = fac/qnorm(1 - (1 - 0.95) / 2) * 1/pl)
  true_normal_s <- distributional::dist_normal(mean = 1/ps,
                                               sd = fac/qnorm(1 - (1 - 0.95) / 2) * 1/ps)
#+end_src

#+RESULTS:

#+begin_src R :tangle /tmp/reprex.R
  ## mfa <- my_filt_age[1:2, ] |>
  ##   mutate(range = 0.25 * f, flow = f - range, fhigh = f + range) |>
  ##   mutate(window = "rectangular") |>
  ##   pivot_longer(flow:fhigh)
  ## mfa <- bind_rows(mfa, mfa) |>
  ##   arrange(f) |>
  ##   mutate(y = rep(c(0, 1, 1, 0), 2))

  pl_windows <- windows |>
    unnest(win) |>
    ggplot(aes(x = frequency, y = amplitude,
               colour = window, shape = window,
               ## fill = window
               )) +
    coord_cartesian(
      xlim = c(0, 0.015), # full window, both short and long ecc
      ylim = c(0, 1.2)
      ## xlim = c(0.0068, 0.007), # zoom in on crossing to check if I did the gaussian parametrization "correctly"
      ## ylim = c(0.36, 0.45)
    ) +
    scale_y_continuous(breaks = c(0, 1)) +
    labs(x = "Frequency (cycles/kyr)",
         y = "") +
    annotate("text", x = 1 / c(405, 110), y = 1,
             label = c("405", "110"), vjust = -0.5) +

    # rectangles
    ## geom_step(aes(x = value, y = y), data = mfa) +
    annotate("rect", fill = NA, colour = "black", xmin = ll, xmax = hl, ymin = 0, ymax = 1) +
    annotate("rect", fill = NA, colour = "black", xmin = ls, xmax = hs, ymin = 0, ymax = 1) +

  ## scale_fill_manual(values = c("rectangular" = "gray", "gaussian" = "pink", "taner" = "blue")) +
    ## # reall gaussian, not limited by weird parametrization
    ## ggdist::stat_slab(aes(xdist = true_normal),
    ##                   inherit.aes = FALSE,
    ##                   fill = "pink", colour = "darkred") +
    scale_shape_manual("Window",
                       values = c(
                         "rectangular" = "square",
                          "gaussian" = "triangle",
                          "gaussian rescaled" = "triangle"
                       )) +
    scale_colour_manual("Window",
                        values = c(
                          "rectangular" = "gray",
                          "gaussian" = "red",
                          "gaussian rescaled" = "darkred"## ,
                          ## "taner" = "green"
                        )) +

    # gauss
    ## ggdist::stat_halfeye(aes(xdist = true_normal_s,
    ##                          alpha = after_stat(ggdist::cut_cdf_qi(cdf, .width = c(.68, .95, 1)))),
    ##                      scale = 1,
    ##                      .width = c(.68, .95),
    ##                      fill = "blue", colour = "darkblue") +
    ## # figure out how gaussian is parameterized
    ## geom_vline(xintercept = c(1 / ps - 0.5 * fac * 1 / ps,
    ##                           1 / ps + 0.5 * fac * 1 / ps,
    ##                           1 / pl - 0.5 * fac * 1 / pl,
    ##                           1 / pl + 0.5 * fac * 1 / pl))
    ## geom_point(aes(group = paste(window, target), colour = window),
    ##            data = gauss |> mutate(window = "gaussian rescaled")) +
    geom_line(aes(group = paste(window, target), colour = window),
              data = gauss |> mutate(window = "gaussian rescaled")) +
    geom_line(aes(group = paste(window, target), colour = window),
              data = orig_gauss |> mutate(window = "gaussian")) +

    # taners
    ggnewscale::new_scale_colour() +
    scale_colour_viridis_d("Taner roll") +
    geom_line(aes(colour = factor(format(roll, scientific = TRUE)),
                  group = paste(roll, window, target), shape = NULL),
              position = "identity") +

        # annotate astronomical solutions spectra
    geom_area(aes(x = frequency, y = power / max(power)),
              inherit.aes = FALSE,
              fill = "black",
              colour = NA,
              position = "identity",
              data = slns_specs |> filter(frequency < 0.02))
#+end_src

#+RESULTS:

#+begin_src R :tangle /tmp/reprex.R
  pl_windows

  # zoom waay in on the intersection for the 1e5 version
  pl_windows +
    ## coord_cartesian(xlim = c(0.0068181, 0.00681825), ylim = c(0.3678, 0.368)) # a little far?
    coord_cartesian(xlim = c(0.0068, 0.00684), ylim = c(0.35, 0.38)) # zoomed out a bit

  # zoom in on the peak
  pl_windows +
    ## coord_cartesian(xlim = c(0.0068181, 0.00681825), ylim = c(0.3678, 0.368)) # a little far?
    coord_cartesian(xlim = c(0.008, 0.010), ylim = c(.99, 1))
#+end_src

#+RESULTS:
: Error in ggnewscale::new_scale_colour() + scale_colour_viridis_d() + labs(colour = "Taner roll") :
:   non-numeric argument to binary operator
: Coordinate system already present. Adding new coordinate system, which will replace the existing one.
: Coordinate system already present. Adding new coordinate system, which will replace the existing one.

contrast the filter to a real gaussian to see where the \minus\sigma and \plus\sigma are.

#+begin_src R :tangle /tmp/reprex.R
  ## x11()
  to <- simple |>
    select(age_floating, res) |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::taner(flow = ls,
                      fhigh = hs,
                      roll = 1e4,
                      xmin = ls - 0.003,
                      xmax = hs + 0.003,
                      genplot = TRUE, verbose = FALSE,
                      output = 1)

  # this is what happens when you just change alpha
  go0 <- simple |>
    select(age_floating, res) |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::bandpass(flow = ls,
                         fhigh = hs,
                         alpha = 3 / 2.1227,
                         win = 1,
                         xmin = ls - 0.003,
                         xmax = hs + 0.003,
                         genplot = TRUE, verbose = FALSE,
                         output = 1)


  ## x11() # open up a new window so we can compare the two native plots
  go <- simple |>
    select(age_floating, res) |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::bandpass(flow = 1/ps - fac * gfac *(1/ps), # ls,
                         fhigh = 1/ps + fac * gfac *(1/ps), # hs,
                         ## alpha = 1,
                         # full width at half maximum (FWHM) = 2 * sqrt(2 * log(2)) * \sigma,
                         # but I see that this only works if I halve it first.
                         ## alpha = 0.5 * 2 * sqrt(2 * log(2)), # but this is not how taner is defined
                         alpha = 5,
                         win = 1,
                         xmin = ls - 0.003,
                         xmax = hs + 0.003,
                         genplot = TRUE, verbose = FALSE,
                         output = 1)

  # plot diffs
  bind_cols(to |> rename(to = res),
            go0 |> select(go0 = res),
            go |> select(go = res)) |>
    as_tibble() |>
    mutate(togo = to - go) |>
    mutate(togo0 = to - go0) |>
    mutate(gogo0 = go - go0) |>
    ggplot(aes(x = age_floating)) +
    geom_line(aes(y = to, colour = "to")) +
    geom_line(aes(y = go0, colour = "go0"), linetype = "dotted") +
    geom_line(aes(y = go, colour = "go"), linetype = "dashed") +
    geom_line(aes(y = togo0, colour = "togo0")) +
    geom_line(aes(y = gogo0, colour = "gogo0")) +
    geom_line(aes(y = togo, colour = "togo"))
#+end_src


#+begin_src R :results output graphics file :file imgs/gaussian_window.png :width 2200 :height 1000 :res 300
  ggplot() +
    # gaussians from the filter
    geom_area(aes(x = frequency, y = amplitude,
                  group = paste(window, target)),
              fill = "pink",
              position = "identity",
              colour = "darkred",
              data = gauss) +
    ## ggdist::stat_halfeye(aes(xdist = true_normal_l,
    ##                          alpha = after_stat(ggdist::cut_cdf_qi(cdf, .width = c(.68, .95, 1)))),
    ##                      scale = 1,
    ##                      .width = c(.68, .95),
    ##                      fill = "blue", colour = "darkblue") +
    ## ggdist::stat_halfeye(aes(xdist = true_normal_s,
    ##                          alpha = after_stat(ggdist::cut_cdf_qi(cdf, .width = c(.68, .95, 1)))),
    ##                      scale = 1,
    ##                      .width = c(.68, .95),
    ##                      fill = "blue", colour = "darkblue") +

    geom_area(aes(x = frequency, y = amplitude,
                  group = paste(window, target)),
              fill = "pink", alpha = .2,
              position = "identity",
              colour = "darkred",
              data = orig_gauss) +

    # taner
    geom_line(aes(x = frequency, y = amplitude,
                  colour = factor(format(roll, scientific = TRUE)),
                  group = paste(roll, window, target)),
              position = "identity", data = windows |> unnest(win)) +
    scale_colour_viridis_d() +


    scale_alpha_manual(values = c("1" = 0.3, "0.95" = 0.6, "0.66" = 1), guide = "none") +
    ## scale_colour_viridis_d() +
    ## geom_area(aes(x = frequency, y = amplitude,
    ##               colour = factor(format(roll, scientific = TRUE)),
    ##               group = paste(roll, window, target)),
    ##           position = "identity",
    ##           alpha = .05, data = windows |> unnest(win)) +
    coord_cartesian(xlim = c(0, 0.0155)) +
    ## coord_cartesian(xlim = c(0.0065, 0.007)) +

  geom_vline(xintercept = c(1 / ps - fac / ps,
                            1 / ps + fac / ps,
                            1 / pl - fac / pl,
                            1 / pl + fac / pl)) +
  geom_vline(xintercept = c(1 / ps - (gfac * fac) / ps,
                            1 / ps + (gfac * fac) / ps,
                            1 / pl - (gfac * fac) / pl,
                            1 / pl + (gfac * fac) / pl), colour = "gray")
#+end_src

#+RESULTS:
[[file:imgs/gaussian_window.png]]
**** [#B] plot filter windows
:PROPERTIES:
:CREATED:  [2024-03-27 Wed 11:04]
:END:
run above reprex to create pl_windows
#+begin_src R :results output graphics file :file imgs/filter_windows.pdf :width 5 :height 3
  pl_windows
#+end_src

#+RESULTS:
[[file:imgs/filter_windows.pdf]]

**** combine taner filter and RMSD scores
:PROPERTIES:
:CREATED:  [2024-03-27 Wed 15:40]
:END:
#+begin_src R :results output graphics file :file imgs/filter_windows.pdf :width 5 :height 3
  (pl_windows /
   (pl_rmsd_taner + theme(legend.position = "none"))) *
    theme(legend.key.height = unit(.1, "mm")) + plot_layout(guides = "collect")
#+end_src

#+RESULTS:
[[file:imgs/filter_windows.pdf]]

**** COMMENT eha after applying age model
:PROPERTIES:
:CREATED:  [2023-12-11 Mon 14:01]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_MS_eha.png :width 400 :height 900
  mini <- rolling_age_optim |>
    ## slice(1) |>
    mutate(
      the_best = map(the_best,
                     \(b) b |>
                          mutate(depth = strat_bot + tie_err))) |>
    ## select(-sol) |> unnest(the_best)
    mutate(
      data = map2(data, the_best,
                  \(d, b) d |>
                          mutate(age = Hmisc::approxExtrap(b$depth, b$age, xout = depth)$y))) |>
    mutate(RMSD = map_dbl(the_best, \(x) x |>
                                         filter(n == max(n), .by = c(sol)) |>
                                         pull(RMSD_cum))) |>
    unnest(data) |>
    tidylog::filter(RMSD == min(RMSD), .by = c(proxy, site, sol)) |>
    filter(proxy == "MS",
           site == "Zumaia",
           ## sol == "ZB20a",
           sol == "La10b",
           ## detrend_type == "lin_gam_det",
           ## comb == "1:1"
           ) |>
    tidylog::left_join(smooth_all)

  (mini |>
   ggplot(aes(x = value, y = age / 1e3)) +
   geom_line(orientation = "y") +
   geom_line() +
   ## coord_cartesian(ylim = c(65.8, 69.7), expand = FALSE) +
   labs(x = "Normalized, filtered MS", y = "Age (Ma)", title = round(mini$RMSD[[1]], 3))) +
  (mini |>
    select(age, ecc) |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::eha(#sigID = TRUE,
                  win = 500, step = 10,
                  ## fmax = 1,
                  ## ydir = -1,
                  genplot = FALSE, verbose = FALSE,
                  output = 3) |> # harmonic CL
    pivot_longer(-freq) |>
    mutate(name = str_sub(name, 2, -1) |> parse_double()) |>
    rename(age = name) |>
    ggplot(aes(x = freq, y = age / 1e3, fill = value)) +
    geom_raster() +
    scale_fill_viridis_c() +
    scale_y_reverse() +
    coord_cartesian(xlim = c(0, 1 / 50), ylim = c(65.8, 69.7), expand = FALSE) +
    labs(x = "Frequency", y = "Age (Ma)"))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_MS_eha.png]]

**** COMMENT calculate bandpass filters in the time domain
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 15:16]
:END:
#+begin_src R :results none
  filts_age_optim <- smooth_optim_age_value |>
    nested_bandpass_filter(frequencies = my_filt_age, x = age, y = value,
                    nest = c("proxy", "site", "detrend_type", "sol"))
#+end_src

**** COMMENT plot the filtered records with the data
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 15:18]
:END:
#+begin_src R :results graphics file output :file imgs/Zumaia_Sopelana_filters_after_optim.png :width 2400 :height 2600 :res 300
  filts_age_optim |>
    filter(target != "prec") |>
    filter(proxy == "MS", site == "Zumaia", detrend_type == "lin_gam_det") |>
    ggplot(aes(x = age / 1e3, y = filt, group = paste(target, proxy, sol, site, detrend_type))) +
    facet_grid(
      rows = vars(proxy, sol),
    ) +
    scale_x_reverse() +
    geom_line(aes(colour = "optim filter")) +
    # contrast new filter to various previous steps:
    ## previous raw filters in age domain prior to shifting the records
    geom_line(aes(color = "field age filter"),
              data = filts_age |>
                filter(target != "prec") |>
                filter(proxy == "MS", site == "Zumaia", detrend_type == "lin_gam_det"))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_Sopelana_filters_after_optim.png]]

#+begin_src R :results graphics file output :file imgs/Zumaia_Sopelana_ecc_after_optim.png :width 2400 :height 2600 :res 300
  filts_age_optim |>
    filter(target != "prec") |>
    filter(proxy == "MS", site == "Zumaia", detrend_type == "lin_gam_det") |>
    summarize(ecc = sum(filt), .by = c(proxy, site, detrend_type, sol, age)) |>
    ggplot(aes(x = age / 1e3, y = ecc, group = paste(proxy, sol, site, detrend_type))) +
    facet_grid(
      rows = vars(proxy, sol),
    ) +
    scale_x_reverse() +
    geom_line(aes(colour = "apply optim agem, filter, combine")) +
    # unfortunately I only exported the combined record
    geom_line(aes(x = age / 1e3, y = ecc / 2, group = paste(proxy, sol, site, detrend_type, comb),
                  colour = "squished ecc from optim"),
              data = smooth_optim_age_value |>
                filter(proxy == "MS", site == "Zumaia", detrend_type == "lin_gam_det", comb == "1:1"))

#+end_src

#+RESULTS:
[[file:imgs/Zumaia_Sopelana_ecc_after_optim.png]]

**** COMMENT plot of matched records and solutions for Zumaia Lstar 1:1
:PROPERTIES:
:CREATED:  [2024-01-12 Fri 15:22]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_Lstar_1-1_solutions.png :width 2400 :height 2000 :res 300
  best_age_optim |>
    filter(site == "Zumaia", proxy == "Lstar", comb == "1:1") |>
    ## filter(detrend_type == "lin_scl_fine") |>
    mutate(m = map(the_best, "matched")) |>
    unnest(m) |>
    ggplot(aes(x = age * 1e-3, y = sign_405 * ecc, colour = detrend_type)) +
    labs(x = "Age (Ma)", y = "Norm. Filter & Solution") +
    scale_x_reverse(breaks = seq(80, 50, -1),
                    minor_breaks = seq(80, 50, -0.1)) +
    scale_y_continuous(breaks = c(-4, -2, 0, 2, 4)) +
    facet_grid(rows = vars(sol)) +
    geom_line(aes(y = ecc_sln), colour = "gold4", linewidth = 1) +
    geom_line(aes(group = paste(site, proxy, comb, detrend_type, as.character(date)))) +
    ## annotate("text", x = 66.3, y = 5, label = "RMSD", size = 3) +
    geom_text(aes(x = 66.3, y = 4, label = round(RMSD, 3)),
              size = 2,
              position = position_dodge(width = .7),
              data = \(x) distinct(x, RMSD, sol, detrend_type))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_Lstar_1-1_solutions.png]]

**** COMMENT plot of matched records and solutions for Zumaia MS 1:1
:PROPERTIES:
:CREATED:  [2024-01-12 Fri 15:22]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_MS_1-1_solutions.png :width 2400 :height 2000 :res 300
  best_age_optim |>
    filter(site == "Zumaia", proxy == "MS", comb == "1:1") |>
    ## filter(detrend_type == "lin_scl_fine") |>
    mutate(m = map(the_best, "matched")) |>
    unnest(m) |>
    ggplot(aes(x = age * 1e-3, y = sign_405 * ecc, colour = detrend_type)) +
    labs(x = "Age (Ma)", y = "Norm. Filter & Solution") +
    scale_x_reverse(breaks = seq(80, 50, -1),
                    minor_breaks = seq(80, 50, -0.1)) +
    scale_y_continuous(breaks = c(-4, -2, 0, 2, 4)) +
    facet_grid(rows = vars(sol)) +
    geom_line(aes(y = ecc_sln), colour = "gold4", linewidth = 1) +
    geom_line() +
    ## annotate("text", x = 66.3, y = 5, label = "RMSD", size = 3) +
    geom_text(aes(x = 66.3, y = 4, label = round(RMSD, 3)),
              size = 2,
              position = position_dodge(width = .7),
              data = \(x) distinct(x, RMSD, sol, detrend_type))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_MS_1-1_solutions.png]]

**** COMMENT plot of matched records and solutions for Zumaia d13C 1:1
:PROPERTIES:
:CREATED:  [2024-01-16 Tue 16:43]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_d13C_1-1_solutions.png :width 2400 :height 2000 :res 300
  best_age_optim |>
    filter(site == "Zumaia", proxy == "d13C", comb == "1:1") |>
    ## filter(detrend_type == "lin_scl_fine") |>
    mutate(m = map(the_best, "matched")) |>
    unnest(m) |>
    ggplot(aes(x = age * 1e-3, y = -ecc, colour = detrend_type)) +
    labs(x = "Age (Ma)", y = "Norm. Filter & Solution") +
    scale_x_reverse(breaks = seq(80, 50, -1),
                    minor_breaks = seq(80, 50, -0.1)) +
    scale_y_continuous(breaks = c(-4, -2, 0, 2, 4)) +
    facet_grid(rows = vars(sol)) +
    geom_line(aes(y = ecc_sln), colour = "gold4", linewidth = 1) +
    geom_line() +
    ## annotate("text", x = 66.3, y = 5, label = "RMSD", size = 3) +
    geom_text(aes(x = 66.3, y = 4, label = round(RMSD, 3)),
              size = 2,
              position = position_dodge(width = .7),
              data = \(x) distinct(x, RMSD, sol, detrend_type))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_d13C_1-1_solutions.png]]

**** COMMENT simplified plot of filters
:PROPERTIES:
:CREATED:  [2024-02-26 Mon 13:07]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_Lstar_1-1_solutions_depth_ecc.pdf :width 9.6 :height 2
  best_age_optim |>
    filter(comb == "1:1") |>
    filter(proxy == "Lstar") |>
    filter(sol == "ZB20b") |>
    mutate(m = map(the_best, "matched")) |>
    unnest(m) |>
    ggplot(aes(x = age * 1e-3,
               y = ecc,
               colour = site,
               group = paste(site, sol, proxy,
                             detrend_type, depth_chunk))) +
    facet_grid(rows = vars(sol)) +
    labs(x = "Age (Ma)", y = "Norm. Filtered proxy",
         colour = "") +
    ## theme(legend.pos = c(.64, .864),
    ##       legend.direction = "horizontal") +
    scale_colour_manual(values = detrend_colours) +
    scale_x_reverse(breaks = seq(80, 50, -1),
                    minor_breaks = seq(80, 50, -0.1)) +
    ## scale_y_continuous(breaks = c(-4, 0, 4)) +
    ## scale_linewidth_continuous(range = c(1.2, 0.3)) +
    ## scale_alpha_continuous(range = c(1, 0.2)) +
    ## scale_colour_manual(values = c("Astronomical Solution" = "black",
    ##                                "Zumaia" = "purple",
    ##                                "Sopelana" = "skyblue"
    ##                                ## "Lstar" = "purple",
    ##                                ## "MS" = "skyblue",
    ##                                ## "d13C" = "darkgreen"
    ##                                )) +
    ## geom_vline(xintercept = 0) +
    # annotate field-based long ecc minima
    # uncertainty
    ## geom_segment(aes(x = strat_bot - 1.6, xend = strat_bot + 1.6,
    ##                  y = -4, yend = -4),
    ##              inherit.aes = FALSE,
    ##              data = agem_simple) +
    ## # points themselves
    ## geom_point(aes(x = strat_bot, y = -4),
    ##            inherit.aes = FALSE,
    ##            data = agem_simple) +
    ## geom_line(aes(y = ) +
    geom_line(aes(colour = detrend_type,
                  group = paste(sol, proxy, site, depth_chunk, detrend_type, site, window)))
    ## geom_line(aes(y = value), colour = "gray")
    ## geom_line(aes(y = value, colour = "Astronomical Solution")) +
    ## geom_line(aes(y = SD, linewidth = RMSD, alpha = RMSD)) +
    ## annotate("text", x = 66.3, y = 5, label = "RMSD", size = 3) +
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_Lstar_1-1_solutions_depth_ecc.pdf]]

**** [#B] simplified plot of detrended data vs depth
:PROPERTIES:
:CREATED:  [2024-01-15 Mon 15:22]
:END:
I should:
- [X] make a plot of scl in depth domain
- [X] with another row with preferred way of detrending in depth domain
# #+begin_src R :results output graphics file :file imgs/Zumaia_Lstar_1-1_solutions_simple.png :width 2400 :height 2000 :res 300
# #+begin_src R :results output graphics file :file imgs/Zumaia_d13C_1-1_solutions_depth.pdf :width 9.6 :height 2
# #+begin_src R :results output graphics file :file imgs/Zumaia_MS_1-1_solutions_depth.pdf :width 9.6 :height 2

#+begin_src R
  simp <- best_age_optim |>
    filter(comb == "1:1") |>
    filter(sol == "ZB20a") |>
    filter(depth_chunk == "full record") |>
    mutate(m = map(the_best, "matched")) |>
    unnest(m)

  simp_crit <- simp |>
    filter(site == "Sopelana") |>
    summarize(min_depth = min(depth),
              .by = c(proxy, sol))

  simp <- simp |>
    tidylog::left_join(simp_crit) |>
    tidylog::filter(proxy == "d13C" | site == "Sopelana" | (site == "Zumaia" & depth < min_depth))
#+end_src

#+RESULTS:
: Joining with `by = join_by(proxy, sol)`
: left_join: added one column (min_depth)
: rows only in x     341
: rows only in y  (    0)
: matched rows     3,320
:                 =======
: rows total       3,661
: filter: removed 424 rows (12%), 3,237 rows remaining

#+begin_src R :results output graphics file :file imgs/Zumaia_Lstar_1-1_solutions_depth.pdf :width 9.6 :height 2
  pl_detrended_depth <- simp |>
    filter(proxy == "Lstar") |>
    ggplot(aes(x = depth,
               ## y = sign_405 * ecc,
               y = value,
               colour = site,
               group = paste(site, sol, proxy,
                             detrend_type, depth_chunk))) +
    ## facet_grid(rows = vars(sol)) +
    theme(legend.position = c(.7, .9), legend.location = "inside") +
    labs(x = "Depth (m)", y = "Detrended proxy",
         colour = "") +
    coord_cartesian(xlim = c(183, 0)) +
    ## scale_colour_manual(values = detrend_colours) +
    scale_colour_manual(name = "",
                        values = c("Zumaia" = "purple",
                                   "Sopelana" = "orange",
                                   "Solution" = "black")) +
    ## theme(legend.pos = c(.64, .864),
    ##       legend.direction = "horizontal") +
    scale_x_reverse(breaks = seq(200, -50, -20),
                    ## minor_breaks = seq(200, -50, -5)
                    ) +
    ## scale_y_continuous(breaks = c(-4, 0, 4)) +
    ## scale_linewidth_continuous(range = c(1.2, 0.3)) +
    ## scale_alpha_continuous(range = c(1, 0.2)) +
    ## scale_colour_manual(values = c("Astronomical Solution" = "black",
    ##                                "Zumaia" = "purple",
    ##                                "Sopelana" = "skyblue"
    ##                                ## "Lstar" = "purple",
    ##                                ## "MS" = "skyblue",
    ##                                ## "d13C" = "darkgreen"
    ##                                )) +
    ## geom_vline(xintercept = 0, alpha = .2) +
      # annotate field-based long ecc minima
    # uncertainty
    geom_segment(aes(x = strat_bot - 1.6, xend = strat_bot + 1.6,
                     y = -4, yend = -4, colour = site),
                 inherit.aes = FALSE,
                 data = agem_simple) +
    geom_vline(aes(xintercept = strat_bot, colour = site),
             alpha = .2,
             data = agem_simple) +
    ## # points themselves
    ## geom_point(aes(x = strat_bot, y = -4,colour = site),
    ##            inherit.aes = FALSE,
    ##            data = agem_simple) +
    geom_line(alpha = .3)
    ## geom_line(aes(y = value, colour = "Astronomical Solution")) +
    ## geom_line(aes(y = SD, linewidth = RMSD, alpha = RMSD)) +
    ## annotate("text", x = 66.3, y = 5, label = "RMSD", size = 3) +
  pl_detrended_depth
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_Lstar_1-1_solutions_depth.pdf]]

same for d13C
#+begin_src R :results output graphics file :file imgs/Zumaia_d13C_1-1_solutions_depth.pdf :width 9.6 :height 2
  pl_detrended_depth_d13C <- simp |>
    filter(proxy == "d13C") |>
    ggplot(aes(x = depth,
               ## y = sign_405 * ecc,
               y = value,
               colour = site,
               group = paste(site, sol, proxy,
                             detrend_type, depth_chunk))) +
    ## facet_grid(rows = vars(sol)) +
    theme(legend.position = c(.7, .9), legend.location = "inside") +
    labs(x = "Depth (m)", y = "Detrended proxy",
         colour = "") +
    coord_cartesian(xlim = c(183, 0)) +
    ## scale_colour_manual(values = detrend_colours) +
    scale_colour_manual(name = "",
                        values = c("Zumaia" = "purple",
                                   "Sopelana" = "orange",
                                   "Solution" = "black")) +
    ## theme(legend.pos = c(.64, .864),
    ##       legend.direction = "horizontal") +
    scale_x_reverse(breaks = seq(200, -50, -20),
                    ## minor_breaks = seq(200, -50, -5)
                    ) +
    ## scale_y_continuous(breaks = c(-4, 0, 4)) +
    ## scale_linewidth_continuous(range = c(1.2, 0.3)) +
    ## scale_alpha_continuous(range = c(1, 0.2)) +
    ## scale_colour_manual(values = c("Astronomical Solution" = "black",
    ##                                "Zumaia" = "purple",
    ##                                "Sopelana" = "skyblue"
    ##                                ## "Lstar" = "purple",
    ##                                ## "MS" = "skyblue",
    ##                                ## "d13C" = "darkgreen"
    ##                                )) +
    ## geom_vline(xintercept = 0, alpha = .2) +
      # annotate field-based long ecc minima
    # uncertainty
    geom_segment(aes(x = strat_bot - 1.6, xend = strat_bot + 1.6,
                     y = -4, yend = -4, colour = site),
                 inherit.aes = FALSE,
                 data = agem_simple) +
    geom_vline(aes(xintercept = strat_bot, colour = site),
             alpha = .2,
             data = agem_simple) +
    ## # points themselves
    ## geom_point(aes(x = strat_bot, y = -4,colour = site),
    ##            inherit.aes = FALSE,
    ##            data = agem_simple) +
    geom_line(alpha = .3)
    ## geom_line(aes(y = value, colour = "Astronomical Solution")) +
    ## geom_line(aes(y = SD, linewidth = RMSD, alpha = RMSD)) +
    ## annotate("text", x = 66.3, y = 5, label = "RMSD", size = 3) +
  pl_detrended_depth_d13C
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_d13C_1-1_solutions_depth.pdf]]

same for MS
#+begin_src R :results output graphics file :file imgs/Zumaia_MS_1-1_solutions_depth.pdf :width 9.6 :height 2
  pl_detrended_depth_MS <- simp |>
    filter(proxy == "MS") |>
    ggplot(aes(x = depth,
               ## y = sign_405 * ecc,
               y = value,
               colour = site,
               group = paste(site, sol, proxy,
                             detrend_type, depth_chunk))) +
    ## facet_grid(rows = vars(sol)) +
    theme(legend.position = c(.7, .9), legend.location = "inside") +
    labs(x = "Depth (m)", y = "Detrended proxy",
         colour = "") +
    coord_cartesian(xlim = c(183, 0)) +
    ## scale_colour_manual(values = detrend_colours) +
    scale_colour_manual(name = "",
                        values = c("Zumaia" = "purple",
                                   "Sopelana" = "orange",
                                   "Solution" = "black")) +
    ## theme(legend.pos = c(.64, .864),
    ##       legend.direction = "horizontal") +
    scale_x_reverse(breaks = seq(200, -50, -20),
                    ## minor_breaks = seq(200, -50, -5)
                    ) +
    ## scale_y_continuous(breaks = c(-4, 0, 4)) +
    ## scale_linewidth_continuous(range = c(1.2, 0.3)) +
    ## scale_alpha_continuous(range = c(1, 0.2)) +
    ## scale_colour_manual(values = c("Astronomical Solution" = "black",
    ##                                "Zumaia" = "purple",
    ##                                "Sopelana" = "skyblue"
    ##                                ## "Lstar" = "purple",
    ##                                ## "MS" = "skyblue",
    ##                                ## "d13C" = "darkgreen"
    ##                                )) +
    ## geom_vline(xintercept = 0, alpha = .2) +
      # annotate field-based long ecc minima
    # uncertainty
    geom_segment(aes(x = strat_bot - 1.6, xend = strat_bot + 1.6,
                     y = -4, yend = -4, colour = site),
                 inherit.aes = FALSE,
                 data = agem_simple) +
    geom_vline(aes(xintercept = strat_bot, colour = site),
             alpha = .2,
             data = agem_simple) +
    ## # points themselves
    ## geom_point(aes(x = strat_bot, y = -4,colour = site),
    ##            inherit.aes = FALSE,
    ##            data = agem_simple) +
    geom_line(alpha = .3)
    ## geom_line(aes(y = value, colour = "Astronomical Solution")) +
    ## geom_line(aes(y = SD, linewidth = RMSD, alpha = RMSD)) +
    ## annotate("text", x = 66.3, y = 5, label = "RMSD", size = 3) +
  pl_detrended_depth_MS
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_MS_1-1_solutions_depth.pdf]]

**** [#B] superduper combination for in main paper
:PROPERTIES:
:CREATED:  [2024-03-22 Fri 09:36]
:END:
where I make the plot components:
[[file:~/SurfDrive/Postdoc1/prj/2023-05-19_cretaceous_constraints/cretaceous_constraints.org::*create a quick plot of all the detrend types][create a quick plot of all the detrend types]]
[[file:~/SurfDrive/Postdoc1/prj/2023-05-19_cretaceous_constraints/cretaceous_constraints.org::*simplified plot of detrended data vs depth][simplified plot of detrended data vs depth]]
[[file:~/SurfDrive/Postdoc1/prj/2023-05-19_cretaceous_constraints/cretaceous_constraints.org::*simple plot of records vs. solutions][simple plot of records vs. solutions]]

Lstar main one
#+begin_src R :results output graphics file :file imgs/matched_solutions.pdf :width 8 :height 7
  (pl_age_matches /
   (pl_detrended_depth +
    theme(axis.text.x = element_blank(),
          axis.line.x = element_blank(),
          axis.ticks.x = element_blank())
   ) /
   pl_detrend) +
  plot_layout(heights = c(7, 1, 1), axes = "collect_x", guides = "collect")
#+end_src

#+RESULTS:
[[file:imgs/matched_solutions.pdf]]

d13C for supplement
#+begin_src R :results output graphics file :file imgs/matched_solutions_d13C.pdf :width 8 :height 7
  (pl_age_matches_d13C /
   (pl_detrended_depth_d13C +
    theme(axis.text.x = element_blank(),
          axis.line.x = element_blank(),
          axis.ticks.x = element_blank())
   ) /
   pl_detrend_d13C) +
  plot_layout(heights = c(7, 1, 1), axes = "collect_x", guides = "collect")
#+end_src

#+RESULTS:
[[file:imgs/matched_solutions_d13C.pdf]]


MS for supplement
#+begin_src R :results output graphics file :file imgs/matched_solutions_MS.pdf :width 8 :height 7
  (pl_age_matches_MS /
   (pl_detrended_depth_MS +
    theme(axis.text.x = element_blank(),
          axis.line.x = element_blank(),
          axis.ticks.x = element_blank())
   ) /
   pl_detrend_MS) +
  plot_layout(heights = c(7, 1, 1), axes = "collect_x", guides = "collect")
#+end_src

#+RESULTS:
[[file:imgs/matched_solutions_MS.pdf]]


**** +simple+ plot of filtered data in time domain
:PROPERTIES:
:CREATED:  [2024-03-20 Wed 09:13]
:END:

#+begin_src R :results output graphics file :file imgs/Zumaia_Lstar_1-1_solutions_age.pdf :width 15 :height 10
  best_age_optim |>
    filter(comb == "1:1") |>
    ## filter(sol == "ZB20b") |>
    mutate(m = map(the_best, "matched")) |>
    unnest(m) |>
    ## filter(detrend_type == "lin_scl_med") |>
    ## filter(window == "rectangular") |>
    ggplot(aes(x = age * 1e-3,
               ## y = sign_405 * ecc,
               y = value,
               ## colour = paste(site, depth_chunk),
               colour = detrend_type,
               ## linetype = window,
               group = paste(site, sol, proxy,
                             detrend_type, depth_chunk))) +
    facet_grid(rows = vars(sol), cols = vars(proxy), scales = "free_x", space = "free_x") +
    labs(x = "Age (Ma)", y = "Detrended proxy",
         colour = "") +
    ## theme(legend.pos = c(.64, .864),
    ##       legend.direction = "horizontal") +
    scale_colour_manual(values = detrend_colours) +
    scale_x_reverse(breaks = seq(72, 65, -1),
                    minor_breaks = seq(72, 65, -.1)) +
    ## scale_y_continuous(breaks = c(-4, 0, 4)) +
    ## scale_linewidth_continuous(range = c(1.2, 0.3)) +
    ## scale_alpha_continuous(range = c(1, 0.2)) +
    ## scale_colour_manual(values = c("Astronomical Solution" = "black",
    ##                                "Zumaia" = "purple",
    ##                                "Sopelana" = "skyblue"
    ##                                ## "Lstar" = "purple",
    ##                                ## "MS" = "skyblue",
    ##                                ## "d13C" = "darkgreen"
    ##                                )) +
    ## geom_vline(xintercept = 0) +
    # annotate field-based long ecc minima
    # uncertainty
    ## geom_segment(aes(x = strat_bot - 1.6, xend = strat_bot + 1.6,
    ##                  y = -4, yend = -4),
    ##              inherit.aes = FALSE,
    ##              data = agem_simple) +
    ## # points themselves
    ## geom_point(aes(x = strat_bot, y = -4),
    ##            inherit.aes = FALSE,
    ##            data = agem_simple) +
    ## geom_line(aes(colour = detrend_type), alpha = .05) +
    ## geom_line(aes(y = `405 kyr` + 6,
    ##               alpha = .05,
    ##               group = paste(detrend_type, sol, proxy, site, comb, depth_chunk, window))) +
    ## geom_line(aes(y = `100 kyr` + 4,
    ##               alpha = .05,
    ##               group = paste(detrend_type, sol, proxy, site, comb, depth_chunk, window))) +
    ## geom_line(aes(y = scale(ecc)[, 1],
    ##               alpha = .05,
    ##               group = paste(detrend_type, sol, proxy, site, comb, depth_chunk, window))) +
    # only the best get a thicker line
    geom_line(aes(y = `405 kyr` + 6,
                  group = paste(detrend_type, sol, proxy, site, comb, depth_chunk, window)),
              data = best_age_optim_one |>
                filter(comb == "1:1") |>
                mutate(m = map(the_best, "matched")) |>
                unnest(m)) +
    geom_line(aes(y = `100 kyr` + 4,
                  group = paste(detrend_type, sol, proxy, site, comb, depth_chunk, window)),
              data = best_age_optim_one |>
                filter(comb == "1:1") |>
                mutate(m = map(the_best, "matched")) |>
                unnest(m)) +
    geom_line(aes(y = scale(ecc)[, 1],
                  group = paste(detrend_type, sol, proxy, site, comb, depth_chunk, window)),
              data = best_age_optim_one |>
                filter(comb == "1:1") |>
                mutate(m = map(the_best, "matched")) |>
                unnest(m)) +
    # now show single detrend type and window here in thick line
    geom_line(aes(y = `405 kyr` + 6,
                  group = paste(detrend_type, sol, proxy, site, comb, depth_chunk, window)),
              data = best_age_optim |>
                filter(comb == "1:1") |>
                filter(detrend_type == "lin_scl_med", window == "rectangular") |>
                mutate(m = map(the_best, "matched")) |>
                unnest(m)) +
    geom_line(aes(y = `100 kyr` + 4,
                  group = paste(detrend_type, sol, proxy, site, comb, depth_chunk, window)),
              data = best_age_optim |>
                filter(comb == "1:1") |>
                filter(detrend_type == "lin_scl_med", window == "rectangular") |>
                mutate(m = map(the_best, "matched")) |>
                unnest(m)) +
    geom_line(aes(y = scale(ecc)[, 1],
                  group = paste(detrend_type, sol, proxy, site, comb, depth_chunk, window)),
              data = best_age_optim |>
                filter(comb == "1:1") |>
                filter(detrend_type == "lin_scl_med", window == "rectangular") |>
                mutate(m = map(the_best, "matched")) |>
                unnest(m))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_Lstar_1-1_solutions_age.pdf]]

**** [10/11] tasks
:PROPERTIES:
:CREATED:  [2023-12-11 Mon 15:52]
:END:
***** DONE increase all figure resolutions
CLOSED: [2023-12-12 Tue 14:12]
:PROPERTIES:
:CREATED:  [2023-12-12 Tue 14:12]
:END:
Richard mentioned several times that he couldn't read the figure axes. Should be better now.
***** DONE comment out sections that are no longer relevant
CLOSED: [2023-12-12 Tue 14:33]
:PROPERTIES:
:CREATED:  [2023-12-12 Tue 14:33]
:END:
***** DONE look at full RMSD vs tie-error plots for each of the best-scoring solutions
CLOSED: [2023-12-14 Thu 10:50]
:PROPERTIES:
:CREATED:  [2023-12-11 Mon 15:14]
:END:
this will be slow but might help me decide if the tie-error range of \pm4 m is too large or not. Should result in 20 new figures!
***** DONE make sure the Zumaia d13C record doesn't just skip a 405 kyr cycle because I've made the tiepoint_uncertainty too large (in Ma405-8)
CLOSED: [2023-12-22 Fri 14:51]
:PROPERTIES:
:CREATED:  [2023-12-11 Mon 15:14]
:END:
I think my new method fixes this? Because I filter anew, it won't put things too close together.
***** CANC make Sopelana's top tiepoint rely on the best fit of the lowest Zumaia tiepoint uncertainty
CLOSED: [2023-12-20 Wed 15:51]
:PROPERTIES:
:CREATED:  [2023-12-11 Mon 15:15]
:END:
Currently the age models of Zumaia/Sopelana are independently tweaked. Not sure if this is needed/how reliable to link between the two records as identified in the field is.
hmm I think I like that they're independent?
***** DONE do eha/wavelet to double-check if I can lump the whole Zumaia/Sopelana record together or whether I should cut it into chunks of
CLOSED: [2023-12-22 Fri 14:51]
:PROPERTIES:
:CREATED:  [2023-12-11 Mon 15:15]
:END:
Seems like the sedrate might have changed around 100 m, cycle Ma_{405}7.
See cref:fig:Zumaia-eha.

***** DONE run spectral analysis on new optimized output
CLOSED: [2023-12-20 Wed 15:39]

***** DONE calculate RMSD against newly filtered record?
CLOSED: [2023-12-22 Fri 14:51]
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 15:53]
:END:
:LOGBOOK:
- State "DONE"       from "SOME"       [2023-12-22 Fri 14:51]
- State "SOME"       from              [2023-12-20 Wed 15:53]
:END:

***** DONE compare new filters to squished ecc record
CLOSED: [2023-12-20 Wed 15:51]
:PROPERTIES:
:CREATED:  [2023-12-20 Wed 15:40]
:END:
I've got it compared to the raw filter output, but I might have to construct a new record again..
Only did it for d13C single example now.

***** DONE make bandpass_filter also return depth/additional columns
CLOSED: [2024-01-15 Mon 15:16]
:PROPERTIES:
:CREATED:  [2023-12-22 Fri 14:52]
:END:
***** SOME now that I've finally figured out the analysis, apply it to other records as well
:PROPERTIES:
:CREATED:  [2023-12-12 Tue 14:41]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-12-12 Tue 14:41]
:END:
might need to have another look at other records once my ~wrap_age_model~ is fast/stable?
*** COMMENT attempt at exact copy of Richard's method
:PROPERTIES:
:CREATED:  [2024-01-30 Tue 12:19]
:END:

*** COMMENT save/load the workspace image (I didn't enjoy having to rerun everything everytime)
:PROPERTIES:
:CREATED:  [2023-11-22 Wed 13:42]
:END:
:LOGBOOK:
- Note taken on [2024-02-15 Thu 13:58] \\
  deleted, re-ran from scratch, saving only pre-massive run inputs
- Note taken on [2024-02-15 Thu 12:03] \\
  this has full version in memory again, not sure if I like that in terms of speed...
- Note taken on [2024-01-12 Fri 17:08] \\
  run the full variable tiepoints analysis with the new detrended record
- Note taken on [2024-01-11 Thu 17:35] \\
  new ways of linear detrending. Ran up to variable tie-points.
- Note taken on [2024-01-02 Tue 14:19] \\
  added ZB20b--d solutions
- Note taken on [2023-12-19 Tue 16:28] \\
  just added the MTLS and FFT spectral analyses for the simple age model
- Note taken on [2023-11-28 Tue 16:51] \\
  this is the image after running the standard depth analysis as well as the simple agemodel time analysis after adding La10b and La10c
:END:

remove the biggies
#+begin_src R
  rm(rolling_age_optim)
  rm(best_age_optim)
  rm(best_age_optim_one)
#+end_src

#+begin_src R :eval never
  save.image()
  ## save.image("best.RData") # this got wayy to big
  save.image("spectral_analysis.RData")
#+end_src

#+RESULTS:

#+begin_src R :eval never
  load(".RData")
  load("best.RData")
  load("spectral_analysis.RData")
#+end_src

** Gubbio
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 15:51]
:END:
via [cite:@Batenburg2018] fig 7

Umbria--March Basin, Italy

66 Ma to ~76 Ma

Ma_{405}1 to at least Ma_{405}12ish?

[cite:@Voigt2012]
https://doi.pangaea.de/10.1594/PANGAEA.778969

Also MS from [cite:@Husson2014] https://doi.pangaea.de/10.1594/PANGAEA.829778

#+begin_src R :results output graphics file :file imgs/Gubbio_MS_Husson2014.png :width 900 :height 500
  Gubbio <- pangaear::pg_data("10.1594/PANGAEA.829778")[[1]]

  dat <- Gubbio$data

  dat |>
    ggplot(aes(x = `Depth sed [m]`, y = `chi [10**-9 m**3/kg]`)) +
    geom_line() +
    labs(title = "Gubbio MS")
#+end_src

#+caption: Gubbio MS.
#+RESULTS:
[[file:imgs/Gubbio_MS_Husson2014.png]]


Also Ca isotopes by [cite:@Kitch2022]
malformed forams
OAE-2
https://doi.pangaea.de/10.1594/PANGAEA.954540

** ODP Leg 198 Site 1210B
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 15:52]
:END:
found via [cite:@Batenburg2018]

Shatsky Rise equatorial Pacific [cite:@Jung2012]

Ma_{405}2 to at least Ma_{405}12 ish?

66.25 Ma to ~71.5 Ma

Table in the supplement:
#+begin_src R :results output graphics file :file imgs/198-1210B_d13C_Jung2012.png :width 900 :height 500
  ODP198_1210B <- readxl::read_excel("dat/Jung2012/1-s2.0-S0195667112000547-mmc1.xls",
                                     range = "B2:E618",
                                     col_types = "numeric") |>
    rename(depth_mbsf = `Depth (mbsf)`,
           d13C_VPDB = `δ13C (‰ V-PDB)`,
           d18O_VPDB = `δ18O (‰ V-PDB)`,
           age = `Age (Ma)`)

  (ODP198_1210B |>
   ggplot(aes(x = depth_mbsf, y = d13C_VPDB)) +
   geom_line() +
   labs(title = "ODP 198 Site 1210B")) /
    (ODP198_1210B |>
     ggplot(aes(x = age, y = d18O_VPDB)) +
     geom_line())
#+end_src

#+caption: ODP 198 Site 1210B d13C and d18O data from Shatsky Rise in the equatorial Pacific [cite:@Jung2012].
#+RESULTS:
[[file:imgs/198-1210B_d13C_Jung2012.png]]

But the data are also available on pangaea now in [cite:@Kim2022]
refers to this study for raw data: https://doi.pangaea.de/10.1594/PANGAEA.950806
#+begin_src R :results output graphics file :file imgs/198-1210_d13C_Jung2012-fig6.png :width 900 :height 500
  IODP198_1210B <- pangaear::pg_data("10.1594/PANGAEA.950806")[[1]]

  dat <- IODP198_1210B$data

  (dat |>
   ggplot(aes(x = `Tuned time [Ma] (405)`, y = `δ13C carb [‰ PDB] (vs. VPDB)`)) +
   geom_line() +
   labs(title = "ODP 198 Site 1210B")) /
  (dat |>
    ggplot(aes(x = `Tuned time [Ma] (405)`, y = `δ18O carb [‰ PDB] (vs. VPDB)`)) +
    geom_line())
#+end_src

#+caption: ODP 198 Site 1210B d13C and d18O data from Shatsky Rise in the equatorial Pacific on a tuned age model [cite:@Ji-Eun2022].
#+RESULTS:
[[file:imgs/198-1210_d13C_Jung2012-fig6.png]]

** ODP Leg 74 Site 525A
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 14:57]
:END:
Ma_{405}6 to Ma_{405}8.5

67.8 Ma to 69 Ma

[cite:@Husson2011] grayscale log

*** WAIT waiting for grayscale log in email
:LOGBOOK:
- State "WAIT"       from              [2023-08-31 Thu 15:20]
:END:

** [#B] ODP Leg 207 Site 1258B
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 14:58]
:END:
Ma_{405}8? to Ma_{405}14
is 8 also high amplitude in short ecc?

raw data from https://doi.pangaea.de/10.1594/PANGAEA.266578
analysis copies [cite:@Husson2011]

https://web.iodp.tamu.edu/janusweb/physprops/colordat.cgi

report options: excel compatible CSV <3
be sure to check "output raw data"

#+begin_src R
  library(tidyverse)
  dat <- read_csv("dat/colordat207-1258.csv")

  dat |>
    ggplot(aes(x =`Depth (mcd)`,
               y = `L*`,
               ## y = `a*`,
               ## y = `b*`,
               ## y = `a*` / `b*`,
               colour = H,
               group = paste(Core, H, Sec))) +
    geom_vline(xintercept = 285) + # should be around beginning cycle Ma405_8
    geom_vline(xintercept = 350) + # around end cycle Ma405_14/15
    geom_line()
#+end_src

#+begin_src R :results output graphics file :file imgs/207-1258B_MS_Husson-fig4.png :width 900 :height 500
  ODP207_1258B_MS <- pangaear::pg_data("10.1594/PANGAEA.266578")[[1]]

  dat <- ODP207_1258B_MS$data |>
    rename(depth_mbsf = `Depth sed [m]`,
           depth_mcd = `Depth comp [mcd]`,
           label = `Sample label`,
           MS = `kappa [10**-6 SI]`) #|>
    ## mutate(MS = MS * 1e2) # convert from 10^-6 SI to 10^-8kgm^-3

  mtm <- dat |>
    select(depth_mcd, MS) |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::mtm(xmax = 3, pl = 2) |>
    as_tibble()

  f100 <- dat |>
    select(depth_mcd, MS) |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::taner(flow = 0, fhigh = 0.9, xmax = 3) |>
    as_tibble()

  f405 <- dat |>
    select(depth_mcd, MS) |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::taner(flow = 0, fhigh = 0.4, xmax = 1) |>
    as_tibble()

  dat |>
    ggplot(aes(x = depth_mcd, y = MS)) +
    ## annotate("rect", xmin = 285.9, xmax = 286.5, ymin = -Inf, ymax = Inf,
    ##          fill = "yellow", alpha = .6) + # the K/T boundary
    geom_line(colour = "darkblue") +
    geom_line(aes(y = MS + 5), data = f100, colour = "skyblue") +
    geom_line(aes(y = MS + 7), data = f405, colour = "black") +
    coord_cartesian(xlim = c(285, 350), expand = FALSE) +
    labs(x = "Depth (mbsf)", y = MS ~ "(10"^{-8} ~ "kgm"^{-3} * ")",
         title = "ODP Leg 207 Site 1258B")


  ## rmcd <- pangaear::pg_data("10.1594/pangaea.666132")[[1]]$data

  ## # add rmcd depth
  ## dat <- dat |>
  ##   ## astrochron::tune(controlPts = rmcd, genplot = FALSE)
  ##   mutate(rmcd = approx(x = rmcd$`Depth comp [mcd]`,
  ##                        y = rmcd$`Depth comp r [rmcd]`,
  ##                        xout = dat$`Depth comp [mcd]`)$y)

  # add age model. This links raw mcd and armcd scale to 100 kyr maxima
  # agem <- pangaear::pg_data("10.1594/PANGAEA.666282")
  # but it's a PDF :S

#+end_src

#+caption: ODP 207 Site 1258B MS record (from shipboard) analyzed in the same way as [cite:@Husson2011] using Taner filters.
#+RESULTS:
[[file:imgs/207-1258B_MS_Husson-fig4.png]]

*** SOME get raw data
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 15:21]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-08-31 Thu 15:21]
:END:
from [cite:@Husson2011], they've extended this record!
** ODP Leg 122 Site 762C
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 14:24]
:END:
Grayscale log from [cite:@Husson2011,Thibault2012]

Ma_{405}8 until Ma_{408}17 and then on to Ca_{405}4

~69 Ma to ~77.5 Ma?

These were sent to me by Nicolas Thibault upon request, also cite [cite:@Thibault2012]
reproduce [cite:@Husson2011] figure 3 and 4

#+begin_src R :results output graphics file :file imgs/122-762B_grayscale_Husson-fig4.png :width 900 :height 500
  ODP122_762C_gs <- readxl::read_excel("dat/Thibault2012/pal06092-mmc4.xls",
                                       range = "A1:H7995",
                                       guess_max = 2000)

  dat <- ODP122_762C_gs |>
    rename(depth_ambsf = ambsf, gray = `grey level (0-255)`,
           depth_mbsf = mbsf,
           core = `ODP Site 762C Cores`,
           section = Section,
           remarks = Remarks,
           kyr100 = `100 kyr cycles`,
           kyr405 = `405 kyr cycles`) |>
    mutate(leg = 122, site = 762, hole = "C", .before = core) |>
    mutate(smooth = slider::slide_dbl(gray, mean, .before = 7, .after = 7))

  f100 <- dat |>
    select(depth_ambsf, gray) |>
    astrochron::linterp(genplot = FALSE) |> # TODO: take care of gaps!
    astrochron::taner(flow = 0, fhigh = 1)

  f405 <- dat |>
    select(depth_ambsf, gray) |>
    astrochron::linterp(genplot = FALSE) |> # TODO: take care of gaps!
    astrochron::taner(flow = 0, fhigh = 0.25) # or is it 0.4?

  dat |>
    ## astrochron::linterp(genplot = FALSE) |>
    ggplot(aes(x = depth_ambsf, y = gray)) +
    annotate("rect", xmin = 555.8, xmax = 556.3, ymin = -Inf, ymax = Inf,
             fill = "yellow", alpha = .6) + # the K/T boundary
    ## geom_line(alpha = .2, colour = "darkblue") +
    geom_line(aes(y = smooth), colour = "darkblue") +
    geom_line(aes(y = gray - 90), data = f100, colour = "skyblue") +
    geom_line(aes(y = gray - 100), data = f405, colour = "black") +
    geom_text(aes(label = kyr100, y = 50)) +
    geom_text(aes(label = kyr405, y = 40)) +
    ## coord_cartesian(xlim = c(552, 588), expand = FALSE) +
    scale_y_reverse() +
    labs(title = "ODP122 762C grayscale from photo")
#+end_src

#+caption: ODP 122 Site 762C grayscale record by [cite:@Husson2011], shared with my by [cite:@Thibault2012].
#+RESULTS:
[[file:imgs/122-762B_grayscale_Husson-fig4.png]]

** Bottaccione == Gubbio?
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 16:09]
:END:
d13C and d18O data from [cite:@Sabatino2018]

~ 72.1 Ma to 84.2 Ma (a little more, these are the ages of the Campanian/Maastrichtian and Santonian/Campanian boundaries)

about 12 405 kyr minima

ah, slightly too old? -> can stitch w/ 1210B!

#+begin_src R :results output graphics file :file imgs/Bottaccione_d13C_Sabatino2018.png :width 900 :height 500
  Bottaccione <- readxl::read_excel("dat/Sabatino2018/1-s2.0-S0031018216309336-mmc1.xlsx",
                     range = "A2:C658") |>
    rename(depth = `Sample (m)`,
           d13C_VPDB = `δ13C`,
           d18O_VPDB = `δ18O`)

  Bottaccione |>
    ggplot(aes(x = depth, y = d13C_VPDB)) +
    geom_line() +
    labs(title = "Bottaccione d13C and d18O")
#+end_src

#+caption: Bottaccione d13C record from [cite:@Sabatino2018].
#+RESULTS:
[[file:imgs/Bottaccione_d13C_Sabatino2018.png]]

** Furlo
:PROPERTIES:
:CREATED:  [2023-09-05 Tue 16:09]
:END:
[cite:@Batenburg2016]
color reflectance, carbon/oxygen isotopes from Furlo https://doi.pangaea.de/10.1594/PANGAEA.864715

something like 90 Ma to 96 Ma

straight through the Bonarelli level OAE-2

** Jordanian Levant Platform
:PROPERTIES:
:CREATED:  [2023-09-05 Tue 16:06]
:END:
TOC, d13C, d18O

90.86 Ma to 96.24 Ma

[cite:@Wendler2014]
https://doi.pangaea.de/10.1594/PANGAEA.834794

** apply our method to a hypothetical dataset
:PROPERTIES:
:CREATED:  [2024-01-25 Thu 13:16]
:END:
#+begin_src R
  # create a true "astronomical" signal in the time domain
  # it has just a single 110 kyr cycle and some noise
  tru <- astrochron::cycles(freqs = 1 / 110,
                             start = 0, end = 1999,
                             dt = 1, noisevar = .5,
                            genplot = FALSE, verbose = FALSE) |>
    as_tibble() |>
    mutate(age = time + 66e3) #|> # let's say it's just 66 Ma
    ## mutate(sedrate = ifelse(time < 1000, 3, 5)) |> # cm / kyr
    ## mutate(depth = time * sedrate * 1e-2) # m

  # create an "age model" for this "site" it has the K/T boundary as a tiepoint,
  # and then two more tiepoints that cause it to have a single kink in the
  # sedimentation rate
  agem <- tribble(~ comment, ~ age, ~ depth,
                  "bottom", 68e3, 100,
                  "middle", 67e3, 30,
                  "K/T boundary", 66e3, 0,
                  )

  # calculate the depth based on the age and the age model
  # then calculate teh sedimentation rate
  tru <- tru |>
    mutate(depth = approx(agem$age, agem$depth, .data$age)$y) |>
    mutate(sedrate = (depth - lag(depth)) / (age - lag(age))) |>
    mutate(sedrate = ifelse(is.na(sedrate), 0.03, sedrate)) |>
    mutate(sedrate_group = age < agem$age[[2]])

  # subset so that the sampling resolution is kind of even in the depth domain
  tru <- tru |>
    filter((sedrate_group & tru$time %%2 == 1) | !sedrate_group)
#+end_src

#+begin_src R :results output graphics file :file imgs/synthetic_depth_construction.png :width 2400 :height 1900 :res 300
  # single overview plot of record in time, sedrates, record in depth, spectral
  # analysis in depth
  (
  tru |>
    ggplot(aes(x = age * 1e-3, y = value)) +
    labs(x = "Age (Ma)") +
    scale_x_reverse() +
    geom_line(alpha = .4) +
    geom_vline(xintercept = agem$age * 1e-3)
  ) + (
  tru |>
    ggplot(aes(x = age * 1e-3, y = depth)) +
    labs(x = "Age (Ma)", y = "Depth (m)") +
    geom_line()
  ) + (
  tru |>
    ggplot(aes(x = depth, y = value)) +
    labs(x = "Depth (m)") +
    scale_x_reverse() +
    geom_line(alpha = .4) +
    geom_vline(xintercept = agem$depth)
  ) + (
  tru |>
    spectral_analysis(x = depth, y = value) |>
    plot_spectrum(periods = 1 / c(1 / 110 / 0.07, 1 / 110 / 0.03),
                  ar1 = TRUE) +
    coord_cartesian(xlim = c(0, 0.5)) +
    geom_vline(xintercept = c(0.05, 0.4))
  ) +
    plot_layout(ncol = 2, nrow = 2, heights = 1,
                widths = c(1, 0.5, 1, 0.5))
#+end_src

#+RESULTS:
[[file:imgs/synthetic_depth_construction.png]]

#+begin_src R
  # filtering in the depth domain
  flt <- tru |>
    bandpass_filter(frequencies = tibble(target = "100 kyr",
                                         flow = 0.05, fhigh = 0.4),
                    x = depth, y = value)

  # filter separately for the two sedimentation rates
  nft <- tru |>
    nested_bandpass_filter(frequencies = tibble(target = "100 kyr",
                                                flow = 0.05, fhigh = 0.4),
                    x = depth, y = value, nest = "sedrate_group")
#+end_src

#+begin_src R :results output graphics file :file imgs/synthetic_depth_filters.png :width 2400 :height 1000 :res 300
  # what I think Richard thinks we're doing
  tru |>
    ggplot(aes(x = depth, y = value)) +
    labs(x = "Depth (m)") +
    scale_x_reverse() +
    annotate("text", x = 0, y = 3, label = "K/T") +
    geom_line(alpha = .4) +
    geom_vline(xintercept = agem$depth) +
    geom_line(aes(y = filter, colour = "fullrecord_filter"),
              linewidth = 2, data = flt) +
    geom_line(aes(y = filter, colour = "seperate_filter", group = sedrate_group),
              linewidth = 2, data = nft)
#+end_src

#+RESULTS:
[[file:imgs/synthetic_depth_filters.png]]

#+begin_src R
  # filter in the time domain for everything at once
  flta <- tru |>
    bandpass_filter(frequencies = my_filt_age |> filter(target == "100 kyr"),
                    x = age, y = value)

  # filter in the time domain for the two sedrates separately
  nfta <- tru |>
    nested_bandpass_filter(frequencies = my_filt_age |> filter(target == "100 kyr"),
                    x = age, y = value, nest = "sedrate_group")
#+end_src

#+begin_src R :results output graphics file :file imgs/synthetic_age_filters.png :width 2400 :height 1000 :res 300
  # make a plot
  tru |>
    ggplot(aes(x = age * 1e-3, y = value)) +
    labs(x = "Age (Ma)") +
    annotate("text", x = agem$age[[3]] * 1e-3, y = 3, label = "K/T") +
    scale_x_reverse() +
    geom_line(alpha = .4) +
    geom_vline(xintercept = agem$age * 1e-3) +
    geom_line(aes(y = filter, colour = "fullrecord_filter"),
              linewidth = 2, data = flta) +
    geom_line(aes(y = filter, colour = "seperate_filter"),
              linewidth = 2, alpha = .7, data = nfta)

  # has a big influence on the amplitude near the gaps, but is identical
  # otherwise.
#+end_src

#+RESULTS:
[[file:imgs/synthetic_age_filters.png]]

* References
:PROPERTIES:
:UNNUMBERED: t
:END:
# \printbibliography[heading=none]
#+bibliography: /home/japhir/SurfDrive/bibliography/references.bib
#+cite_export: csl apa.csl
#+print_bibliography:

#+begin_src emacs-lisp :eval never
  (setq org-cite-export-processors '((latex biblatex) (t csl)))
#+end_src

* can you get low amplitude in 100 kyr filter from noise?
:PROPERTIES:
:CREATED:  [2024-04-16 Tue 12:02]
:END:
#+begin_src R
  dat <- tibble(x = 1:1000, y = astrochron::ar1(1000, genplot = FALSE)$V2, s = rnorm(1000), z = y + s)
#+end_src

#+begin_src R :results output graphics file :file imgs/2024-04-16_ar1+white_noise_spectrum.png :width 800
  dat |>
    spectral_analysis(x = x, y = z) |>
    plot_spectrum(confidence = TRUE, logy = TRUE) +
    annotate("rect", xmin = 0.015, xmax = 0.03, ymin = 1e-5, ymax = 1e-1, fill = "red", alpha = .3) +
    annotate("rect", xmin = 0.038, xmax = 0.045, ymin = 1e-5, ymax = 1e-1, fill = "red", alpha = .3)
    ## coord_cartesian(xlim = c(0, 0.2))
#+end_src

#+RESULTS:
[[file:imgs/2024-04-16_ar1+white_noise_spectrum.png]]

#+begin_src R
  flt <- dat |>
    taner_filter(frequencies = tibble(target = c("one", "two"), flow = c(0.015, 0.038), fhigh = c(0.03, 0.045)), x = x, y = z)
#+end_src

#+begin_src R :results output graphics file :file imgs/2024-04-16_ar1+white_noise_filter.png :width 800
  dat |>
    ggplot(aes(x = x, y = y)) +
    geom_line() +
    geom_line(aes(y = filter, colour = target), linewidth = 2, data = flt)
#+end_src

#+RESULTS:
[[file:imgs/2024-04-16_ar1+white_noise_filter.png]]

so what did I learn here?

My question was:
* latex settings that I haven't settled on yet         :noexport:
:PROPERTIES:
:CREATED:  [2023-11-17 Fri 13:08]
:END:
#+latex_compiler: lualatex
#+latex_header: \usepackage[utf8]{luainputenc}
** engraved
:PROPERTIES:
:CREATED:  [2023-11-22 Wed 10:54]
:END:
installed ~engrave-faces~.
# #+latex_engraved_theme: modus-operandi
#+begin_src emacs-lisp
  (setq org-latex-src-block-backend 'engraved)
#+end_src

#+RESULTS:
: engraved
