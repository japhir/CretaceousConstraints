#+PROPERTY: header-args:R  :session *R:cretaceous-constraints* :exports results :results output :eval no-export
#+options: TOC:nil
* COMMENT libs
#+begin_src R :exports code
  library(tidyverse)
  library(patchwork)
  theme_set(theme_bw())
#+end_src

#+RESULTS:
#+begin_example
── Attaching core tidyverse packages ───────────────────────────────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.2     ✔ readr     2.1.4
✔ forcats   1.0.0     ✔ stringr   1.5.0
✔ ggplot2   3.4.3     ✔ tibble    3.2.1
✔ lubridate 1.9.2     ✔ tidyr     1.3.0
✔ purrr     1.0.2
── Conflicts ─────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
#+end_example

* COMMENT look at the orbital solution
:PROPERTIES:
:CREATED:  [2023-08-30 Wed 17:04]
:END:
#+begin_src R

#+end_src

* COMMENT reproduce [cite:@Ma2017] steps
:PROPERTIES:
:CREATED:  [2023-08-28 Mon 10:52]
:END:
Load the R package Astrochron
This analysis uses version 0.6.6. Please use versions >= 0.6.6.

#+begin_src R
  library(astrochron)
#+end_src

#+RESULTS:
: Welcome to astrochron v1.2 (2023-08-25)
:  Type ?astrochron to learn more

** read in data
Read the Libsack FMI data from Locklair & Sageman (2008)
This should be a comma-separated-value file (.csv), with first column as depth
    (meters) and second column as FMI.

#+begin_src R
  FMI <- read("dat/Ma2017/data.csv")
#+end_src

** interpolate to median sampling interval
This data set has a sampling interval
that ranges from 0.030478 to 0.030479 m. Interpolate the data to a sampling interval of 0.03 m.

#+begin_src R
  FMI_0.03 <- linterp(FMI, dt = 0.03)
#+end_src

** Tune the FMI record using the long-eccentricity cycle
*** bandpass filter long eccentricity
Extract Locklair & Sageman’s (2008) long-eccentricity cycle using bandpass filtering.

#+begin_src R
  longEcc <- bandpass(FMI_0.03, flow = 0.14, fhigh = 0.26, xmax = 0.5, padfac = 5, win = 2, p = 0.66)
#+end_src

*** find the peak
Find the peak associated with each long eccentricity cycle.

#+begin_src R
  eccMax <- peak(longEcc)
#+end_src

*** construct floating time
Construct the floating time (elapsed time) vs. core depth map for tuning.

#+begin_src R
  timeControl <- cb(eccMax[, 2], (0:18) * 405)

  plot(timeControl, type = "l", lwd = 2, xlab = "Depth (m)", ylab = "Elapsed Time (ka)")
#+end_src

*** tune
Tune (the original FMI data) using the time vs. core depth map.

#+begin_src R
  tuned <- tune(FMI, timeControl, extrapolate = TRUE)
#+end_src

** interpolate
This tuned data set has a sampling interval that ranges from 1.714387 to
3.774922 ka. Interpolate the tuned data to the median sampling interval of ~2.5
ka.

#+begin_src R
  tuned_2.5 <- linterp(tuned, dt = 2.5)
#+end_src

** anchor to radioisotopic age
Convert result from floating (elapsed) time to radioisotopically-anchored
time, using the nominal radioisotopic anchoring (S.p. ammonite biozone). The
radioisotopic age, and its depth in the Libsack core, come from Table 1.

#+begin_src R
  anchorAt <- resample(timeControl, xout = 2147.62, genplot=FALSE)[, 2]
  anchored <- anchorTime(tuned_2.5, time = anchorAt, age = 89370, timeDir = 2)
#+end_src

*** plot
Now create a plot of radioisotopically-anchored time vs. depth.
#+begin_src R
  timeDepth <- tuned
  timeDepth[2] <- FMI[1]
  anchoredTimeDepth <- anchorTime(timeDepth, time = anchorAt, age = 89370, timeDir = 2, genplot = FALSE)

  pl(1);
  plot(anchoredTimeDepth,
       type = "l", lwd = 2, col = "red",
       ylim = c(max(FMI[1]), min(FMI[1])),
       xlab = "Time (ka)", ylab = "Depth (m)",
       cex.lab = 1.2)
#+end_src

*** create basic plot using ggplot
#+begin_src R
  library(ggplot2)
  library(patchwork)
  library(dplyr)

  pl_FMI <- FMI |>
    tibble::as_tibble() |>
    ggplot(aes(x = Depth_m, y = FMI_ohm.m)) +
    geom_line() +
    labs(x="Depth (m)",
         y = "FMI"~Ohm~"(m)")
  pl_anchored <- anchored |>
    tibble::as_tibble() |>
    rename(Time_ka = X1, FMI_ohm.m = X2) |>
    ggplot(aes(x = Time_ka/1e3, y = FMI_ohm.m)) +
    geom_line() +
    scale_x_continuous(
      breaks = 80:92,
      minor_breaks = seq(80, 92, 0.1)) +
    labs(x = "Age (Ma)",
         y = "FMI Ohm (m)") # not sure if this is what it is.
  pl_FMI/pl_anchored
#+end_src

** EPSA/EHA
Conduct evolutive power spectral analysis (EPSA) and evolutive harmonic analysis (EHA)
for the tuned & anchored FMI data using a 500-ka moving window (with linear trend
removal), and three 2pi prolate tapers. Plot amplitude normalized to unity
(for each window) to reveal changes in relative strength.

#+begin_src R
  pwr <- eha(anchored, win = 500, fmax = .1, output = 2, pl = 1,
             pad = 5000, genplot = 3, ydir = -1,
             xlab = "Frequency (cycles/ka)", ylab = "Age (ka)")
#+end_src

** power modulation of obliquity
Determine power modulation of obliquity terms using EPSA results. Integrate
the obliquity power from 0.018 to 0.037 cycles/ka.

#+begin_src R
  integrate_obl <- integratePower(pwr, flow = 0.018, fhigh = 0.037,
                                  npts = 201, pad = 5000, ln = TRUE,
                                  ydir = -1)
#+end_src

** power modulation of short ecc
Determine power modulation of short eccentricity terms.
Integrate the short eccentricity power from 0.007 to 0.012 cycles/ka.

#+begin_src R
  integrate_ecc <- integratePower(pwr, flow = 0.007, fhigh = 0.012,
                                  npts = 201, pad = 5000, ln = TRUE,
                                  ydir = -1)
#+end_src

** amplitude modulation of long ecc
Evaluate amplitude modulation of the long eccentricity term (405 ka), following
removal of bias associated with long-term (>1 Myr) variance, using Lowess.

# note: win = 2 means a cosine-tapered (Tukey) window
#+begin_src R
  longEcc2 <- bandpass(noLow(anchored, 0.1, genplot = FALSE),
                       flow = .002, fhigh = .0035,
                       win = 2, p = 0.66, padfac = 5, xmax = .02)

  hilEcc2 <- hilbert(longEcc2, addmean=TRUE)
#+end_src

** plot summary
Plot summary figures.
#+begin_src R
  xlim1 <- c(82707.41, 89932.41)
  pl(r = 3, c = 1)
  plot(cb(integrate_obl, c(1, 2)),
       type = "l", lwd = 2, col = "red",
       ylab = "Obliquity Band Power", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  plot(cb(integrate_ecc, c(1, 2)),
       type = "l", lwd = 2, col = "red",
       ylab = "Short-Eccentricity Band Power", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  plot(longEcc2, type = "l", lwd = 2, col = "red",
       ylab = "Long-Eccentricity Bandpass", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  lines(hilEcc2)
  pl(r = 3, c = 1)
  plot(cb(integrate_obl, c(1, 4)),
       type = "l", lwd = 2, col = "red",
       ylab = "Obliquity/Total Power", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  plot(cb(integrate_ecc, c(1, 4)),
       type = "l", lwd = 2, col = "red",
       ylab = "Short-Eccentricity/Total Power", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  plot(longEcc2, type = "l", lwd = 2, col = "red",
       ylab = "Long-Eccentricity Bandpass", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  lines(hilEcc2)
  pl(r = 3, c = 1)
  plot(cb(integrate_ecc, c(1, 2)),
       type = "l", lwd = 2, col = "red",
       ylab = "Short-Eccentricity Band Power", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  plot(cb(integrate_ecc, c(1, 4)),
       type = "l",lwd = 2, col = "red",
       ylab = "Short-Eccentricity/Total Power", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  plot(longEcc2,
       type = "l", lwd = 2, col = "red",
       ylab = "Long-Eccentricity Bandpass", xlab = "Time (ka)",
       cex.lab = 1.2, xlim = xlim1)
  lines(hilEcc2)
#+end_src

* COMMENT read [cite:@ZeebeLourens2019,@ZeebeLourens2022] to reproduce their approach
:PROPERTIES:
:CREATED:  [2023-08-28 Mon 11:56]
:END:
:LOGBOOK:
CLOCK: [2023-08-28 Mon 17:02]--[2023-08-28 Mon 17:10] =>  0:08
CLOCK: [2023-08-28 Mon 14:55]--[2023-08-28 Mon 17:02] =>  2:07
- try to reproduce, cannot figureit out?
CLOCK: [2023-08-28 Mon 14:10]--[2023-08-28 Mon 14:55] =>  0:45
- do 2.4 Myr analysis on ZB18a
CLOCK: [2023-08-28 Mon 11:20]--[2023-08-28 Mon 12:08] =>  0:48
:END:

Richard's code
#+begin_src matlab
f  = 1./2000;
df = 0.6;

yf{i} = gaussfilter(t{i},y{i},f,df*f,2*df*f,0.0);

[~,ix{i}] = findpeaks(-yf{i});
kv = ix{i};
dt{i} = diff(t{i}(kv));
#+end_src


#+begin_src R
  library(tidyverse)

  # get orbital solution sol
  sol <- snvecR::get_ZB18a() |>
    select(age, ee)

  # Do the same as Zeebe and Lourens 2022:
  # filter 2 Myr ± 60% Gaussian
  # 2 Myr = 2000 kyr period = 1 / 2000 period
  x11(type = "cairo")
  bp2000 <- sol |>
    astrochron::bandpass(
                  padfac = 10, # 10x the number of data points
                  # parameterized as I understand Richard's matlab code
                  # this doesn't make any sense to me
                  ## flow = 0.6 * 1 / 2000,
                  ## fhigh = 2 * 0.6 * 1 / 2000,
                  flow = 1 / 2000 - 0.6 * 1 / 2000,
                  fhigh = 1 / 2000 + 0.6 * 1 / 2000,
                  win = 1, # Gaussian window
                  demean = TRUE, detrend = TRUE, #???
                  addmean = FALSE,
                  xmax = .02)
  grDevices::savePlot("imgs/2023-08-28_0_2Myr_bandpass_filter.png")

  # get the peak maxima
  pk2000 <- bp2000 |>
    astrochron::peak()
  grDevices::savePlot("imgs/2023-08-28_1_peak.png")

  # but in the paper they do peak minima, we just flip the input
  pk2000_flip <- bp2000 |>
    mutate(ee = -ee) |>
    astrochron::peak(genplot = TRUE)
  grDevices::savePlot("imgs/2023-08-28_2_peak.png")

  # calculate deltas between peaks
  pk2000_tidy <- pk2000 |>
    as_tibble() |>
    # different ways to calculate the delta
    mutate(delta_vln_lag = Location - lag(Location)) |> # this one minus previous one
    mutate(delta_vln = lead(Location) - Location) # next one minus this one
  pk2000_flip_tidy <- pk2000_flip |>
    as_tibble() |>
    mutate(delta_vln_lag = Location - lag(Location)) |>
    mutate(delta_vln = lead(Location) - Location)

  # check that peak id has gone well
  bp2000 |>
    ggplot(aes(x = age, y = ee)) +
    geom_line() +
    geom_point(aes(x = Location, y = Peak_Value, colour = "maxima"), data = pk2000_tidy) +
    geom_point(aes(x = Location, y = -Peak_Value, colour = "minima"), data = pk2000_flip_tidy)
  ggsave("~/SurfDrive/Postdoc1/prj/2023-05-19_cretaceous/imgs/2023-08-28_3_check_peaks.png")

  # create a plot similar to Zeebe and Lourens 2022 EPSL figure 6a
  pk2000_tidy |>
    ggplot(aes(x = Location / 1000, y = delta_vln / 1000)) +
    ## geom_point(aes(colour = "maxima lead")) +
    ## geom_line(aes(colour = "maxima lead")) +
    geom_point(aes(colour = "minima lead"), data = pk2000_flip_tidy) +
    geom_line(aes(colour = "minima lead"), data = pk2000_flip_tidy) +
    # did they use the half-distance? nope
    ## geom_point(aes(x = (Location + .5 * (lead(Location) - Location)) / 1000, colour = "minima lead"), data = pk2000_flip_tidy) +
    ## geom_line(aes(x = (Location + .5 * (lead(Location) - Location)) / 1000, colour = "minima lead"), data = pk2000_flip_tidy) +
    ## geom_point(aes(y = delta_vln_lag / 1000, colour = "maxima lag")) +
    ## geom_line(aes(y = delta_vln_lag / 1000, colour = "maxima lag")) +
    ## geom_point(aes(y = delta_vln_lag / 1000, colour = "minima lag"), data = pk2000_flip_tidy) +
    ## geom_line(aes(y = delta_vln_lag / 1000, colour = "minima lag"), data = pk2000_flip_tidy) +
    labs(x = "Age (Ma)",
         y = Delta[VLN] ~ "Interval between min/max in 2-Myr ecc filter (Myr)") +
    scale_x_continuous(breaks = seq(40, 80, 5)) +
    coord_cartesian(xlim = c(44, 70), ylim = c(0, 3))

  ggsave("imgs/2023-08-28_4_Dvln.png", width = 8, height = 3)
  ## ggsave("~/SurfDrive/Postdoc1/prj/2023-05-19_cretaceous/imgs/2023-08-28_4_Dvln.png")
#+end_src

#+RESULTS:
#+begin_example

----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----
 ,* Number of data points= 250001
 ,* Sample interval= 0.4
 ,* Mean value removed= 0.02683078
 ,* Center of bandpass filter = 5e-04
 ,* 600 pos/neg frequency pairs will be bandpassed

----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
 ,* Number of data points= 250001
 ,* Number of columns= 2
 ,* Identifying maxima of peaks
 ,* Number of peaks identified= 50

 ,* No filtering of peaks applied.

----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
 ,* Number of data points= 250001
 ,* Number of columns= 2
 ,* Identifying maxima of peaks
 ,* Number of peaks identified= 51

 ,* No filtering of peaks applied.
Saving 7 x 6.99 in image
Warning messages:
1: Removed 1 rows containing missing values (`geom_point()`).
2: Removed 1 row containing missing values (`geom_line()`).
Warning messages:
1: Removed 1 rows containing missing values (`geom_point()`).
2: Removed 1 row containing missing values (`geom_line()`).
#+end_example

** filter orbital solutions
#+begin_src R
  # test whether filtering is the same for comparison with Zeebe and Lourens 2022 EPSL fig B2
  ## ZB20a <- readr::read_table("http://www.soest.hawaii.edu/oceanography/faculty/zeebe_files/Astro/300Myr/ZB20a.dat",
  ##                            col_names = c("time", "ecc", "inc"), skip = 1) |>
  ##   readr::write_rds("out/ZB20a.rds")
  ZB20a <- readr::read_rds("out/ZB20a.rds")

  ZB20a |>
    ggplot(aes(x = time / 1000, y = ecc)) +
    geom_line() +
    coord_cartesian(xlim = c(63, 66))


  ZB20a_bp100 <- ZB20a |>
    astrochron::bandpass(flow = 1 / 100 - 0.0016 * 1 / 100,
                         fhigh = 1 / 100 + 0.0016 * 1 / 100,
                         padfac = 1000,
                         win = 1,
                         demean = TRUE, detrend = TRUE)

  # this is how Richard filters the 405 kyr cycle in his solution
  ZB20a_bp405 <- ZB20a |>
    select(time, ecc) |>
    astrochron::bandpass(flow = 1 / 405 - 0.0004,
                         fhigh = 1 / 405 + 0.0004,
                         padfac = 10,
                         win = 1, # gaussian window
                         demean = TRUE, detrend = TRUE,
                         xmax = 0.005) |>
    as_tibble()

  ZB20a_bp405_narrower <- ZB20a |>
    select(time, ecc) |>
    astrochron::bandpass(flow = 1 / 405 - 0.0001,
                         fhigh = 1 / 405 + 0.0001,
                         padfac = 10,
                         win = 1, # gaussian window
                         demean = TRUE, detrend = TRUE,
                         xmax = 0.005) |>
    as_tibble()

  ZB20a_bp405_wider <- ZB20a |>
    select(time, ecc) |>
    astrochron::bandpass(flow = 1 / 405 - 0.001,
                         fhigh = 1 / 405 + 0.001,
                         padfac = 10,
                         win = 1, # gaussian window
                         demean = TRUE, detrend = TRUE,
                         xmax = 0.005) |>
    as_tibble()

  ZB20a_bp405_widest <- ZB20a |>
    select(time, ecc) |>
    astrochron::bandpass(flow = 1 / 405 - 0.0024,
                         fhigh = 1 / 405 + 0.0024,
                         padfac = 10,
                         win = 1, # gaussian window
                         demean = TRUE, detrend = TRUE,
                         xmax = 0.005) |>
    as_tibble()

  ZB20a_bp405 |>
    mutate(filt="default") |>
    bind_rows(
      ZB20a_bp405_narrower |>
      mutate(filt="narrower")) |>
    bind_rows(
      ZB20a_bp405_wider |>
      mutate(filt="wider")) |>
    bind_rows(
      ZB20a_bp405_widest |>
      mutate(filt = "widest")) |>
    ggplot(aes(x=time,y=ecc, colour = filt)) +
    geom_line() +
    geom_line(aes(colour="ZB18a default"), data = bp405 |> rename(time = age, ecc = ee)) +
    geom_line(aes(colour = "ZB20a raw"), alpha = .3, data = ZB20a) +
    geom_line(aes(colour = "ZB18a raw"), alpha = .3, data = snvecR::get_ZB18a() |> select(time = age, ecc = ee)) +
    coord_cartesian(xlim=c(65400, 74200))
#+end_src

#+begin_src R
  # everything below is a big hot mess!

  bp405 <- sol |>
    ## filter(age < 50e3) |>
    astrochron::bandpass(flow = 1 / 405 - .0004,
                         fhigh = 1 / 405 + .0004,
                         padfac = 10,
                         win = 1,
                         demean = TRUE, detrend = TRUE,
                         xmax = .02)

  ## eha405 <- snvecR::get_ZB18a() |>
  ##   select(age, ee) |>
  ##   astrochron::eha(fmax = .1, pl = 1, output = 2, pad = 5000, genplot = 3, ydir = -1)

  ## integrate_ecc <- eha405 |>
  ##   astrochron::integratePower(flow = 0.007, fhigh = 0.012,
  ##                              npts = 201, pad = 5000, ln = TRUE,
  ##                              ydir = -1)

  ## bp405_2 <- sol |>
  ##   noLow(smooth = 1000, genplot = TRUE) |>
  ##   bandpass(flow = .002, fhigh = .0035,
  ##            win = 2, p = 0.66, padfac = 5, xmax = .02)

  ## hb405_2 <- bp405_2 |>
  ##   astrochron::hilbert()

  hb405 <- bp405 |>
    astrochron::hilbert()

  # this doesn't work well on the hilbert transform, finds many peaks because of noise?
  pk405 <- hb405 |>
    astrochron::peak()

  pkf405 <- pk405 |>
    as_tibble() |>
    tidylog::mutate(diff = Location - lag(Location)) |>
    ## ggplot(aes(x = Location, y = diff)) + geom_point()
    tidylog::filter(diff > 500) #|>
    ## tidylog::filter(Location > 4000) |> # filter out youngest weird few
    ## tidylog::filter(Location < 93e3)
    ## tidylog::filter(!ID %in% c(142107, 17355, 174355, 203304, 225749))

  pkf405 |>
    ggplot(aes(x = Location, y = diff)) + geom_point() + geom_line()

  pkf405 |>
    ggplot(aes(x = Location, y = Peak_Value, ID = ID)) +
    geom_point() +
    geom_line(aes(x = age, y = ee - mean(ee), ID = NULL), data = bp405)
    ## geom_line(aes(x = age, y = envelope, ID = NULL), data = hb405_2)

  pkf405 |>
    ggplot(aes(x = diff)) +
    ## geom_histogram(binwidth = 1000) +
    geom_density()
#+end_src

** how can I calculate the average spectral misfit?
:PROPERTIES:
:CREATED:  [2023-08-28 Mon 17:14]
:END:

* get overview of dataset
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 12:48]
:END:
sorted from young to older, longest records at the end

** [#C] IODP Leg 208 Site 1262
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 16:37]
:END:
color reflectance a* used in [cite:@ZeebeLourens2019]
d13C/d18O available in https://doi.pangaea.de/10.1594/PANGAEA.854816
53 Ma to 58 Ma
[[https://web.iodp.tamu.edu/janusweb/imaging/photo.cgi][section photo's]]

color reflectance a*/b* used in [cite:@ZeebeLourens2022EPSL]
in combination with site 1209, Zumaia
56 Ma to 66 Ma

[[http://www-odp.tamu.edu/publications/208_IR/chap_03/chap_03.htm][initial reports]]

http://web.iodp.tamu.edu/OVERVIEW/
ah here it is:
https://web.iodp.tamu.edu/janusweb/physprops/colordat.cgi?leg=208&site=1262

or search for it via https://web.iodp.tamu.edu/janusweb/physprops/colordat.shtml
figure from initial reports: http://www-odp.tamu.edu/publications/208_IR/chap_03/c3_f9.htm

get conversion between MBSF and MCD here http://web.iodp.tamu.edu/OVERVIEW/?&exp=208&site=1263
figure of conversion between MBSF and MCD, 3 linear fits for different holes
http://www-odp.tamu.edu/publications/208_IR/chap_03/c3_f5.htm

I'm not going to put too much effort in, Richard should have this analysis according to Luc.

#+begin_src R :results output graphics file :file imgs/208-1262_color_ZeebeLourens2019-2022.png :width 900 :height 500
  ODP208_1262_col <- readr::read_tsv("dat/ODP208_1262_color_reflectance.dat",
                                     guess_max = 3000)
  # add MCD
  spl <- readr::read_tsv("dat/ODP208_1262_splice.dat")
  spl_tie <- readr::read_tsv("dat/ODP208_1262_splice_tie.dat")

  # add preliminary age model
  wr_agem <- readxl::read_excel("dat/ZeebeLourens2022EPSL/agem.xlsx",
                             range = "A3:K29")

  ODP208_1262_col |>
    ggplot(aes(x = `Depth (mbsf)`, y = scale(`a*` / `b*`))) +
    geom_line() +
    coord_cartesian(xlim = c(140, 220)) +
    labs(title = "ODP 208 Site 1264 Color reflectance")
#+end_src

#+RESULTS:
[[file:imgs/208-1262_color_ZeebeLourens2019-2022.png]]

** [#A] Hendaye
:PROPERTIES:
:CREATED:  [2023-09-18 Mon 16:42]
:END:
via [[id:107d5e85-9f0d-4193-941d-7b8887fa4d28][Frits Hilgen]]
[[mu4e:msgid:AS8PR05MB10601D055071F8CD08F7C0153DBFBA@AS8PR05MB10601.eurprd05.prod.outlook.com][RE: Paper: Earth beyond six of nine planetary boundaries]]
66 Ma until 64 Ma
multi-proxy study of the interval from the K/Pg boundary up to cycle 20 of [cite:@Dinares-Turell2003].

only photos for now
linked to Zumaia, but no turbidites
[[file:imgs/Hendaye_tuning_Frits-Hilgen.pdf::3]]

shows expression of weak 200 kyr eccentricity cycle and oldest node of 2-Myr cycle
Frits thinks this wasn't taken into account in ZL2022 b/c Luc didn't believe in the 200 kyr cycle.

** [#C] IODP Leg 198 Site 1209
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 17:29]
:END:
56 Ma to 66 Ma
color reflectance used in [cite:@ZeebeLourens2022EPSL]
#+begin_src R :results output graphics file :file imgs/198-1209_color_ZeebeLourens2019-2022.png :width 900 :height 500
  ODP198_1209_col <- readr::read_tsv("dat/ODP198_1209_color_reflectance.dat")
  ## spl <- readr::read_tsv("dat/ODP198_1209_splice.dat")
  ## spl_tie <- readr::read_tsv("dat/ODP198_1209_splice_tie.dat")
  ODP198_1209_col |>
    ggplot(aes(x = `Depth (mbsf)`, y = `a*`)) +
    geom_line() +
    coord_cartesian(xlim = c(252.5, 261.6)) +
    labs(title = "ODP 198 Site 1209 Color reflectance")
#+end_src

#+RESULTS:
[[file:imgs/198-1209_color_ZeebeLourens2019-2022.png]]

** Contessa highway section
:PROPERTIES:
:CREATED:  [2023-09-05 Tue 15:59]
:END:
[cite:@Sinnesael2016] https://doi.pangaea.de/10.1594/PANGAEA.864450
MS, CaCO3, d13C, d18O
uppermost Maastrichtian to lower Danian
62.5 Ma to 67 Ma

combined with Bottaccione
#+begin_src R :results output graphics file :file imgs/Contessa_MS_Sinnesael2016.png :width 900 :height 500
  Contessa <- pangaear::pg_data("10.1594/PANGAEA.864450")[[1]]

  dat <- Contessa$data

  dat |>
    ggplot(aes(x = `Section [m]`, y = `chi [10**-9 m**3/kg]`)) +
    geom_line() +
    labs(title = "Contessa Highway Magnetic Susceptibility")
#+end_src

#+RESULTS:
[[file:imgs/Contessa_MS_Sinnesael2016.png]]

** [#A] ODP Leg 208 Site 1267
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 12:49]
:END:
via [cite:@Husson2011] figure 3 and 4
Ma_{405}1 to Ma_{405}6 or 7
66 Ma to ~68.6
raw magsus data from [cite:@Blum2005] https://doi.pangaea.de/10.1594/PANGAEA.266605
also related: [cite:@Zachos2004]

*** Magsus data analyzed similarly to [cite:@Husson2011]
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 11:22]
:END:
depth sed [m] from 0.05 to 329 m
depth comp [mcd] from 0.05 to 368 m

208-1267B-1H-1,5 to 208-1267B-36X-7,37.5

#+begin_src R :results output none
  library(tidyverse)
  theme_set(theme_bw())

 # get hole A directly from Janus database:
  ODP208_1267_MS_A <- readr::read_tsv("https://web.iodp.tamu.edu/janusweb/physprops/msldat.cgi?leg=208&site=1267&hole=A",
                  comment = "<") |> # this comment gets rid of all the html headers
    filter(str_detect(Leg, "^208")) # this gets rid of some stuff at the bottom of the page
  ODP208_1267_MS_B <- readr::read_tsv("https://web.iodp.tamu.edu/janusweb/physprops/msldat.cgi?leg=208&site=1267&hole=B",
                  comment = "<") |> # this comment gets rid of all the html headers
    filter(str_detect(Leg, "^208")) # this gets rid of some stuff at the bottom of the page
  # so we have Depth (mbsf) and would like to convert it to the new rmcd
#+end_src

**** same plot as in [cite:@Husson2011] figure 4
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 13:17]
:END:
#+begin_src R :results output graphics file :file imgs/208-1267B_MS_Husson-fig4.png :width 900 :height 500
  # somehow they also put these data on PANGAEA (I found this one first)
  # this is for hole B
  ODP208_1267_MS_B_pg <- pangaear::pg_data("10.1594/PANGAEA.266605")[[1]]

  ## ODP208_1267_MS$data |>
  ##   select(`Sample label`) |>
  ##   separate(`Sample label`, into = c("leg", "sitehole", "coretype", "sectioninterval"),
  ##            sep = "-") |>
  ##   separate(sectioninterval, into = c("section", "interval"), sep = ",") |>
  ##   separate(sitehole, into = c("site", "hole"), sep = 4) |>
  ##   separate(coretype, into = c("core", "type"), sep = -1) |>
  ##   write_csv("out/ODP208_1267_MS.csv")

  dat <- ODP208_1267_MS_B_pg$data |>
    select(
      depth = `Depth sed [m]`, # they use mbsf in Husson et al., 2011!!
      ## depth = `Depth comp [mcd]`,
      MS = `Suscept corr`) |>
    filter(depth >= 285.9)

  mtm <- dat |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::mtm(xmax = 10, pl = 1) |> # basically only ~40 cm cycles
    ## astrochron::lowspec(xmax = 10, pl = 1) |>
    as_tibble()
  abline(v = c(1.4, 1.6))

  f100_2 <- dat |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::bandpass(flow = 1.4, fhigh = 1.6, win = 1, padfac = 10)

  f100 <- dat |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::taner(flow = 0, fhigh = 0.9, xmax = 3) |>
    as_tibble()


  f405 <- dat |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::taner(flow = 0, fhigh = 0.25, xmax = 1) |>
    as_tibble()

  dat |>
    ggplot(aes(x = depth, y = MS)) +
    annotate("rect", xmin = 285.9, xmax = 286.5, ymin = -Inf, ymax = Inf,
             fill = "yellow", alpha = .6) + # the K/Pg boundary
    geom_line(colour = "darkblue") +
    geom_line(aes(y = MS + 50), data = f100, colour = "skyblue") +
    geom_line(aes(y = MS + 70), data = f405, colour = "black") +
    coord_cartesian(xlim = c(287.4, 330), ylim = c(0, 300)) +
    labs(x = "Depth (mbsf)", y = MS ~ "(10"^{-8} ~ "kgm"^{-3} * ")",
         title = "ODP Leg 208 Site 1267B")

  ## dat <- ODP208_1267_MS_B_pg$data |>
    ## select(depth = `Depth comp [mcd]`, MS = `Suscept corr`) #|>
    ## filter(depth >= 285.9)

  ## dat |>
  ##   ggplot(aes(x = depth, y = MS)) +
  ##   geom_line()
#+end_src

#+RESULTS:
[[file:imgs/208-1267B_MS_Husson-fig4.png]]

*** [#B] convert from mbsf and mcd to rmcd
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 11:29]
:END:
**** COMMENT 1267 rmcd to 1262 rmcd
#+begin_src R
  # https://doi.pangaea.de/10.1594/PANGAEA.666132
  # NO! This is 1267 rmcd vs 1262 mcd!!!
  rmcd <- pangaear::pg_data("10.1594/pangaea.666132")[[1]]$data
  # this only covers mcd 104--236
  # but I care only about depths in mbsf > ~285.9
  ## ODP208_1267_MS$data |>
  ##   filter(`Depth sed [m]` > 285)
  # so that's roughly 320 rmcd

  # I have Depth comp [mcd] in my original MS dataset

  ## # add rmcd depth
  dat <- dat |>
    astrochron::tune(controlPts = rmcd, genplot = FALSE)
    mutate(rmcd = approx(x = rmcd$`Depth comp [mcd]`,
                         y = rmcd$`Depth comp r [rmcd]`,
                         xout = dat$`Depth comp [mcd]`)$y)
#+end_src
why do we need this? It would allow me to apply the agemodel of others' to our record to check, what else?
I need to integrate hole A and B into a single splice.

**** original shipboard report
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 09:34]
:END:
simple conversion between mbsf and mcd table:
http://www-odp.tamu.edu/publications/208_IR/chap_08/c8_t2.htm#563154

single splice table
http://www-odp.tamu.edu/publications/208_IR/chap_08/c8_t3.htm#564205

table also available in ASCII: http://www-odp.tamu.edu/publications/208_IR/VOLUME/TABLES/IR208_08/08_T03.TXT
**** shipboard section mbsf/mcd
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:20]
:END:
#+begin_src R
  mbsf <- readr::read_tsv("dat/ODP208_1267_core-section-summary.dat")
  mcd <- readr::read_tsv("dat/ODP208_1267_splice-mcd.dat") |>
    mutate(length = `MCD Bot` - `MCD Top`)
#+end_src
**** CANC janus web tool
CLOSED: [2023-09-20 Wed 11:32]
does this do what I want?
https://web.iodp.tamu.edu/janusweb/general/splice.cgi
doesn't work anymore

**** splice table from Röhl 2007
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 11:19]
:END:
https://doi.pangaea.de/10.1594/PANGAEA.667174?format=html#download
this has depth from 202.78 m(bsf?) to 209 m
from 227.08 to 235.24 rmcd

**** splice table from [cite:@Westerhold2008] PDF
https://doi.pangaea.de/10.1594/PANGAEA.592301

another PDF :S
[[file:~/Downloads/208-1267_TabS7_tie_points.pdf]]

this has hole core section interval depth_mbsf depth_rmcd
tie to / append to / end of splice
new mbsf / rmcd

manually converted to csv again (using tabula/copy-paste).
this one was a bit easier than the one with many sites)

this links hole A to hole B and vice-versa
depth_mbsf from 25.2 m to 329
depth_rmcd from 28.6 m to 367 m

same as shipboard MCD above 180.25 MCD, adjusted below

#+begin_src R :results none
  # the full splice table
  rmcd <- readr::read_csv("dat/ODP208_1267_rmcd.csv") |>
    separate(label, into = c("sitehole", "coretype", "Sec"),
               sep = "-", remove = FALSE) |>
    separate(sitehole, into = c("Site", "H"), sep = -1) |>
    separate(coretype, into = c("Core", "T"), sep = -1) |>
    # we do not rename the interval, may not be the same as in the data!
    # rename the CC sections into 7, the naming convention in the MS data
    mutate(Sec = ifelse(Sec == "7", "7", Sec),
           Sec = ifelse(Sec == "cc", "7", Sec)) |>
    mutate(diff = depth_rmcd - depth_mbsf, .after = depth_rmcd) |>
    mutate(diff2 = depth_rmcd2 - depth_mbsf2, .after = depth_rmcd2) |>
    mutate(row = 1:n())

  # the right side of the splice table only
  rmcd2 <- rmcd |>
    select(label, link, label2, interval2, depth_mbsf2, depth_rmcd2, diff2, row) |>
    separate(label2, into = c("sitehole", "coretype", "Sec"),
               sep = "-", remove = FALSE) |>
    separate(sitehole, into = c("Site", "H"), sep = -1) |>
    separate(coretype, into = c("Core", "T"), sep = -1) |>
    # we do not rename the interval, may not be the same as in the data!
    mutate(Sec = ifelse(Sec == "7", "7", Sec),
           Sec = ifelse(Sec == "cc", "7", Sec))
#+end_src

***** plots to try to understand the splice table
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 17:15]
:END:
#+begin_src R
  rmcd |>
    ggplot(aes(x = depth_mbsf, y = depth_rmcd, colour = H)) +
    geom_point(alpha = .5) +
    geom_segment(aes(xend = depth_mbsf, yend = depth_rmcd2),
                 arrow = arrow(angle = 20, length = unit(2, "mm"), type = "closed")) +
    geom_line(aes(y = depth_rmcd), linetype = "dashed") +
    ## geom_line(aes(x = depth_mbsf2, y = depth_rmcd2))
    geom_line(aes(y = depth_rmcd2))
    ## geom_line(linetype = "dashed") #+
    ## geom_line(aes(x = depth_mbsf2))

  rmcd |>
    ggplot(aes(x = depth_rmcd, y = row)) +
    geom_point(alpha = .2) +
    geom_point(aes(x = depth_rmcd2), color = "red", alpha = .2) +
    geom_segment(aes(xend = depth_rmcd2, yend = row),
                 arrow = arrow(angle = 20, length = unit(2, "mm"), type = "closed"))

  # i'm confused by how to work with this splice table
  rmcd |>
    ggplot(aes(x = 1, y = depth_rmcd, colour = H)) +
    geom_point() +
    geom_point(aes(x = 2, y = depth_rmcd2)) +
    geom_segment(aes(xend = 2, yend = depth_rmcd2), colour = "black") +
    ## facet_grid(cols = vars(hole)) +
    scale_y_reverse() +
    coord_cartesian(xlim = c(-4, 6))
#+end_src

#+RESULTS:
: Warning messages:
: 1: Removed 1 rows containing missing values (`geom_segment()`).
: 2: Removed 1 row containing missing values (`geom_line()`).
: + Warning messages:
: 1: Removed 1 rows containing missing values (`geom_point()`).
: 2: Removed 1 rows containing missing values (`geom_segment()`).
: + Warning messages:
: 1: Removed 1 rows containing missing values (`geom_point()`).
: 2: Removed 1 rows containing missing values (`geom_segment()`).

understand the splice table
#+begin_src R
  ODP208_1267_MS_A |>
    mutate(Sec = as.character(Sec)) |>
    ggplot(aes(x = `Depth (mbsf)`,
               y = `Corrected Suscept.`,
               colour = H, group = H,
               Site = Site, Core = Core, T = T, Sec = Sec)) +
    geom_line() +
    geom_line(aes(y = `Corrected Suscept.` + 100), data = ODP208_1267_MS_B) +
    # this shows how the holes line up from XRF data and MS data
    geom_segment(aes(x = depth_mbsf, xend = depth_mbsf2, y = -200, yend = -10,
                     lab2 = label2),
                 data = rmcd |> filter(H == "A")) +
    geom_segment(aes(x = depth_mbsf, xend = depth_mbsf2, y = -10, yend = -200,
                     lab2 = label2),
                 data = rmcd |> filter(H == "B")) #+
    # this shows the stretching they applied after
    ## geom_segment(aes(xend = depth_rmcd2, y = 0, yend = 500), data = rmcd)
#+end_src

**** apply the splice table to the magsus data
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 10:43]
:END:
#+begin_src R
  # add Magsus from hole A and B to the same dataframe
  MS <- ODP208_1267_MS_A |>
    mutate(Sec = as.character(Sec)) |>
    bind_rows(ODP208_1267_MS_B) |>
    # add the rcmd splice table
    tidylog::left_join(rmcd |>
                       # make the types teh same
                       mutate(across(c(Site, Core), parse_double)) |>
                       # do NOT match by section, only by core!
                       rename(section = Sec) |>
                       select(top = label, to = label2,
                              Site, H, Core, T, section, interval, depth_mbsf, depth_rmcd, diff, row)) |>
    # add the right-hand side of the splice table
    tidylog::left_join(rmcd2 |>
                       mutate(across(c(Site, Core), parse_double)) |>
                       rename(section2 = Sec) |>
                       select(from = label, bot = label2,
                              Site, H, Core, T, section2, interval2, depth_mbsf2, depth_rmcd2, diff2, row2 = row)) |>
    # I tried the full_joins for both, which adds
    #> 1267A-26H-7	1267B-27X-4	7	10	244.7	275.3	30.6	46
    # and
    #> 1267B-36X-C							61
    # the ties represent jumps to another depth, anything above the jump should be included
    ## mutate(seclsec = Sec < section,
    ##        secesec = Sec == section,
    ##        secgsec = Sec > section,
    ##        topleint = `Top (cm)` <= interval,
    ##        my_rmcd =
    mutate(my_rmcd = case_when(
    (Sec <= section) | ((Sec == section) & (`Top (cm)` <= interval)) ~ `Depth (mbsf)` + diff,
    (Sec >= section2) | ((Sec == section2) & (`Top (cm)` >= interval2)) ~ `Depth (mbsf)` + diff2,
    TRUE ~ NA_real_)) |>
    mutate(on_splice = (Sec < section | ((Sec == section) & (`Top (cm)` <= interval))) &
           (Sec > section2 | ((Sec == section2) & `Top (cm)` >= interval2))) |>
    mutate(on_splice = ifelse(is.na(on_splice), FALSE, on_splice)) |>
    ## print(width = Inf)
    readr::write_csv("out/ODP208_1267_MS.csv")
#+end_src

**** COMMENT apply splice table using linear interpolation/extrapolation
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 13:01]
:END:
The rmcd splice table goes down to 311 mbsf for hole A, the MS data goes down to 312 mbsf.
Trying it with approx/approxExtrap.
This is wrong, they shouldn't be stretched!

#+begin_src R
  ## MS <- ODP208_1267_MS_A |>
  ##   mutate(Sec = as.character(Sec)) |>
  ##   mutate(depth_rmcd = Hmisc::approxExtrap(x = rmcd[rmcd$H == "A", ]$`Depth (mbsf)`,
  ##                              y = rmcd[rmcd$H == "A", ]$depth_rmcd,
  ##                              xout = `Depth (mbsf)`)$y) |>
  ##   ## tail() |>
  ##   ## print(width = Inf)
  ##   bind_rows(
  ##     # the rmcd splice table goes down to 329 mbsf for hole B, the MS data goes down to 329 mbsf
  ##     ODP208_1267_MS_B |>
  ##     mutate(Sec = as.character(Sec)) |>
  ##     mutate(depth_rmcd = Hmisc::approxExtrap(x = rmcd[rmcd$H == "B", ]$`Depth (mbsf)`,
  ##                                             y = rmcd[rmcd$H == "B", ]$depth_rmcd,
  ##                                             xout = `Depth (mbsf)`)$y)
  ##   )
#+end_src

**** plot the splice MS record vs rmcd
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 13:02]
:END:
#+begin_src R :results output graphics file :file imgs/ODP208_1267_MS_rcmd.png :width 900
  MS |>
    # I'd like to NOT plot the lines between the core gaps, so I group by Core
    ggplot(aes(x = my_rmcd, y = `Corrected Suscept.`, colour = H, group = paste(H, Core, T, Sec),
               Sec = Sec)) +
    geom_line(aes(alpha = on_splice)) +
    coord_cartesian(xlim = c(320.25, NA), ylim = c(0, 300)) +
    scale_alpha_manual(values = c(0.5, 1))

  ## MS |>
  ##   ggplot(aes(x = `Depth (mbsf)`, y = `Corrected Suscept.`, colour = H, group = paste(H, Core, T))) +
  ##   geom_line(aes(alpha = on_splice))
#+end_src

#+RESULTS:
[[file:imgs/ODP208_1267_MS_rcmd.png]]

I think that did it!

**** [#B] get_rmcd function
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:58]
:END:
#+begin_src R
  get_rmcd <- function(data, rmcd = "dat/ODP208_1267_rmcd.csv") {
    rmcd <- readr::read_csv(rmcd) |>
      separate(label, into = c("sitehole", "coretype", "Sec"),
                 sep = "-", remove = FALSE) |>
      separate(sitehole, into = c("Site", "H"), sep = -1) |>
      separate(coretype, into = c("Core", "T"), sep = -1) |>
      # we do not rename the interval, may not be the same as in the data!
      # rename the CC sections into 7, the naming convention in the MS data
      mutate(Sec = ifelse(Sec == "7", "7", Sec),
             Sec = ifelse(Sec == "cc", "C", Sec)) |>
      mutate(diff = depth_rmcd - depth_mbsf, .after = depth_rmcd) |>
      mutate(diff2 = depth_rmcd2 - depth_mbsf2, .after = depth_rmcd2) |>
      mutate(row = 1:n())

    # the right side of the splice table only
    rmcd2 <- rmcd |>
      select(label, link, label2, interval2, depth_mbsf2, depth_rmcd2, diff2, row) |>
      separate(label2, into = c("sitehole", "coretype", "Sec"),
                 sep = "-", remove = FALSE) |>
      separate(sitehole, into = c("Site", "H"), sep = -1) |>
      separate(coretype, into = c("Core", "T"), sep = -1) |>
      # we do not rename the interval, may not be the same as in the data!
      mutate(Sec = ifelse(Sec == "7", "7", Sec),
             Sec = ifelse(Sec == "cc", "C", Sec))

    out <- data |>
      tidylog::left_join(rmcd |>
                       # make the types the same
                       mutate(across(c(Site, Core), parse_double)) |>
                       # do NOT match by section, only by core!
                       rename(section = Sec) |>
                       select(top = label, to = label2,
                              Site, H, Core, T, section, interval, depth_mbsf, depth_rmcd, diff, row)) |>
      # add the right-hand side of the splice table
      tidylog::left_join(rmcd2 |>
                         mutate(across(c(Site, Core), parse_double)) |>
                         rename(section2 = Sec) |>
                         select(from = label, bot = label2,
                                Site, H, Core, T, section2, interval2, depth_mbsf2, depth_rmcd2, diff2, row2 = row)) |>
    mutate(my_rmcd = case_when(
    (Sec <= section) | ((Sec == section) & (`Top (cm)` <= interval)) ~ `Depth (mbsf)` + diff,
    (Sec >= section2) | ((Sec == section2) & (`Top (cm)` >= interval2)) ~ `Depth (mbsf)` + diff2,
    TRUE ~ NA_real_)) |>
    mutate(on_splice = (Sec < section | ((Sec == section) & (`Top (cm)` <= interval))) &
           (Sec > section2 | ((Sec == section2) & `Top (cm)` >= interval2))) |>
      mutate(on_splice = ifelse(is.na(on_splice), FALSE, on_splice))

    return(out)
  }
#+end_src

#+RESULTS:

**** SOME currently some issue with A26/B27 but I'm not interested in that interval anyway
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 17:32]
:END:
:LOGBOOK:
- State "SOME"       from "NEXT"       [2023-09-20 Wed 17:32]
:END:

**** NEXT double-check with the excel file
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 09:22]
:END:
**** NEXT fix issue with overlapping depth in A31-4 and B32-5
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 17:32]
:END:
*** analyze MS data in depth domain (rmcd)
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 16:42]
:END:

**** create a shiny interface
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 08:42]
:END:
:LOGBOOK:
CLOCK: [2023-09-22 Fri 08:42]--[2023-09-22 Fri 09:30] =>  0:48
:END:
this is to inspect how the moving average affects the outcome
#+begin_src R
  library(shiny)
  library(bslib)
  library(plotly)

  cleandat <- MS |>
    tidylog::filter(
               !is.na(my_rmcd),
               ## my_rmcd > 319.46,
               my_rmcd > 320.25, # K/Pg boundary
               on_splice) |>
    mutate(var = scale(`Corrected Suscept.`)[, 1]) |>
    select(my_rmcd, var)

  rawmtm <- cleandat |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::mtm(detrend = TRUE, demean = TRUE, xmax = 5,
                    output = 1,
                    verbose = FALSE,
                    genplot = FALSE) |>
    as_tibble()

  rawfreq <- cleandat |>
    astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
    astrochron::mtm(detrend = TRUE, demean = TRUE, xmax = 5,
                    output = 3,
                    verbose = FALSE,
                    genplot = FALSE) |>
    as_tibble()


  ui <- page_sidebar(
    theme = bs_theme(bootswatch = "minty"),
    sidebar = sidebar(
      sliderInput(inputId = "width",
                  label = "Width of the moving average",
                  min = 1,
                  max = 200,
                  value = 200)
    ),
    plotOutput("raw"),
    plotOutput("mtm"),
    plotOutput("wavelet")
  )

  server <- function(input, output, session) {
    filt <- reactive(MS |>
      tidylog::filter(
                 !is.na(my_rmcd),
                 my_rmcd > 320.25, # K/Pg
                 on_splice) |>
      mutate(var = scale(`Corrected Suscept.`)[, 1]) |> # or `L*`
      mutate(scl_ma = scale(var - slider::slide_mean(var,
                                                     before = input$width,
                                                     after = input$width))[, 1]))
    freqs <- reactive(filt() |>
                      select(my_rmcd, scl_ma) |>
                      astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                      astrochron::mtm(detrend = TRUE, demean = TRUE, xmax = 5,
                                      output = 3,
                                      verbose = FALSE,
                                      genplot = FALSE) |>
                      as_tibble())

    output$raw <- renderPlot({
      ## pl_raw <-
        filt() |>
        ggplot(aes(x = my_rmcd, y = var)) +
        geom_line(aes(colour = "scale(MS)")) +
        geom_line(aes(y = scl_ma, colour = glue::glue("moving average")))
      ## plotly::toWebGL(plotly::ggplotly(p = pl_raw, dynamicTicks = TRUE))
    })

    output$mtm <- renderPlot({
      ## plmtm <-
        filt() |>
        select(my_rmcd,
           ## var
           scl_ma
           ## scl_gam
           ## scl_loess
           ) |>
        astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
        astrochron::mtm(detrend = TRUE, demean = TRUE, xmax = 5, verbose = FALSE, output = 1,
                        genplot = FALSE) |>
        ggplot(aes(x = Frequency, y = Power)) +
        geom_segment(aes(xend = Frequency, y = 0, yend = Harmonic_CL),
                     colour = "lightgray",
                     data = rawfreq) +
        geom_line(data = rawmtm, colour = "darkgray") +
        geom_segment(aes(xend = Frequency, y = 0, yend = Harmonic_CL),
                     colour = "darkgray", linetype = "dotted",
                     data = freqs()) +
        geom_line() +
        scale_y_log10() +
        ## scale_x_continuous(
        ##   sec.axis = sec_axis(trans = ~ 1 / .x,
        ##                       name = "Period",
        ##                       breaks = c(.01, .5, .1, 1, 10))) +
        geom_line(aes(y = AR1_fit), colour = "red") +
        geom_line(aes(y = AR1_90_power), colour = "red") +
        geom_line(aes(y = AR1_95_power), colour = "red") +
        geom_line(aes(y = AR1_99_power), colour = "red") +
        coord_cartesian(xlim = c(0, 10))
        ## coord_cartesian(xlim = c(0.050, 1 / 10))
      ## plotly::toWebGL(plotly::ggplotly(p = plmtm, dynamicTicks = TRUE))
    })

    output$wavelet <- renderPlot({
      filt() |>
        select(my_rmcd, scl_ma) |>
        WaverideR::analyze_wavelet(lowerPeriod = .3,
                                   upperPeriod = 20,
                                   omega_nr = 8) |>
        WaverideR::plot_wavelet(palette_name = "inferno",
                                siglvl = .95,
                                dev_new = FALSE,
                                add_data = FALSE,
                                add_MTM = FALSE, # NOT WORKING!
                                add_MTM_peaks = FALSE,
                                )
    })
  }

  shinyApp(ui, server)
#+end_src
**** filter out desired depth interval and get rid of long-term trends
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 16:44]
:END:
#+begin_src R :results graphics file :file imgs/ODP208_1267_MS_detrend.png :width 900
  MS_ <- MS |>
    tidylog::filter(
               !is.na(my_rmcd),
               my_rmcd > 320.25, # K/Pg
               on_splice) |>
    mutate(var = scale(`Corrected Suscept.`)[, 1],
           ma = slider::slide_mean(var, before = 200, after = 200),
           scl_ma = scale(var - ma)[, 1])

  fit_loess_MS <- loess(var ~ my_rmcd, data = MS_, span = .75)
  fit_gam_MS <- mgcv::gam(var ~ s(my_rmcd, bs = "cs"),
                          method = "REML",
                          data = MS_)

  MS_ <- MS_ |>
    mutate(
      gam = predict(fit_gam_MS) |> as.vector(),
      loess = predict(fit_loess_MS),
      scl_gam = scale(var - gam)[, 1],
      scl_loess = scale(var - loess)[, 1])

  MS_ |>
    ggplot(aes(x = my_rmcd, y = var)) +
    geom_line(aes(group = paste(Core, H, Sec))) +
    geom_line(aes(y = ma, colour = "moving average ± 200")) +
    ## geom_line(aes(y = scl_ma, colour = "moving average ± 200")) +
    ## geom_line(aes(y = scl_gam, colour = "generalized additive model (GAM)"))
    geom_line(aes(y = gam, colour = "generalized additive model (GAM)")) +
    ## geom_line(aes(y = scl_loess, colour = "LOESS"))
    geom_line(aes(y = loess, colour = "LOESS"))
#+end_src

#+RESULTS:
[[file:imgs/ODP208_1267_MS_detrend.png]]

**** [#B] redo analysis from [cite:@Husson2011] but now with rmcd
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 13:05]
:END:
#+begin_src R :results output graphics file :file imgs/208-1267B_MS_Husson-fig4_rmcd.png :width 900 :height 500
  f100 <- MS_ |>
    select(my_rmcd, var) |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::taner(flow = 0, fhigh = 0.9, xmax = 3) |>
    as_tibble()


  f405 <- MS_ |>
    select(my_rmcd, var) |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::taner(flow = 0, fhigh = 0.25, xmax = 1) |>
    as_tibble()

  MS_ |>
    ggplot(aes(x = my_rmcd, y = var)) +
    annotate("rect", xmin = 320.275 - 1, xmax = 320.275, ymin = -Inf, ymax = Inf,
             fill = "yellow", alpha = .6) + # the K/Pg boundary
    ## geom_line(colour = "gray", data = MS_ |> select(my_rmcd, var) |> astrochron::linterp(genplot = FALSE)) +
    geom_line(aes(group = paste(H, Core, Sec), depth_mbsf = `Depth (mbsf)`), colour = "darkblue") +
    geom_line(aes(y = var + 2), data = f100, colour = "skyblue") +
    geom_line(aes(y = var + 4), data = f405, colour = "black") +
    ## coord_cartesian(xlim = c(287.4, 330), ylim = c(0, 300)) +
    labs(x = "Depth (rmcd)", y = MS ~ "(10"^{-8} ~ "kgm"^{-3} * ")",
         title = "ODP Leg 208 Site 1267")
#+end_src

#+RESULTS:
[[file:imgs/208-1267B_MS_Husson-fig4_rmcd.png]]

**** do spectral analysis
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 16:52]
:END:
#+begin_src R :results graphics file :file imgs/ODP208_1267_MS_mtm.png :width 800
  MS_ |>
    select(my_rmcd,
           var
           ## scl_ma
           ## scl_gam
           ## scl_loess
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::mtm(detrend = TRUE, demean = TRUE, xmax = 5)
#+end_src

#+RESULTS:
[[file:imgs/ODP208_1267_MS_mtm.png]]

**** do wavelet analysis
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 16:45]
:END:
#+begin_src R :results graphics file :file imgs/ODP208_1267_MS_wavelet.png :width 800
  MS |>
    select(my_rmcd,
           var
           ## scl_ma
           ## scl_gam
           ## scl_loess
           ) |>
    filter(my_rmcd <= 355.350) |> # there's a coregap after this
    ## filter(my_rmcd >= 356.950) |> # there's a coregap before this
    WaverideR::analyze_wavelet(lowerPeriod = .3,
                               upperPeriod = 20,
                               omega_nr = 8,
                               ## verbose = TRUE
                               ) |>
    WaverideR::plot_wavelet(palette_name = "inferno",
                            siglvl = .95,
                            dev_new = FALSE,
                            ## add_avg = TRUE,
                            add_MTM = TRUE, # NOT WORKING!
                            add_MTM_peaks = TRUE,
                            ## add_abline_h = c(11)
                            )
#+end_src

#+RESULTS:
[[file:imgs/ODP208_1267_MS_wavelet.png]]

*** agemodels
**** shipboard agemodel [cite:@Zachos2004]
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 09:46]
:END:
http://www-odp.tamu.edu/publications/208_IR/chap_08/c8_f28.htm#554657
from 1 Ma to 66 Ma
#+begin_src R
  agem_sb <- readr::read_tsv("http://www-odp.tamu.edu/publications/208_IR/VOLUME/TABLES/IR208_08/08_T14.TXT",
                             comment = "#", skip = 4)
#+end_src

**** agemodel from Neptune database [cite:@Renaudie2020] (only hole B)
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 09:43]
:END:
#+begin_src R
  agem3 <- readr::read_tsv("dat/Renaudie2020/agem.csv")

  agem3 |>
    ggplot(aes(x = `Depth (mbsf)`, y = `Age (Ma)`)) +
    geom_line() +
    geom_line(aes(x = `Depth (mcd)`), data = agem_sb, colour = "red")
#+end_src

#+RESULTS:
: indexing agem.csv [=================================================================] 59.00MB/s, eta:  0s                                                                                                                                            Rows: 22 Columns: 4
: ── Column specification ─────────────────────────────────────────────────────────────────────────────────
: Delimiter: "\t"
: chr (2): Hole, Comment
: dbl (2): Age (Ma), Depth (mbsf)
:
: ℹ Use `spec()` to retrieve the full column specification for this data.
: ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
: Error: object 'agem_sb' not found

**** agemodels from [cite:@Westerhold2008]
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 11:22]
:END:
site 1267 range or rmcd = 311.39 m to 336.1 m

#+begin_src R :results output graphics file :file imgs/agem_Westerhold2008.png :width 900 :height 500
  # add age model. This links raw mcd and armcd scale to 100 kyr maxima
  ## agem <- pangaear::pg_data("10.1594/PANGAEA.666282")
  # but it's a PDF :S
  # used tabula --pages=all to convert to text
  # then manually converted it to CSV

  agem <- readr::read_csv("dat/Westerhold2008/agemodel_clean.csv",
                          comment = "#",
                          na = c("", "end of splice", "condensed"))
  # see if I got the formatting of the CSV correct
  ## agem |>
  ##   print(n = Inf, width = Inf)

  agem |>
    pivot_longer(c(site1262_mcd:site1001_rmcd, Zumaia_depth),
                 names_to = "site", values_to = "depth") |>
    pivot_longer(c(age_La2004_1, age_La2004_2), names_to = "option", values_to = "age") |>
    ggplot(aes(x = depth, y = age, colour = site,
               linetype = option, shape = option)) +
    geom_point() +
    geom_line()
#+end_src

#+RESULTS:
[[file:imgs/agem_Westerhold2008.png]]
**** [#B] agemodel from [cite:@Batenburg2018a]
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 09:14]
:END:
depth rmcd from 232 m to 366 m
age from 56 Ma to 69.1 Ma

#+begin_src R
  agem2 <- readr::read_csv("dat/Batenburg2018/site_1267_agemodel.csv") #|>
  ## summarize(d = range(depth_rmcd), a = range(age_ma))
#+end_src

#+RESULTS:
**** plot agem
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:25]
:END:
#+begin_src R :results output graphics file :file imgs/208-1267B_agem.png :width 900 :height 500
  agem |>
    ggplot() +
    geom_line(aes(x = `Depth (mcd)`, y = `Age (Ma)`,
                  colour = "Shipboard Scientific Party 2004"), data = agem_sb) +
    geom_line(aes(x = `Depth (mbsf)`, y = `Age (Ma)`,
                  colour = "Renaudi 2020 Neptune db (mbsf!)"), data = agem3) +
    geom_line(aes(x = site1267_rmcd, y = age_La2004_1 / 1000,
                  colour = "Westerhold et al., 2008 option 1")) +
    geom_line(aes(x = site1267_rmcd, y = age_La2004_2 / 1000,
                  colour = "Westerhold et al., 2008 option 2")) +
    geom_line(aes(x = depth_rmcd, y = age_ma,
                  colour = "Batenburg et al., 2018"), data = agem2) +
    annotate("rect", xmin = -Inf, xmax = Inf, ymin = 66, ymax = 80, fill = "yellow", alpha = .3)
#+end_src

#+RESULTS:
[[file:imgs/208-1267B_agem.png]]
*** plot the age model on top of the depth MS data
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 09:32]
:END:
#+begin_src R
  MS |>
    ggplot(aes(x = my_rmcd, y = `Corrected Suscept.`, colour = H, group = paste(H, Core, T, Sec),
               Sec = Sec)) +
    geom_line(aes(alpha = on_splice)) +
    geom_point(aes(x = depth_rmcd, y = 0, age = age_ma, strat_event = strat_event),
               inherit.aes = FALSE, data = agem2)
#+end_src

#+RESULTS:
: Warning messages:
: 1: In geom_point(aes(x = depth_rmcd, y = 0, age = age_ma, strat_event = strat_event),  :
:   Ignoring unknown aesthetics: age and strat_event
: 2: Using alpha for a discrete variable is not advised.
: 3: Removed 2230 rows containing missing values (`geom_line()`).

*** apply the agemodel to the MS data
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 15:49]
:END:
#+begin_src R
  MS |>
    mutate(age = approx(agem2$depth_rmcd, agem2$age_ma,
                        xout = my_rmcd)$y) |>
    ggplot(aes(x = age, y = `Corrected Suscept.`,
               ## alpha = on_splice,
               Sec = Sec)) +
    geom_line(aes(colour = H, group = paste(H, Core))) #+
    ## geom_smooth(aes(group = "all"))
#+end_src

#+RESULTS:

*** analyze MS data in the time domain
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 10:00]
:END:
#+begin_src R
  MS_ |>
    mutate(age = approx(agem2$depth_rmcd, agem2$age_ma,
                        xout = my_rmcd)$y) |>
    ## filter(my_rmcd <= 355.350) |> # there's a coregap after this
    ## filter(my_rmcd >= 356.950) |> # there's a coregap before this
    select(age,
           ## var
           scl_gam
           ) |>
    WaverideR::analyze_wavelet(lowerPeriod = .01,
                               upperPeriod = 1.5,
                               omega_nr = 8,
                               ## verbose = TRUE
                               ) |>
    WaverideR::plot_wavelet(palette_name = "inferno",
                            siglvl = .95,
                            dev_new = FALSE,
                            ## add_avg = TRUE,
                            add_MTM = TRUE, # NOT WORKING!
                            add_MTM_peaks = TRUE,
                            add_abline_h = c(0.405, 0.125, 0.027)
                            )
#+end_src

#+RESULTS:
: Warning message:
: In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
:   collapsing to unique 'x' values

**** filter MS in time
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 10:19]
:END:
#+begin_src R
  MS_f405 <- MS |>
      mutate(age = approx(agem2$depth_rmcd, agem2$age_ma,
                          xout = my_rmcd)$y) |>
      filter(my_rmcd <= 355.350) |> # there's a coregap after this
      ## filter(my_rmcd >= 356.950) |> # there's a coregap before this
      select(age,
             ## var
             scl_gam
             ) |>
    astrochron::linterp(verbose = F, genplot = F) |>
    astrochron::bandpass(flow = 1 / .405 - .15 * 1 / .405,
                         fhigh = 1 / .405 + .15 * 1 / .405,
                         xmax = 15,
                         padfac = 5, win = 1, detrend = T, addmean = F) |>
    as_tibble()

  MS_f100 <- MS |>
      mutate(age = approx(agem2$depth_rmcd, agem2$age_ma,
                          xout = my_rmcd)$y) |>
      filter(my_rmcd <= 355.350) |> # there's a coregap after this
      ## filter(my_rmcd >= 356.950) |> # there's a coregap before this
      select(age,
             ## var
             scl_gam
             ) |>
    astrochron::linterp(verbose = F, genplot = F) |>
    astrochron::bandpass(flow = 1 / .125 - .15 * 1 / .125,
                         fhigh = 1 / .125 + .15 * 1 / .125,
                         xmax = 15,
                         padfac = 5, win = 1, detrend = T, addmean = F) |>
    as_tibble()

  MS |>
    mutate(age = approx(agem2$depth_rmcd, agem2$age_ma,
                        xout = my_rmcd)$y) |>
    filter(my_rmcd <= 355.350) |> # there's a coregap after this
    ggplot(aes(x = age, y = scl_gam)) +
    geom_line() +
    geom_line(data = MS_f100) +
    geom_line(data = MS_f405)

  MS_f100 |>
    rename(f100 = scl_gam) |>
    full_join(MS_f405 |> rename(f405 = scl_gam)) |>
    mutate(fake_ecc = scale(f100 + f405)[, 1]) |>
    ggplot(aes(x = age, y = fake_ecc)) +
    geom_line(colour = "red") +
    geom_line(aes(x = age, y = ecc),
              data = snvecR::get_ZB18a() |>
                mutate(age = age / 1e3) |>
                filter(age > 66 & age < 68.5) |>
                mutate(ecc = scale(ee)[, 1]))
#+end_src
*** colour reflectance data from Janus database?
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 11:23]
:END:
I've added this myself, may be nicer than just MS?
https://web.iodp.tamu.edu/janusweb/physprops/colordat.cgi?leg=208&site=1267
they did this analysis also in [cite:@Westerhold2007] and extended it in [cite:@Batenburg2018a] (56.042 Ma to 69.070 Ma)
**** read in the data and calculate normalized a*/b*
#+begin_src R
  ODP208_1267_color_A <- readr::read_tsv("dat/ODP208_1267_color-reflectance.dat")
  ODP208_1267_color_B <- readr::read_tsv("dat/ODP208_1267_color-reflectance_B.dat")

  # dat is only hole B for now
  dat <- ODP208_1267_color_B |>
    select(depth = `Depth (mbsf)`,
           Lstar = `L*`,
           astar = `a*`,
           bstar = `b*`) |>
    filter(depth >= 285.9) |>
    mutate(aob = scale(astar / bstar)[, 1]) |>
    select(depth, aob, everything())

  # raw data with simple loess curve
  dat |>
    ggplot(aes(x = depth, y = Lstar)) +
    geom_line() +
    geom_line(aes(x = `Depth (mbsf)`, y = `L*`), data = ODP208_1267_color_A, alpha = .2) +
    geom_smooth(method = "loess", span = .2) +
    geom_smooth(method = "gam", color = "orange")
#+end_src

#+RESULTS:
#+begin_example
indexed 0B in  0s, 0B/sindexed 1.00TB in  0s, 38.17TB/s                                                                                                       Rows: 25316 Columns: 15
── Column specification ─────────────────────────────────────────────────────────────────────────────────
Delimiter: "\t"
chr  (4): H, T, Sec, Munsell_HVC
dbl (11): Leg, Site, Core, Top (cm), Depth (mbsf), L*, a*, b*, X, Y, Z

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
indexing ODP208_1267_color-reflectance_B.dat [=====================================] 143.06GB/s, eta:  0s                                                                                                                                            Rows: 13263 Columns: 15
── Column specification ─────────────────────────────────────────────────────────────────────────────────
Delimiter: "\t"
chr  (4): H, T, Sec, Munsell_HVC
dbl (11): Leg, Site, Core, Top (cm), Depth (mbsf), L*, a*, b*, X, Y, Z

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
`geom_smooth()` using formula = 'y ~ x'
`geom_smooth()` using formula = 'y ~ s(x, bs = "cs")'
#+end_example
**** do analysis of hole B in the depth domain
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 12:42]
:END:
***** use taner filters
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 12:16]
:END:
#+begin_src R
  f100 <- dat |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::taner(flow = .07, fhigh = 0.9, xmax = 3) |>
    as_tibble()

  f405 <- dat |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::taner(flow = .07, fhigh = 0.25, xmax = 1) |>
    as_tibble()

  ## f100_2 <- dat |>
  ##   astrochron::linterp(genplot = FALSE) |>
  ##   astrochron::bandpass(flow = .1, fhigh = .5, win = 1, xmax = 5)
#+end_src

#+RESULTS:
#+begin_example
----- TANER BANDPASS FILTERING STRATIGRAPHIC SERIES-----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 0.025
 ,* New number of samples= 1733
 ,* Number of data points= 1733
 ,* Sample interval= 0.025
 ,* Mean value removed= 11.30448
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
#+end_example

***** COMMENT do spectral analysis
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 12:14]
:END:
#+begin_src R :results output graphics file :file imgs/208-1267B_color_mtm.png :width 900 :height 500
  mtm <- dat |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::mtm(xmax = 6, pl = 1, output = 1) |>
    as_tibble()

  # plot the mtm
  mtm |>
    ggplot(aes(x = Frequency, y = Power)) +
    geom_line() +
    scale_y_log10() +
    scale_x_continuous(
      sec.axis = sec_axis(trans = ~ 1 / .x,
                          name = "Period",
                          breaks = c(.01, .5, .1, 1, 10))) +
    geom_line(aes(y = AR1_fit), colour = "red") +
    geom_line(aes(y = AR1_90_power), colour = "red") +
    geom_line(aes(y = AR1_95_power), colour = "red") +
    geom_line(aes(y = AR1_99_power), colour = "red") +
    # highlight what filters are being used by Husson 2011
    annotate("rect", xmin = 0., xmax = .25, ymin = 1e-5, ymax = 1e-1, alpha = .3, fill = "red") +
    annotate("rect", xmin = 0., xmax = .9, ymin = 1e-5, ymax = 1e-1, alpha = .3, fill = "red") +
    coord_cartesian(xlim = c(0, 10))
#+end_src

#+RESULTS:
[[file:imgs/208-1267B_color_mtm.png]]

***** plot the filters and the record
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 12:16]
:END:
#+begin_src R :results output graphics file :file imgs/208-1267B_color.png :width 900 :height 500
  dat |>
    ggplot(aes(x = depth, y = aob)) +
    geom_line(color = "darkblue") +
    geom_line(data = f100, color = "skyblue") +
    geom_line(data = f405, color = "black") +
    # same as MS from Husson 2011 from above
    annotate("rect", xmin = 285.9, xmax = 286.5, ymin = -Inf, ymax = Inf,
             fill = "yellow", alpha = .6) + # the K/Pg boundary
    coord_cartesian(xlim = c(287.4, NA)) +
    labs(x = "Depth (mbsf)", y = "Norm. a*/b*")
#+end_src

#+RESULTS:
[[file:imgs/208-1267B_color.png]]

***** get the maxima of the 405 kyr filter
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 12:17]
:END:
#+begin_src R
  pk405 <- f405 |>
    astrochron::peak() |>
    as_tibble() |>
    mutate(
      n_cyc = 1:n(),
      age_405 = 65940 + n_cyc * 405) # ZB18a eq 2 or 66.96 for eq 3

  pk405 |>
    ggplot(aes(x = Location, y = age_405)) +
    geom_line() + geom_point()

  dat <- dat |>
    mutate(
      age = astrochron::tune(dat,
                   controlPts = pk405 |>
                     select(depth = Location, age_405),
                   extrapolate = TRUE,
                   genplot = FALSE)$X1)

  dat |>
    ggplot(aes(x = age, y = aob)) +
    geom_line()

  dat |>
    select(age, aob) |>
    mutate(aob = aob - slider::slide_mean(aob, before = 200, after = 200)) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::mtm(xmax = .06)
#+end_src

#+RESULTS:
#+begin_example
----- FINDING MAXIMA OF PEAKS, FILTERING AT THRESHOLD VALUE -----
 ,* Number of data points= 1733
 ,* Number of columns= 2
 ,* Identifying maxima of peaks
 ,* Number of peaks identified= 9

 ,* No filtering of peaks applied.
----- TUNING STRATIGRAPHIC SERIES -----
 ,* Number of data points= 1840
 ,* Number of time control points= 9
 ,* Sorting datasets into ensure increasing order, removing empty entries

,**** WARNING: duplicate depth/height datum found in dat

 ,* Mean sampling interval= 2.096929
 ,* Median sampling interval= 2.154255
 ,* Maximum sampling interval= 7.941176
 ,* Minimum sampling interval= 0

----- PERFORMING Multitaper Spectral Analysis -----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 2.154255
 ,* New number of samples= 1791
 ,* Number of data points in stratigraphic series: 1791
 ,* Stratigraphic series length (space or time): 3856.117
 ,* Sampling interval (space or time): 2.154255
 ,* Will use default setting of 5 DPSS tapers
 ,* Mean value subtracted= 0.00882429
 ,* Linear trend NOT subtracted
 ,* Nyquist frequency: 0.2320988
 ,* Rayleigh frequency: 0.0002591834
 ,* MTM Power spectrum bandwidth resolution (halfwidth): 0.0007775503
 ,* Padded to 8956 points

 ,* Searching for significant spectral peaks that satisfy 90 % CL
     requirements outlined in Meyers (2012):
 ,* Number of significant F-test peaks identified = 33
ID  / Frequency / Period / Harmonic_CL / Rednoise_CL
1   0.002798869   357.2872   90.68548   98.53344
2   0.003835487   260.7231   96.06114   96.35961
3   0.007256326   137.8108   97.68282   82.70286
4   0.02752221   36.33429   97.5   80.64475
5   0.02829967   35.3361   93.87141   79.03028
6   0.02933629   34.08747   99.54662   93.66677
7   0.0411019   24.32977   98.98623   84.84235
8   0.0531785   18.80459   95.4257   74.80281
9   0.05447427   18.35729   99.89771   95.87553
10   0.06287088   15.90561   95.22755   97.11556
11   0.06395933   15.63494   93.02414   89.89813
12   0.06696552   14.93306   91.90037   73.29973
13   0.0681058   14.68304   98.00992   82.16992
14   0.07474016   13.37969   99.96271   91.50175
15   0.07852381   12.73499   97.43281   65.44862
16   0.09231083   10.83296   95.61134   89.70635
17   0.09422857   10.61249   99.31377   99.89063
18   0.1000855   9.991461   93.88109   76.57064
19   0.1010184   9.899185   98.41569   72.34155
20   0.102677   9.739278   90.12556   94.56918
21   0.1049576   9.52766   97.28039   85.37081
22   0.1077564   9.280188   91.26549   72.50968
23   0.1085339   9.213711   97.25827   90.16475
24   0.1096224   9.122227   94.33675   77.94989
25   0.112784   8.866503   96.57953   69.30783
26   0.1211806   8.252143   96.03697   56.31232
27   0.1220099   8.196054   98.88495   84.78227
28   0.1249643   8.002286   99.84032   79.34508
29   0.1367817   7.310917   91.50361   88.80223
30   0.1441936   6.935122   90.96567   94.40426
31   0.1635265   6.115217   95.39002   85.09184
32   0.167051   5.986196   95.01506   91.9216
33   0.1933293   5.172523   94.30443   84.0192
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
#+end_example

***** remove long-term trends in the depth domain
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:39]
:END:
#+begin_src R
  fit_loess <- loess(aob ~ depth, data = dat, span = .75)
  fit_gam <- mgcv::gam(aob ~ s(depth, bs = "cs"), data = dat)

  lp <- dat |>
    select(depth, aob## Lstar_scl
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::lowpass(fcut = 1 / 15) # how do you decide which frequency to cull?
  # this is linearly interpolated so it can't go into the other df

  # let's see how sensitive it is to the span or to size of the rolling mean
  dat <- dat |>
    mutate(
      # there are several methods of calculating a rolling average
      ## ma = roll::roll_mean() # that's left-aligned
      ## ma = zoo::rollmean(Lstar, k = 33, align = "center", na.pad = TRUE),
      # I prefer the slider implementation, it's FAAAST
      # I've played around with the size of the window. If I make it larger,
      # more low-frequency peaks are preserved.
      ma = slider::slide_mean(aob, before = 200, after = 200),
      loess = predict(fit_loess),
      gam = predict(fit_gam),
      scl = scale(Lstar)[, 1],
      loess_scl = scale(aob - loess)[, 1],
      gam_scl = scale(aob - loess)[, 1],
      ma_scl = scale(aob - ma)[, 1])

  dat |>
    ggplot(aes(x = depth, y = aob)) +
    geom_line(alpha = .3) +
    geom_line(aes(y = loess), colour = "orange") +
    geom_line(aes(y = gam), colour = "red") +
    geom_line(aes(y = ma), colour = "indianred")

  dat |>
    ggplot(aes(x = depth, y = aob)) +
    geom_line() +
    geom_line(aes(y = loess_scl + 3), colour = "orange") +
    geom_line(aes(y = gam_scl + 6), colour = "red") +
    geom_line(aes(y = ma_scl + 9), colour = "indianred")
#+end_src

#+RESULTS:
#+begin_example
----- LOWPASS FILTERING STRATIGRAPHIC SERIES-----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 0.025
 ,* New number of samples= 1733
 ,* Number of data points= 1733
 ,* Sample interval= 0.025
 ,* Mean value removed= 0.01953956
 ,* 5 pos/neg frequency pairs and f(0) will be bandpassed
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
#+end_example

***** do mtm analysis  in the depth domain
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:55]
:END:
#+begin_src R
  dat |>
    drop_na() |>
    select(depth,
           ## aob
           ## Lstar,
           ## loess_scl
           ## gam_scl
           ma_scl
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::mtm(output = 1, xmax = 10) |>
    as_tibble()
#+end_src

#+RESULTS:
#+begin_example
----- PERFORMING Multitaper Spectral Analysis -----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 0.025
 ,* New number of samples= 1733
 ,* Number of data points in stratigraphic series: 1733
 ,* Stratigraphic series length (space or time): 43.3
 ,* Sampling interval (space or time): 0.025
 ,* Will use default setting of 5 DPSS tapers
 ,* Mean value subtracted= -0.007338007
 ,* Linear trend NOT subtracted
 ,* Nyquist frequency: 20
 ,* Rayleigh frequency: 0.02308136
 ,* MTM Power spectrum bandwidth resolution (halfwidth): 0.06924409
 ,* Padded to 8666 points

 ,* Searching for significant spectral peaks that satisfy 90 % CL
     requirements outlined in Meyers (2012):
 ,* Number of significant F-test peaks identified = 46
ID  / Frequency / Period / Harmonic_CL / Rednoise_CL
1   0.1477037   6.770312   97.81888   70.95153
2   0.3507962   2.850658   96.15821   99.83479
3   0.549273   1.820588   99.93298   95.71491
4   0.6600508   1.515035   91.60759   59.35608
5   2.506347   0.3989871   99.90005   97.14331
6   2.594046   0.3854982   92.58703   84.48891
7   4.264943   0.2344697   92.27711   88.87931
8   5.67736   0.1761382   96.11432   89.04281
9   6.106624   0.1637566   99.97548   64.3143
10   7.957535   0.1256671   98.05545   84.35803
11   8.156012   0.1226089   99.56947   93.36902
12   8.636049   0.1157937   93.82859   89.15123
13   9.162243   0.1091436   94.41139   94.81218
14   9.254558   0.1080549   97.05078   90.86573
15   9.780752   0.1022416   99.25119   89.55859
16   10.58389   0.09448321   97.63315   95.10522
17   11.0547   0.09045929   95.32547   71.18952
18   11.17009   0.08952479   93.37106   94.26625
19   11.23933   0.08897331   94.40806   69.16598
20   11.34549   0.08814076   97.58416   82.10638
21   11.65474   0.08580198   96.48069   92.10786
22   12.3748   0.0808094   95.1167   97.58248
23   12.6379   0.0791271   93.62709   93.73139
24   12.91946   0.07740264   93.56098   98.65819
25   13.021   0.07679901   99.36458   62.45722
26   13.99954   0.07143093   93.03784   69.10545
27   14.09647   0.07093975   99.06973   99.20623
28   14.3688   0.06959525   98.68524   64.65251
29   14.43803   0.06926151   98.14767   87.79034
30   14.62266   0.06838699   93.01484   71.31289
31   14.81652   0.06749221   93.2065   96.91767
32   14.92269   0.06701206   98.81679   88.57128
33   15.26425   0.06551255   90.33441   64.59363
34   15.31964   0.06527569   90.22784   91.29449
35   15.62428   0.06400295   97.42037   85.11671
36   16.00277   0.06248918   97.92532   68.65022
37   17.09208   0.05850662   94.69208   88.55884
38   17.56751   0.05692328   94.97037   98.45663
39   17.70598   0.0564781   95.89307   66.52896
40   17.7706   0.05627273   94.15521   82.41941
41   17.80291   0.0561706   94.19327   72.928
42   17.91369   0.05582324   99.42919   89.47333
43   18.30141   0.05464061   90.11566   73.50925
44   18.47681   0.05412191   99.35983   57.57737
45   18.5645   0.05386624   99.42766   59.69106
46   19.87076   0.0503252   99.85037   87.35517
# A tibble: 4,332 × 8
   Frequency   Power Harmonic_CL AR1_CL AR1_fit AR1_90_power AR1_95_power AR1_99_power
       <dbl>   <dbl>       <dbl>  <dbl>   <dbl>        <dbl>        <dbl>        <dbl>
 1   0.00462 0.00286        13.7   56.8 0.00283      0.00452      0.00518      0.00656
 2   0.00923 0.00276        10.4   53.9 0.00283      0.00452      0.00518      0.00656
 3   0.0138  0.00263        11.0   49.5 0.00283      0.00452      0.00518      0.00656
 4   0.0185  0.00248        25.8   44.7 0.00283      0.00452      0.00518      0.00656
 5   0.0231  0.00232        57.8   39.0 0.00283      0.00452      0.00518      0.00656
 6   0.0277  0.00214        87.9   33.0 0.00283      0.00452      0.00518      0.00656
 7   0.0323  0.00201        98.8   28.5 0.00283      0.00452      0.00518      0.00656
 8   0.0369  0.00193       100.    25.8 0.00283      0.00452      0.00518      0.00656
 9   0.0415  0.00186       100.    23.4 0.00283      0.00452      0.00518      0.00656
10   0.0462  0.00175        99.1   20.0 0.00283      0.00452      0.00518      0.00656
# ℹ 4,322 more rows
# ℹ Use `print(n = ...)` to see more rows
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
#+end_example

***** bandpass filtering in the depth domain
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:56]
:END:
#+begin_src R
  # I like gam I think?
  filt_bp_2.4 <- dat |>
    drop_na() |>
    select(depth, gam_scl) |>
    astrochron::linterp(genplot = FALSE) |>
    # this is peak no 1
    astrochron::bandpass(flow = 0.042 - .15 * .042, fhigh = 0.042 + .15 * .042, win = 1, xmax = 1) |> # gaussian window
    ## astrochron::taner(flow = 0, fhigh = .3, xmax = 1) |> # taner window
    as_tibble()

  filt_bp_405 <- dat |>
    drop_na() |>
    select(depth,
           ## gam_scl
           ma_scl
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    ## astrochron::bandpass(flow = 0, fhigh = .3, win = 0, xmax = 1) |> # uniform window
    # this is peak no 2, no 3 = 0.5 (based on gam_scl)
    ## astrochron::bandpass(flow = 0.35 - .15 * .35, fhigh = 0.35 + .15 * .35, win = 1, xmax = 1) |> # gaussian window
    # this is based on the ma_scl, peak number 1 appears: 0.1477
    astrochron::bandpass(flow = 0.148 - .15 * .148, fhigh = 0.148 + .15 * .148, win = 1, xmax = 1) |> # gaussian window
    ## astrochron::taner(flow = 0, fhigh = .3, xmax = 1) |> # taner window
    as_tibble()

  filt_bp_100 <- dat |>
    drop_na() |>
    select(depth,
           ## gam_scl
           ma_scl
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    ## astrochron::bandpass(flow = 0, fhigh = .3, win = 0, xmax = 1) |> # uniform window
    # this is peak no. 5/6
    ## astrochron::bandpass(flow = 2.51 - .15 * 2.51, fhigh = 2.51 + .15 * 2.51, win = 1, xmax = 10) |> # gaussian window
    # this is ma_scl peak no. 3
    astrochron::bandpass(flow = 0.55 - .15 * .55, fhigh = .55 + .15 * .55, win = 1, xmax = 10) |> # gaussian window
    ## astrochron::taner(flow = 0, fhigh = .3, xmax = 1) |> # taner window
    as_tibble()

  filt_bp_prec <- dat |>
    drop_na() |>
    select(depth,
           ## gam_scl
           ma_scl
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    ## astrochron::bandpass(flow = 0, fhigh = .3, win = 0, xmax = 1) |> # uniform window
    # this is peak no. 9
    ## astrochron::bandpass(flow = 7.96 - .15 * 7.69, fhigh = 7.96 + .15 * 7.96, win = 1, xmax = 10) |> # gaussian window
    # this is ma_scl peak no. 5/6
    astrochron::bandpass(flow = 2.55 - .15 * 2.55, fhigh = 2.55 + .15 * 2.55, win = 1, xmax = 10) |> # gaussian window
    ## astrochron::taner(flow = 0, fhigh = .3, xmax = 1) |> # taner window
    as_tibble()

  filt_hb <- filt_bp_prec |>
    astrochron::hilbert(genplot = TRUE, output = TRUE) |>
    ## astrochron::peak() |>
    as_tibble()
#+end_src

#+RESULTS:
#+begin_example
----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 0.025
 ,* New number of samples= 1733
 ,* Number of data points= 1733
 ,* Sample interval= 0.025
 ,* Mean value removed= -0.01994842
 ,* Center of bandpass filter = 2.5
 ,* 86 pos/neg frequency pairs will be bandpassed
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 0.025
 ,* New number of samples= 1733
 ,* Number of data points= 1733
 ,* Sample interval= 0.025
 ,* Mean value removed= -0.01994842
 ,* Center of bandpass filter = 4
 ,* 86 pos/neg frequency pairs will be bandpassed
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----

----- APPLYING PIECEWISE-LINEAR INTERPOLATION TO STRATIGRAPHIC SERIES -----

 ,* Number of samples= 1840
 ,* Determining median sampling interval for series
 ,* Will interpolate to median sampling interval of 0.025
 ,* New number of samples= 1733
 ,* Number of data points= 1733
 ,* Sample interval= 0.025
 ,* Mean value removed= -0.01994842
 ,* Center of bandpass filter = 6.7
 ,* 86 pos/neg frequency pairs will be bandpassed
Warning message:
In regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
----- PERFORMING HILBERT TRANSFORM ON STRATIGRAPHIC SERIES -----
 ,* Number of data points= 1733
 ,* Sample interval= 0.025
 ,* Mean value removed= -0.01987432
#+end_example

***** plot the filters
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:56]
:END:
#+begin_src R
  dat |>
    ggplot(aes(x = depth, y = ma_scl)) +
    geom_line(alpha = .3) +
    ## geom_line(aes(colour = "precession?"), data = filt_bp_prec) +
    geom_line(aes(colour = "100 kyr"), data = filt_bp_100) +
    geom_line(aes(colour = "405 kyr"), data = filt_bp_405) #+
    ## geom_line(aes(colour = "2.4 Myr"), data = filt_bp_2.4) #+
    ## geom_line(aes(colour = "Hilbert transform of prec", x = depth, y = envelope), data = filt_hb)
#+end_src

#+RESULTS:

***** get the peaks of the 405 kyr filter
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 13:51]
:END:
#+begin_src R
  agem_405 <- filt_bp_405 |>
    astrochron::peak() |>
    as_tibble() |>
    mutate(
      n_cyc = 1:n(),
      age_405 = 65940 + n_cyc * 405) # ZB18a eq 2 or 66.96 for eq 3


  dat |>
    mutate(age_405 = Hmisc::approxExtrap(agem_405$Location, agem_405$age_405,
                                         xout = depth)$y) |>
    ggplot(aes(x = age_405, y = aob)) +
    geom_line()
#+end_src
***** combine the filters into an eccentricity curve
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 13:15]
:END:
#+begin_src R
  filt_bp_405 |>
    rename(f405 = ma_scl) |>
    mutate(f100 = filt_bp_100$ma_scl) |>
    mutate(f405s = scale(f405)[, 1],
           f100s = scale(f100)[, 1],
           ecc = f405s + f100s, # with arbitrary scaling
           ecc2 = f405 + f100,
           ) |> # just the raw spectral output
    ggplot(aes(x = depth, y = ecc)) +
    geom_line()
#+end_src

#+RESULTS:
***** what if we look at EHA, do we see sed changes?
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 14:30]
:END:
#+begin_src R
  dat |>
    select(
      depth,
      ## aob
      ## scl
      ## gam_scl
      ## loess_scl
      ma_scl
    ) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::eha(fmax = 10, ydir = -1, pad = 1000, pl = 1)
#+end_src
**** add rmcd depth and create splice for colour data
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 11:39]
:END:
#+begin_src R
  col <- ODP208_1267_color_A |>
    mutate(Sec = as.character(Sec)) |>
    bind_rows(ODP208_1267_color_B) |>
    get_rmcd() |>
    # this CC isn't included correctly
    mutate(on_splice = if_else(H == "B" & Core == 33 & Sec == "CC", TRUE, on_splice))
#+end_src

**** plot the colour data vs rmcd
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 15:00]
:END:

#+begin_src R :results output graphics file :file imgs/ODP208_1267_colour_rmcd.png :width 900
  col |>
    ggplot(aes(x = my_rmcd,
               ## y = `L*`,
               y = `a*` / `b*`,
               colour = H, group = paste(H, Core, T, Sec),
               Sec = Sec)) +
    geom_line(aes(alpha = on_splice)) +
    coord_cartesian(xlim = c(320., NA), ylim = c(0.2, .9))
#+end_src

#+RESULTS:
[[file:imgs/ODP208_1267_colour_rmcd.png]]

**** clean up colour data
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 13:43]
:END:
#+begin_src R
  col_w <- col |>
    tidylog::filter(
               !is.na(my_rmcd),
               ## my_rmcd > 319.46,
               my_rmcd > 320.35, # the depth of the K/Pg massive shift in MS and colour
               on_splice) |>
    ## mutate(var = `a*`) |>
    ## mutate(var = `b*`) |> # or `L*`
    ## mutate(var = `a*` / `b*`) |> # or `L*`
    mutate(var = `L*`) |> # or `L*`
    mutate(scl_ma = scale(var - slider::slide_mean(var,
                                                   before = 200,
                                                   after = 200)))
#+end_src

#+RESULTS:
: filter: removed 35,321 rows (92%), 3,258 rows remaining

**** create wavelet with rmcd vs L*
#+begin_src R :results graphics file :file imgs/ODP208_1267_color_wavelet.png :width 800
  ## library(biwavelet)
  library(WaverideR)

  ## par(oma = c(0, 0, 0, 1), mar = c(5, 4, 4, 5) + .1)
  col_w |>
    select(depth = my_rmcd, scl_ma) |>
    ## astrochron::linterp(genplot = FALSE) |>
    ## biwavelet::wt(sig.level = .95) |>
    ## plot(plot.cb = TRUE,
    ##      plot.phase = FALSE,
    ##      xlab = "Depth (rmcd)",
    ##      main = "L*",
    ##      fill.cols = viridis::inferno(n = 64))
    # let's try waverider!
    WaverideR::analyze_wavelet(lowerPeriod = .3,
                               upperPeriod = 20,
                               omega_nr = 8,
                               ## verbose = TRUE
                               ) |>
    WaverideR::plot_wavelet(palette_name = "inferno",
                            siglvl = .95,
                            dev_new = FALSE,
                            ## add_avg = TRUE,
                            add_MTM = TRUE, # NOT WORKING!
                            add_MTM_peaks = TRUE)

#+end_src

#+RESULTS:
[[file:imgs/ODP208_1267_color_wavelet.png]]

**** apply agemodel to colour data
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 12:09]
:END:
#+begin_src R
  col <- col |>
    mutate(age = approx(agem2$depth_rmcd, agem2$age_ma,
                        xout = my_rmcd)$y,
           age_Neptune = if_else(H == "B",
                                 approx(agem3$`Depth (mbsf)`, agem3$`Age (Ma)`,
                                        xout = `Depth (mbsf)`)$y,
                                 NA_real_))



  col |>
    ggplot(aes(x = age, y = `L*`,
               group = paste(H, Core, Sec),
               Sec = Sec)) +
    geom_line(aes(colour = H, alpha = on_splice)) #+
    ## geom_line(aes(x = age_Neptune, y = `L*`))
#+end_src

#+RESULTS:

**** do spectral analysis of the splice in the time domain
:PROPERTIES:
:CREATED:  [2023-09-21 Thu 12:44]
:END:
interesting! There's almost no 405 kyr cyclicity in there, probably b/c it was tuned to 100 kyr cycles exactly?

#+begin_src R
  col_ <- col |>
    filter(!is.na(age),
           age > 66,
           on_splice) |>
    mutate(aob = `a*` / `b*`,
           scl = scale(aob)[, 1])

  col_N <- col |>
    filter(!is.na(age_Neptune),
           age_Neptune > 66) |>
    mutate(aob = `a*` / `b*`,
           scl = scale(aob)[, 1])

  col_ |>
    ggplot(aes(x = age, y = scl, colour = H, group = paste(H, Core, Sec))) +
    geom_line() +
    geom_smooth(aes(group = "all"))
    ## geom_line(linetype = "dashed")

  col_N |>
    ggplot(aes(x = age, y = scl, colour = H, group = paste(H, Core, Sec))) +
    geom_line() +
    geom_smooth(aes(group = "all"))

  fit_gam_col <- mgcv::gam(scl ~ s(age, bs = "cs"), data = col_)
  fit_gam_col_N <- mgcv::gam(scl ~ s(age, bs = "cs"), data = col_N)

  col_ |>
    mutate(gam = predict(fit_gam_col) |> as.vector()) |>
    mutate(scl_gam = scl - gam) |>
    mutate(scl_ma = slider::slide_mean(scl, before = 2, after = 2)) |>
    mutate(age = age * 1e3) |>
    ## ggplot(aes(x = scl_gam)) + geom_density()
    select(age,
           ## scl #> gives 2.975 Myr cycle
           ## scl_gam #> 316
           scl_ma #> 2.975 Myr + 125 kyr + 106 kyr, if I increase the size it's just 125 kyr and 106 kyr
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::mtm(xmax = 0.06)
  # I keep getting a 316 kyr cycle and a 188 and a 125 kyr
  # but maybe this was tuned to 100 kyr equidistant?

  col_N |>
    mutate(gam = predict(fit_gam_col_N) |> as.vector()) |>
    mutate(scl_gam = scl - gam) |>
    mutate(scl_ma = slider::slide_mean(scl, before = 1, after = 1)) |>
    mutate(age = age * 1e3) |>
    ## ggplot(aes(x = scl_gam)) + geom_density()
    select(age,
           ## scl #> 2.712 Myr + 27 kyr ...
           scl_gam #> 301 kyr + 188 kyr + 124 kyr + 106 kyr + 27 kyr
           ## scl_ma #> size 2: 2.712 Myr + 124 kyr + 107 kyr + 78 + 70 ... kyr
           ) |>
    astrochron::linterp(genplot = FALSE) |>
    ## astrochron::mtm(xmax = 0.06)
    astrochron::mtm(xmax = 0.06)
  # I keep getting a 300 kyr cycle and a 188 and a 124 and 106
  # even though this one was NOT tuned to 100 kyr cycle

  col_ |>
    mutate(scl_ma = slider::slide_mean(scl, before = 2, after = 2)) |>
    mutate(age = age * 1e3) |>
    ## ggplot(aes(x = scl_gam)) + geom_density()
    select(age, scl_ma) |>
    astrochron::linterp(genplot = FALSE) |>
    # this is 124 kyr
    astrochron::bandpass(flow = 0.008 - .15 * 0.008, fhigh = .008 + .15 * .008, xmax = .006)

  col_N |>
    mutate(scl_ma = slider::slide_mean(scl, before = 2, after = 2)) |>
    mutate(age = age * 1e3) |>
    ## ggplot(aes(x = scl_gam)) + geom_density()
    select(age, scl_ma) |>
    astrochron::linterp(genplot = FALSE) |>
    # this is 106 kyr
    astrochron::bandpass(flow = 0.0094 - .15 * 0.0094, fhigh = .0094 + .15 * .0094, xmax = .006)

  # try and get the 405 kyr even though it isn't really there in the mtm
  col_N |>
    mutate(scl_ma = slider::slide_mean(scl, before = 2, after = 2)) |>
    mutate(age = age * 1e3) |>
    ## ggplot(aes(x = scl_gam)) + geom_density()
    select(age, scl_ma) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::bandpass(flow = 0.0094 - .15 * 0.0094, fhigh = .0094 + .15 * .0094, xmax = .006)
#+end_src
*** Fe count from [cite:@Westerhold2008]
:PROPERTIES:
:CREATED:  [2023-09-19 Tue 21:14]
:END:
overview of all supplementary data on PANGAEA
https://doi.pangaea.de/10.1594/PANGAEA.667122

title says "astronomical calibration of the Paleocene time"
depth sed [m] from 234 m to 295 m
depth revised [m] from 265 m to 330 m
#+begin_src R :results graphics file :file imgs/ODP208_1267_Fe.png :width 800
  ODP208_1267_Fe <- pangaear::pg_data("10.1594/PANGAEA.666120")

  ## ODP208_1267_magstrat <- pangaear::pg_data("10.1594/PANGAEA.666515")

  dat <- ODP208_1267_Fe[[1]]$data |>
    tidylog::filter(`Depth revised [m]` > 319.46) |>
    mutate(var = scale(`Fe count [#]`)[, 1], #log(`Fe count [#]`),
           scl_ma = scale(var -
                          slider::slide_mean(var,
                                             before = 5, after = 5))[, 1])

  dat |>
    ggplot(aes(x = `Depth revised [m]`, y = var)) +
    geom_line() #+
    ## geom_line(aes(y = scl_ma))
#+end_src

#+RESULTS:
[[file:imgs/ODP208_1267_Fe.png]]

#+begin_src R :results graphics file :file imgs/ODP208_1267_Fe_wavelet.png :width 800
  par(oma = c(0, 0, 0, 1), mar = c(5, 4, 4, 5) + .1)
  dat |>
    select(depth = `Depth revised [m]`,
           ## scl_ma
           var
           ) |>
    ## filter(depth <= 324.59) |>
    ## filter(depth >= 324.59 & depth <= 328.96) |>
    astrochron::linterp(genplot = FALSE) |>
    biwavelet::wt(sig.level = .95) |>
    plot(plot.cb = TRUE,
         plot.phase = FALSE,
         xlab = "Depth (rmcd)",
         main = "Fe [#]",
         fill.cols = viridis::inferno(n = 64))
#+end_src

#+RESULTS:
[[file:imgs/ODP208_1267_Fe_wavelet.png]]

*** CaCO3 dataset from [cite:@Sexton2011]
:PROPERTIES:
:CREATED:  [2023-09-20 Wed 09:06]
:END:
Too young!

depth sed [m] from 154 m to 163 m.
depth comp [mcd] from to 168 m to 180 m
age [ka BP] from 47800 ka to 50002 ka.
#+begin_src R
  ODP208_1267_CaCO3 <- pangaear::pg_data("10.1594/PANGAEA.763155")
#+end_src
** IODP Exp 342 Site U1403A,B
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 15:29]
:END:
[cite:@Batenburg2018]
d18O data between 66 Ma and 68.8 Ma
XRF ln(Fe/Ca) data between 66 Ma and 68.8 Ma
that /should/ correspond to approximately Ma_{405}1 to Ma_{405}7

#+begin_src R :results output graphics file :file imgs/342-U1403A_d18O_Batenburg2018-fig7.png :width 900 :height 500
  IODP342_U1403A <- pangaear::pg_data("10.1594/PANGAEA.875741")[[1]]
  dat <- IODP342_U1403A$data

  dat |>
    ggplot(aes(x = `Depth sed [m]`, y = `δ18O carb [‰ PDB]`)) +
    geom_line() +
    labs(title = "IODP 342 U1403B d18O and d13C")
#+end_src

#+RESULTS:
[[file:imgs/342-U1403A_d18O_Batenburg2018-fig7.png]]

#+begin_src R :results output graphics file :file imgs/342-U1403A_FeCa_Batenburg2018-fig6.png :width 900 :height 500
  IDOP342_U1403A_XRF <- pangaear::pg_data("10.1594/PANGAEA.875742")[[1]]

  dat <- IDOP342_U1403A_XRF$data

  bp <- dat |>
    mutate(FeCa = log(`Fe count [#]` / `Ca count [#]`)) |>
    select(depth = `Depth comp r [rmcd]`, FeCa) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::bandpass(flow = 1 / 3.4, fhigh = 1 / 6.8)

  # copied from [cite:@Batenburg2018] table 2
  agem <- tibble::tribble(
                     ~ `Depth comp r [rmcd]`, ~ age_ma, ~ sed_rate,
                     247.700, 66.04, NA_real_,
                     251.040, 66.374, 1.00,
                     254.960, 66.782, 0.96,
                     259.205, 67.192, 1.04,
                     263.695, 67.585, 1.14,
                     268.365, 67.986, 1.16,
                     271.680, 68.383, 0.84,
                     274.635, 68.787, 0.73,
                     275.000, 68.837, 0.73
                   )

  dat |>
    ggplot(aes(x = `Depth comp r [rmcd]`, y = log(`Fe count [#]` / `Ca count [#]`))) +
    geom_line() +
    geom_line(aes(x = depth, y = FeCa), data = bp, colour = "red") +
    ## annotate("text", x = 247.7, y = 2, label = "about 66 Ma") +
    ## annotate("text", x = 275, y = 2, label = "about 68.5 Ma") +
    geom_label(aes(label = age_ma, y = 1.9), data = agem) +
    labs(title = "IODP342 U1403A XRF")
#+end_src

#+RESULTS:
[[file:imgs/342-U1403A_FeCa_Batenburg2018-fig6.png]]

** Zumaia and Sopelana
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 15:37]
:END:
[cite:@Batenburg2012]
Ma_{405}1 to Ma_{405}9
66 Ma to ~70 Ma
has some turbidites according to [[id:107d5e85-9f0d-4193-941d-7b8887fa4d28][Frits Hilgen]]

[cite:@Batenburg2014] has Sopelana expansion downwards

*** read the data from the supplementary info
#+begin_src R :results output graphics file :file imgs/Zumaia_Batenburg2012.png :width 900 :height 500
  # Batenburg et al., 2012
  Zumaia <- readxl::read_excel("dat/Batenburg2012/1-s2.0-S0012821X12005742-mmc2.xls") |>
    rename(depth = Depth,
           MS = `Magentic susceptibility (SI)`, # notice typo! XD
           Lstar = `Reflectance, L* (%)`,
           d13C_VPDB = `δ13C (‰VPDB) outliers in italics`) |>
    mutate(depth = depth / 100) # convert from cm to m?

  # Batenburg et. al., 2014
  Sopelana <- readr::read_csv("dat/Batenburg2014/18696_2.csv",
                                 skip = 2,
                                 col_names = c("depth", "MS", "", "depth_comp_mm", "Lstar"),
                                 col_select = c(1, 2, 5))
  # I have double-checked that the depth_comp_m and depth_comp_mm are identical throughout
  ## Sopelana |>
  ## mutate(same = depth_comp_m == depth_comp_mm) |>
  ## filter(!same)



  library(patchwork)

  (Zumaia |>
    ggplot(aes(x = depth, y = MS)) +
    geom_line()) /
  (Zumaia |>
    ggplot(aes(x = depth, y = Lstar)) +
    geom_line()) /
  (Zumaia |>
    filter(!is.na(d13C_VPDB)) |>
    ggplot(aes(x = depth, y = d13C_VPDB)) +
   geom_line())

  (Sopelana |>
     ggplot(aes(x = depth, y = magsus)) +
   geom_line()) /
    (Sopelana |>
     ggplot(aes(x = depth, y = Lstar)) +
     geom_line())

  # assmeble them all in a single df
  comp <- Zumaia |>
    pivot_longer(MS:d13C_VPDB) |>
    mutate(comment = if_else(name == "d13C_VPDB", comment, NA_character_)) |>
    tidylog::filter(is.na(comment) | comment != "outlier") |>
    tidylog::filter(!is.na(value)) |>
    mutate(site = "Zumaia") |>
    bind_rows(
      Sopelana |>
      pivot_longer(MS:Lstar) |>
      mutate(site = "Sopelana")
    )

  comp |>
    ggplot(aes(x = depth, y = value, colour = site)) +
    facet_grid(rows = vars(name), scales = "free_y") +
    geom_line() +
    geom_smooth()
    ## geom_smooth(aes(group = "all"))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_Batenburg2012.png]]

*** [#C] simple taner filters like [cite:@Husson2011]
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 14:18]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_filters.png :width 900 :height 500
  f100 <- Zumaia |>
    select(depth, Lstar) |>
    filter(!is.na(Lstar)) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::taner(flow = 0, fhigh = 1) |>
    as_tibble()

  f405 <- Zumaia |>
    select(depth, Lstar) |>
    filter(!is.na(Lstar)) |>
    astrochron::linterp(genplot = FALSE) |>
    astrochron::taner(flow = 0, fhigh = .4) |>
    as_tibble()

  (Zumaia |>
   filter(!is.na(d13C_VPDB)) |>
    ggplot(aes(x = depth, y = d13C_VPDB)) +
    geom_line() + labs(title = "Zumaia")) /
  (Zumaia |>
   ggplot(aes(x = depth, y = Lstar)) +
   geom_line(alpha = .3, colour = "darkblue") +
   geom_line(data = f100, colour = "skyblue") +
   geom_line(data = f405)) /
  (Zumaia |>
    ggplot(aes(x = depth, y = MS)) +
    geom_line())
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_filters.png]]

*** subtract the long-term trends
:PROPERTIES:
:CREATED:  [2023-09-22 Fri 14:18]
:END:
**** This just subtracts a gam from the raw data
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 15:35]
:END:
#+begin_src R
  smooth_basic <- comp |>
    ## pivot_wider() |>
    nest(.by = c(name, site,)) |> # nest_by is different!!
    mutate(
      gam = map(data,
                     ~ mgcv::gam(value ~ s(depth, bs = "cs"),
                                 method = "REML",
                                 data = .))) |>
    mutate(
      gam_pred = map(gam, predict),
    ) |>
    select(-gam) |>
    unnest(cols = c(data, gam_pred)) |>
    mutate(det = scale(value - gam_pred)[, 1], .by = c(name, site))
#+end_src

#+RESULTS:

**** subtract red/white interval means and then do a gam for the whole record
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 15:35]
:END:
we have to be careful of the white/red intervals in the record!
So instead of fitting a simple gam through the whole record, we fit one for each coloured interval separately.

#+begin_src R
  smooth <- comp |>
    mutate(colour = case_when(
             depth < 0 ~ "white1",
             depth > 0 & depth <= 58.59 ~ "red1",
             depth > 58.59 & depth <= 59 ~ "pink1",
             depth > 59 & depth <= 82.75 ~ "white2",
             depth > 82.75 & depth <= 87.8 ~ "pink2",
             depth > 87.8 & depth <= 108.5 ~ "red2",
             depth > 108.5 & depth <= 109.8 ~ "pink3",
             depth > 109.8 ~ "white3",
             TRUE ~ NA_character_)) |>
    ## mutate(mean_colour = mean(value), .by = c(site, name, colour)) |>
    ## mutate(dec = value - mean_colour) |>
    ## pivot_wider() |>
    # first calculate a lm for each slice of colour interval
    nest(.by = c(name, site, colour)) |> # nest_by is different!!
    mutate(
      lim = map(data, ~ lm(value ~ depth, data = .x)),
      lin_pred = map(lim, predict)) |>
    select(-lim) |>
    unnest(c(data, lin_pred)) |>
    mutate(lin = value - lin_pred) |>
    nest(.by = c(name, site)) |> # nest_by is different!!
    mutate(
      gamm = map(data,
                ## ~ loess(dec ~ depth, data = ., span = .9)
                ~ mgcv::gam(lin ~ s(depth, bs = "cs"),
                            method = "REML",
                            data = .)),
      gam_pred = map(gamm, predict)
    ) |>
    select(-gamm) |>
    unnest(cols = c(data, gam_pred)) |>
    mutate(gam = lin - gam_pred,
           det = scale(gam)[, 1],
           .by = c(name, site))
#+end_src

#+RESULTS:

**** did the linear trend removal work?
:PROPERTIES:
:CREATED:  [2023-09-26 Tue 10:57]
:END:
***** lines
#+begin_src R
  smooth |>
    ggplot(aes(x = depth, y = value)) +
    geom_line() +
    facet_grid(rows = vars(name), scales = "free_y") +
    geom_line(aes(y = lin_pred, group = paste(site, colour)), colour = "red", linewidth = 2)
#+end_src

#+RESULTS:

***** gam
#+begin_src R
  smooth |>
    ggplot(aes(x = depth, y = lin)) +
    geom_line() +
    facet_grid(rows = vars(name), scales = "free_y") +
    geom_line(aes(y = gam_pred, group = paste(site)), colour = "red", linewidth = 2)
#+end_src

#+RESULTS:

***** final result
#+begin_src R
  smooth |>
    ggplot(aes(x = depth, y = det)) +
    geom_line() +
    facet_grid(rows = vars(name), scales = "free_y") #+
    ## geom_line(aes(y = gam_pred, group = paste(site)), colour = "red", linewidth = 2)
#+end_src

#+RESULTS:


**** COMMENT gam with custom knots around the colour transitions
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 15:43]
:END:
#+begin_src R
  smooth_k <- comp |>
    nest(.by = c(name, site,)) |> # nest_by is different!!
    mutate(
      gam = map(data,
                     ~ mgcv::gam(value ~ s(depth, bs = "cs"),
                                 method = "REML",
                                 k = 6,
                                 knots = c(-5, 0, 58.75, 85, 109, 145),
                                 data = .))) |>
    mutate(
      gam_pred = map(gam, predict),
    ) |>
    select(-gam) |>
    unnest(cols = c(data, gam_pred)) |>
    mutate(det = scale(value - gam_pred)[, 1], .by = c(name, site))
#+end_src

#+RESULTS:

*** plot long-term trend removal
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 14:30]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia_long-term-trend.png :width 900 :height 500
  (smooth |>
   filter(site == "Zumaia", name == "MS") |>
   ggplot(aes(x = depth, y = dec)) +
   geom_line(aes(y = value), colour = "gray") +
   ## geom_line(aes(y = det), smooth_basic) +
   geom_line(colour = "gray4") +
   geom_line(aes(y = mean_colour), colour = "darkgreen") +
   ## geom_smooth(method = "loess", span = .05) +
   geom_line(aes(y = gam_pred, group = site), colour = "blue", linewidth = 2) +
   geom_line(aes(y = gam_pred, group = site), linewidth = 2,
             colour = "red",
             data = smooth_basic |> filter(site == "Zumaia", name == "MS")) +
   facet_grid(rows = vars(name), scales = "free_y") #+
    ## geom_vline(xintercept = c(59, 85, 109)) +
    ## annotate("rect",
    ##          xmin = c(-5, 0, 58.75, 85, 109),
    ##          xmax = c(0, 59, 85, 109, 145),
    ##          ymin = 0, ymax = 1,
    ##          fill = c("gray", "red", "gray", "red", "gray"),
    ##          alpha = .2
   ##          )
   ) /
  (smooth |>
   filter(site == "Zumaia", name == "MS") |>
   ggplot(aes(x = depth, y = det)) +
   geom_line() +
   ## geom_smooth(method = "loess", span = .05) +
   facet_grid(rows = vars(name), scales = "free_y") +
   ## geom_vline(xintercept = c(59, 85, 109)) +
   annotate("rect",
            xmin = c(-5, 0, 59, 85, 109),
            xmax = c(0, 59, 85, 109, 145),
            ymin = 0, ymax = 1,
            fill = c("gray", "red", "gray", "red", "gray"),
            alpha = .2
            ))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia_long-term-trend.png]]

*** calculate spectra
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 10:56]
:END:
#+begin_src R
  specs <- comp |>
    nest(.by = c(name, site)) |>
    mutate(
      mtm = map(data,
                ~ . |>
                  select(depth, value) |>
                  astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                  astrochron::mtm(output = 1, genplot = FALSE, verbose = FALSE))
    ) |>
    unnest(mtm)
#+end_src

#+RESULTS:

**** make plot of spectra
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 10:57]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_mtm.png :width 900
  specs |>
    ggplot(aes(x = Frequency/100, y = Power, colour = site)) +
    facet_grid(## cols = vars(site),
               rows = vars(name)) +
    geom_line() +
    geom_line(aes(y = AR1_fit)) +
    geom_line(aes(y = AR1_95_power), linetype = "dashed") +
    ## geom_line(aes(y = Harmonic_CL)) +
    ## coord_cartesian(xlim = c(0.0001, 0.05)) +
    scale_y_log10()# +
    ## scale_x_continuous(trans = "reciprocal")
    ## scale_x_log10() #+
    ## scale_x_continuous(sec.axis = sec_axis(trans = ~ 1 / .x, breaks = c(10, 1, .5, .3, .2, .1))) +
    ## geom_rect(aes(xmin = flow, xmax = fhigh, ymin = 1e-5, ymax = 1, fill = name),
              ## inherit.aes = FALSE,
              ## alpha = .3, data = filts2 |> distinct(name, flow, fhigh))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia-Sopelana_mtm.png]]

*** calculate spectra on artificially chopped up record
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 10:56]
:END:
#+begin_src R
  specs <- smooth |>
    nest(.by = c(name, site)) |>
    mutate(
      mtm = map(data,
                ~ . |>
                  select(depth, det) |>
                  astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                  astrochron::mtm(output = 1, genplot = FALSE, verbose = FALSE))
    ) |>
    unnest(mtm)
#+end_src

#+RESULTS:

**** make plot of spectra
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 10:57]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_mtm.png :width 900
  specs |>
    ggplot(aes(x = Frequency, y = Power, colour = site)) +
    facet_grid(## cols = vars(site),
               rows = vars(name)) +
    geom_line() +
    geom_line(aes(y = AR1_fit)) +
    geom_line(aes(y = AR1_95_power), linetype = "dashed") +
    ## geom_line(aes(y = Harmonic_CL)) +
    coord_cartesian(xlim = c(0.01, 5)) +
    scale_y_log10() +
    ## scale_x_continuous(trans = "reciprocal")
    ## scale_x_log10() +
    ## scale_x_continuous(sec.axis = sec_axis(trans = ~ 1 / .x, breaks = c(10, 1, .5, .3, .2, .1))) +
    geom_rect(aes(xmin = flow, xmax = fhigh, ymin = 1e-5, ymax = 1, fill = name),
              inherit.aes = FALSE,
              alpha = .3, data = filts_fancy |> distinct(name, flow, fhigh))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia-Sopelana_mtm.png]]
*** do bandpass filtering
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 10:56]
:END:
**** bp on raw
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 16:18]
:END:
#+begin_src R
  filts_basic <-
    comp |>
    nest(.by = c(name, site)) |>
    # different filters per proxy
    mutate(flow = case_when(name == "MS" ~ 1 / 12,
                            name == "Lstar" ~ 1 / 12,
                            name == "d13C_VPDB" ~ 1 / 12,
                            TRUE ~ NA_real_),
           fhigh = case_when(name == "MS" ~ 1 / 24,
                             name == "Lstar" ~ 1 / 29, # this was 22 in Batenburg 2012, 29 in 2014.
                             name == "d13C_VPDB" ~ 1 / 31,
                             TRUE ~ NA_real_)) |>
    mutate(
      bp = pmap(list(data, flow, fhigh),
               \(d, l, h) d |>
                 select(depth, value) |>
                 astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                 astrochron::bandpass(flow = l, fhigh = h, win = 0,
                                      genplot = FALSE))
    ) |>
    unnest(cols = bp) |>
    rename(filt = value)
  # TODO: 100 kyr
#+end_src
**** bp on scaled
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 16:47]
:END:
#+begin_src R
  filts_scl <- comp |>
      nest(.by = c(name, site)) |>
      # different filters per proxy
      mutate(flow = case_when(name == "MS" ~ 1 / 12,
                              name == "Lstar" ~ 1 / 12,
                              name == "d13C_VPDB" ~ 1 / 12,
                              TRUE ~ NA_real_),
             fhigh = case_when(name == "MS" ~ 1 / 24,
                               name == "Lstar" ~ 1 / 29, # this was 22 in Batenburg 2012, 29 in 2014.
                               name == "d13C_VPDB" ~ 1 / 31,
                               TRUE ~ NA_real_)) |>
      mutate(
        bp = pmap(list(data, flow, fhigh),
                 \(d, l, h) d |>
                   mutate(scl = scale(value)[, 1]) |>
                   select(depth, scl) |>
                   astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                   astrochron::bandpass(flow = l, fhigh = h, win = 0,
                                        genplot = FALSE))
      ) |>
      unnest(cols = bp) |>
      rename(filt = scl)
#+end_src

#+RESULTS:
#+begin_example

----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----
 ,* Number of data points= 386
 ,* Sample interval= 0.375
 ,* Mean value removed= -0.07309613
 ,* Center of bandpass filter = 0.0577957
 ,* 15 pos/neg frequency pairs will be bandpassed

----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----
 ,* Number of data points= 1349
 ,* Sample interval= 0.10458
 ,* Mean value removed= 0.09609354
 ,* Center of bandpass filter = 0.0625
 ,* 12 pos/neg frequency pairs will be bandpassed

----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----
 ,* Number of data points= 1344
 ,* Sample interval= 0.105
 ,* Mean value removed= -0.09514475
 ,* Center of bandpass filter = 0.05890805
 ,* 14 pos/neg frequency pairs will be bandpassed

----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----
 ,* Number of data points= 625
 ,* Sample interval= 0.08
 ,* Mean value removed= 0.0221335
 ,* Center of bandpass filter = 0.0625
 ,* 4 pos/neg frequency pairs will be bandpassed

----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----
 ,* Number of data points= 625
 ,* Sample interval= 0.08
 ,* Mean value removed= 0.02285176
 ,* Center of bandpass filter = 0.05890805
 ,* 5 pos/neg frequency pairs will be bandpassed
#+end_example

**** bp on the gam
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 16:18]
:END:
#+begin_src R
  filts_gam <-
    smooth_basic |>
    nest(.by = c(name, site)) |>
    # different filters per proxy
    mutate(flow = case_when(name == "MS" ~ 1 / 12,
                            name == "Lstar" ~ 1 / 12,
                            name == "d13C_VPDB" ~ 1 / 12,
                            TRUE ~ NA_real_),
           fhigh = case_when(name == "MS" ~ 1 / 24,
                             name == "Lstar" ~ 1 / 29, # this was 22 in Batenburg 2012, 29 in 2014.
                             name == "d13C_VPDB" ~ 1 / 31,
                             TRUE ~ NA_real_)) |>
    mutate(
      bp = pmap(list(data, flow, fhigh),
               \(d, l, h) d |>
                 select(depth, det) |>
                 astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                 astrochron::bandpass(flow = l, fhigh = h, win = 0,
                                      genplot = FALSE))
    ) |>
    unnest(cols = bp) |>
    rename(filt = det)
  # TODO: 100 kyr
#+end_src

#+RESULTS:
**** bp on the gam with white/red separation
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 16:18]
:END:
#+begin_src R
  filts_fancy <-
    smooth |>
    nest(.by = c(name, site)) |>
    # different filters per site
    ## mutate(flow = case_when(site == "Zumaia" & name == "MS" ~ 1 / 12,
    ##                         site == "Zumaia" & name == "Lstar" ~ 1 / 12,
    ##                         site == "Zumaia" & name == "d13C_VPDB" ~ 1 / 12,
    ##                         # filter intervals from Batenburg 2014 fig 3
    ##                         site == "Sopelana" & name == "MS" ~ 1 / 8.1,
    ##                         site == "Sopelana" & name == "Lstar" ~ 1 / 7.7,
    ##                         site == "Sopelana" & name == "d13C_VPDB" ~ 1 / 8.1,
    ##                         TRUE ~ NA_real_),
    ##        fhigh = case_when(site == "Zumaia" & name == "MS" ~ 1 / 40,
    ##                          site == "Zumaia" & name == "Lstar" ~ 1 / 22,
    ##                          site == "Zumaia" & name == "d13C_VPDB" ~ 1 / 31,
    ##                          site == "Sopelana" & name == "MS" ~ 1 / 15.8,
    ##                          site == "Sopelana" & name == "Lstar" ~ 1 / 14.3,
    ##                          ## site == "Sopelana" & name == "d13C_VPDB" ~ 1 /
    ##                          TRUE ~ NA_real_)) |>
    # different filters per proxy
    mutate(flow = case_when(name == "MS" ~ 1 / 12,
                            name == "Lstar" ~ 1 / 12,
                            name == "d13C_VPDB" ~ 1 / 12,
                            TRUE ~ NA_real_),
           fhigh = case_when(name == "MS" ~ 1 / 24,
                             name == "Lstar" ~ 1 / 29, # this was 22 in Batenburg 2012, 29 in 2014.
                             name == "d13C_VPDB" ~ 1 / 31,
                             TRUE ~ NA_real_)) |>
    mutate(
      bp = pmap(list(data, flow, fhigh),
               \(d, l, h) d |>
                 select(depth, det) |>
                 astrochron::linterp(genplot = FALSE, verbose = FALSE) |>
                 astrochron::bandpass(flow = l, fhigh = h, win = 0,
                                      genplot = FALSE))
    ) |>
    unnest(cols = bp) |>
    rename(filt = det)
  # TODO: 100 kyr
#+end_src

#+RESULTS:
#+begin_example

----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----
 ,* Number of data points= 386
 ,* Sample interval= 0.375
 ,* Mean value removed= -0.06151652
 ,* Center of bandpass filter = 0.0577957
 ,* 15 pos/neg frequency pairs will be bandpassed

----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----
 ,* Number of data points= 1349
 ,* Sample interval= 0.10458
 ,* Mean value removed= 0.02744599
 ,* Center of bandpass filter = 0.0625
 ,* 12 pos/neg frequency pairs will be bandpassed

----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----
 ,* Number of data points= 1344
 ,* Sample interval= 0.105
 ,* Mean value removed= -0.0158664
 ,* Center of bandpass filter = 0.05890805
 ,* 14 pos/neg frequency pairs will be bandpassed

----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----
 ,* Number of data points= 625
 ,* Sample interval= 0.08
 ,* Mean value removed= 0.04618908
 ,* Center of bandpass filter = 0.0625
 ,* 4 pos/neg frequency pairs will be bandpassed

----- BANDPASS FILTERING STRATIGRAPHIC SERIES-----
 ,* Number of data points= 625
 ,* Sample interval= 0.08
 ,* Mean value removed= -0.0161482
 ,* Center of bandpass filter = 0.05890805
 ,* 5 pos/neg frequency pairs will be bandpassed
#+end_example

*** load in the identified 405-kyr minima from the field of [cite:@Batenburg2012]
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 11:01]
:END:
#+begin_src R
  agem <- read_csv("dat/Batenburg2012/405_minima.csv")
#+end_src

#+RESULTS:
: indexing 405_minima.csv [===========================================================] 58.04MB/s, eta:  0s                                                                                                                                            Rows: 20 Columns: 5
: ── Column specification ─────────────────────────────────────────────────────────────────────────────────
: Delimiter: ","
: chr (3): comment, minmax, desc
: dbl (2): strat_bot, strat_top
:
: ℹ Use `spec()` to retrieve the full column specification for this data.
: ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

*** make plot of records with filters
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 10:57]
:END:
**** [#A] complicated overview plot
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 16:19]
:END:

#+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_records.png :width 900
  comp |>
    filter(site == "Zumaia", name == "MS") |>
    ggplot(aes(x = depth, y = value, group = paste(site, name))) +
    facet_grid(rows = vars(name), scales = "free_y") +
    # r/w intervals
    annotate("rect",
             xmin = c(-5, 0, 59, 85, 109),
             xmax = c(0, 59, 85, 109, 145),
             ymin = 45, ymax = 50,
             fill = c("gray", "red", "gray", "red", "gray"),
             alpha = .2
             ) +

    # "raw" data
    geom_line(colour = "gray") +
    annotate("text", x = 145, y = 33, label = "raw - r/w", colour = "gray", hjust = 0) +
    geom_line(aes(y = lin + 30), colour = "gray", data = smooth |>
              filter(site == "Zumaia", name == "MS")) +
    annotate("text", x = 145, y = 10, label = "raw", colour = "gray", hjust = 0) +
    geom_line(aes(y = scale(value)[, 1]), colour = "gray") + # scaled
    annotate("text", x = 145, y = 0, label = "scaled", colour = "gray", hjust = 0) +
    geom_line(aes(y = det - 5), data = smooth_basic |>
                              filter(site == "Zumaia", name == "MS"),
              colour = "gray") +
    annotate("text", x = 145, y = -5, label = "gam", colour = "gray", hjust = 0) +
    geom_line(aes(y = det - 10), data = smooth |>
                              filter(site == "Zumaia", name == "MS"),
              colour = "gray") +
    annotate("text", x = 145, y = -10, label = "gam r/w", colour = "gray", hjust = 0) +

    ## # gam and other trends
    geom_line(aes(y = gam_pred, colour = "gam"), data = smooth_basic |>
                              filter(site == "Zumaia", name == "MS")) +
    geom_line(aes(y = lin_pred, colour = "mean r/w", group = colour), data = smooth |>
                              filter(site == "Zumaia", name == "MS")) +
    geom_line(aes(y = gam_pred + 30, colour = "gam pred r/w"), data = smooth |>
                              filter(site == "Zumaia", name == "MS")) +

    ## # filters
    geom_line(aes(y = filt, colour = "scaled filt"),
              data = filts_scl |>
              filter(site == "Zumaia", name == "MS")) +
    geom_line(aes(y = filt - 5, colour = "gam filt"),
              data = filts_gam |>
              filter(site == "Zumaia", name == "MS")) +
    geom_line(aes(y = filt - 10, colour = "gam + r/w filt"),
              data = filts_fancy |>
              filter(site == "Zumaia", name == "MS")) +

    ## # age model from the log
    geom_point(aes(x = strat_bot, y = -2,
                   size = !is.na(comment)),
               inherit.aes = FALSE,
               data = agem |>
                 filter(minmax == "minimum")) +
    annotate("text", x = 145, y = -2, label = "minima", hjust = 0) +
    annotate("text", x = 145, y = 2, label = "maxima", hjust = 0) +
    geom_segment(aes(x = strat_bot, xend = strat_top,
                     y = 2, yend = 2),
                 inherit.aes = FALSE,
                 data = agem |>
                   filter(minmax == "maximum"),
                 linewidth = 2) +
    # try to make it into little sine waves
    ## geom_segment(aes(x = strat_bot, xend = strat_top,
    ##                  y = if_else(minmax == "minimum", 1.5, -1.5),
    ##                  yend = if_else(minmax == "minimum", -1.5, 1.5)),
    ##              data = agem) +

    coord_cartesian(xlim = c(0, 150)) +
    labs(x = "Depth (m)", y = "Proxy value", colour = "Site", size = "Well-defined") #+
    ## theme(legend.position = "none")
#+end_src

#+RESULTS:
[[file:imgs/Zumaia-Sopelana_records.png]]

**** basic gam removal
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 15:36]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_records.png :width 900
  smooth_basic |>
    filter(site == "Zumaia", name == "MS") |>
    ggplot(aes(x = depth, y = value, group = paste(site, name))) +
    facet_grid(rows = vars(name), scales = "free_y") +
    geom_line(colour = "gray") +
    geom_line(aes(y = gam_pred)) +
    geom_line(aes(y = det)) +
    geom_line(aes(y = filt, colour = "basic filt"),
              data = filts_basic |>
              filter(site == "Zumaia", name == "MS")) +
    geom_point(aes(x = strat_bot, y = -2,
                   size = !is.na(comment)),
               inherit.aes = FALSE,
               data = agem |>
               filter(minmax == "minimum")) +
    geom_segment(aes(x = strat_bot, xend = strat_top,
                     y = 2, yend = 2),
                 inherit.aes = FALSE,
                 data = agem |>
                   filter(minmax == "maximum"),
                 linewidth = 2) +
    # try to make it into little sine waves
    ## geom_segment(aes(x = strat_bot, xend = strat_top,
    ##                  y = if_else(minmax == "minimum", 1.5, -1.5),
    ##                  yend = if_else(minmax == "minimum", -1.5, 1.5)),
    ##              data = agem) +
    labs(x = "Depth (m)", y = "Scaled proxy value", colour = "Site", size = "Well-defined")
    ## geom_text(aes(x = strat_bot, y = 0,
    ##                label = desc), data = agem)
#+end_src

#+RESULTS:
[[file:imgs/Zumaia-Sopelana_records.png]]
**** gam removal after subtracting the mean
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 15:42]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_records.png :width 900
  smooth |>
    ggplot(aes(x = depth, y = value, group = paste(site, name))) +
    facet_grid(rows = vars(name), scales = "free_y") +
    ## geom_line(colour = "gray") +
    ## geom_line(aes(y = gam_pred, group = site))
    geom_line(aes(y = det)) +
    geom_line(aes(y = filt, colour = "fancy filt"), data = filts) +
    geom_line(aes(y = filt, colour = "basic filt"), data = filts_basic) +
    geom_point(aes(x = strat_bot, y = -2,
                   size = !is.na(comment)),
               inherit.aes = FALSE,
               data = agem |>
               filter(minmax == "minimum")) +
    geom_segment(aes(x = strat_bot, xend = strat_top,
                     y = 2, yend = 2),
                 inherit.aes = FALSE,
                 data = agem |>
                   filter(minmax == "maximum"),
                 linewidth = 2) +
    # try to make it into little sine waves
    ## geom_segment(aes(x = strat_bot, xend = strat_top,
    ##                  y = if_else(minmax == "minimum", 1.5, -1.5),
    ##                  yend = if_else(minmax == "minimum", -1.5, 1.5)),
    ##              data = agem) +
    labs(x = "Depth (m)", y = "Scaled proxy value", colour = "Site", size = "Well-defined")
    ## geom_text(aes(x = strat_bot, y = 0,
    ##                label = desc), data = agem)
#+end_src

#+RESULTS:
[[file:imgs/Zumaia-Sopelana_records.png]]

note that the minima from the field do not map 1:1 to the minima in the records...
*** make plot of spectra
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 10:57]
:END:
#+begin_src R :results output graphics file :file imgs/Zumaia-Sopelana_mtm.png :width 900
  specs |>
    ggplot(aes(x = Frequency, y = Power, colour = site)) +
    facet_grid(rows = vars(name)) +
    geom_line() +
    geom_line(aes(y = AR1_fit)) +
    geom_line(aes(y = AR1_95_power), linetype = "dashed") +
    ## geom_line(aes(y = Harmonic_CL)) +
    coord_cartesian(xlim = c(NA, 5)) +
    scale_y_log10() +
    scale_x_continuous(sec.axis = sec_axis(trans = ~ 1 / .x, breaks = c(10, 1, .5, .3, .2, .1))) +
    geom_rect(aes(xmin = flow, xmax = fhigh, ymin = 1e-5, ymax = 1, fill = name),
              inherit.aes = FALSE,
              alpha = .3, data = filts2 |> distinct(name, flow, fhigh))
#+end_src

#+RESULTS:
[[file:imgs/Zumaia-Sopelana_mtm.png]]
*** apply the age model from the field
:PROPERTIES:
:CREATED:  [2023-09-25 Mon 11:16]
:END:
#+begin_src R
  agem <- agem |>
    mutate(n = 0:(n() - 1), .before = comment, .by = minmax)

  # NOTE: original is only the age model for Zumaia!
  agem_simple <- agem |>
    filter(minmax == "minimum") |>
    select(-strat_top, -minmax, -desc) |>
    # let's add the age model for Sopelana
    # copied manually by reading figure 3 in Batenburg et al., 2014!
    bind_rows(
      tribble(
        ~ n, ~ strat_bot,
        10, 149,
        11, 160,
        12, 171,
        13, 183)) |>
    mutate(age = n * 405)

  smooth |>
    ## filter(site == "Zumaia") |>
    mutate(age = Hmisc::approxExtrap(agem_simple$strat_bot,
                                     agem_simple$age,
                                     xout = depth)$y) |>
    ggplot(aes(x = age, y = value)) +
    facet_grid(rows = vars(name), scales = "free_y") +
    ## geom_line(colour = "gray") +
    ## geom_line(aes(y = gam_pred, group = site))
    geom_line(aes(y = det, colour = site)) +
    geom_point(aes(x = age, y = -2.5), data = agem_simple)
#+end_src
** Gubbio
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 15:51]
:END:
via [cite:@Batenburg2018] fig 7

Umbria--March Basin, Italy
66 Ma to ~76 Ma
Ma_{405}1 to at least Ma_{405}12ish?
[cite:@Voigt2012]
https://doi.pangaea.de/10.1594/PANGAEA.778969

also MS from [cite:@Husson2014] https://doi.pangaea.de/10.1594/PANGAEA.829778
#+begin_src R :results output graphics file :file imgs/Gubbio_MS_Husson2014.png :width 900 :height 500
  Gubbio <- pangaear::pg_data("10.1594/PANGAEA.829778")[[1]]

  dat <- Gubbio$data

  dat |>
    ggplot(aes(x = `Depth sed [m]`, y = `chi [10**-9 m**3/kg]`)) +
    geom_line() +
    labs(title = "Gubbio MS")
#+end_src

#+RESULTS:
[[file:imgs/Gubbio_MS_Husson2014.png]]

also this newer composite by [cite:@Gabriella2023]
malformed forams
OAE-2
https://doi.pangaea.de/10.1594/PANGAEA.954540

** ODP Leg 198 Site 1210B
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 15:52]
:END:
found via [cite:@Batenburg2018]
Shatsky Rise equatorial Pacific [cite:@Jung2012]
Ma_{405}2 to at least Ma_{405}12 ish?
66.25 Ma to ~71.5 Ma

table in the supplement:
#+begin_src R :results output graphics file :file imgs/198-1210B_d13C_Jung2012.png :width 900 :height 500
  ODP198_1210B <- readxl::read_excel("dat/Jung2012/1-s2.0-S0195667112000547-mmc1.xls",
                                     range = "B2:E618",
                                     col_types = "numeric") |>
    rename(depth_mbsf = `Depth (mbsf)`,
           d13C_VPDB = `δ13C (‰ V-PDB)`,
           d18O_VPDB = `δ18O (‰ V-PDB)`,
           age = `Age (Ma)`)

  (ODP198_1210B |>
   ggplot(aes(x = depth_mbsf, y = d13C_VPDB)) +
   geom_line() +
   labs(title = "ODP 198 Site 1210B")) /
    (ODP198_1210B |>
     ggplot(aes(x = age, y = d18O_VPDB)) +
     geom_line())
#+end_src

#+RESULTS:
[[file:imgs/198-1210B_d13C_Jung2012.png]]

but the data are also available on pangaea now in [cite:@Ji-Eun2022]
refers to this study for raw data: https://doi.pangaea.de/10.1594/PANGAEA.950806
#+begin_src R :results output graphics file :file imgs/198-1210_d13C_Jung2012-fig6.png :width 900 :height 500
  IODP198_1210B <- pangaear::pg_data("10.1594/PANGAEA.950806")[[1]]

  dat <- IODP198_1210B$data

  (dat |>
   ggplot(aes(x = `Tuned time [Ma] (405)`, y = `δ13C carb [‰ PDB] (vs. VPDB)`)) +
   geom_line() +
   labs(title = "ODP 198 Site 1210B")) /
  (dat |>
    ggplot(aes(x = `Tuned time [Ma] (405)`, y = `δ18O carb [‰ PDB] (vs. VPDB)`)) +
    geom_line())
#+end_src

#+RESULTS:
[[file:imgs/198-1210_d13C_Jung2012-fig6.png]]

** ODP Leg 74 Site 525A
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 14:57]
:END:
Ma_{405}6 to Ma_{405}8.5
67.8 Ma to 69 Ma
[cite:@Husson2011] grayscale log
*** WAIT waiting for grayscale log in email
:LOGBOOK:
- State "WAIT"       from              [2023-08-31 Thu 15:20]
:END:

** ODP Leg 207 Site 1258B
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 14:58]
:END:
Ma_{405}8? to Ma_{405}14

raw data from https://doi.pangaea.de/10.1594/PANGAEA.266578
analysis copies [cite:@Husson2011]

#+begin_src R :results output graphics file :file imgs/207-1258B_MS_Husson-fig4.png :width 900 :height 500
  ODP207_1258B_MS <- pangaear::pg_data("10.1594/PANGAEA.266578")[[1]]

  dat <- ODP207_1258B_MS$data |>
    rename(depth_mbsf = `Depth sed [m]`,
           depth_mcd = `Depth comp [mcd]`,
           label = `Sample label`,
           MS = `kappa [10**-6 SI]`) #|>
    ## mutate(MS = MS * 1e2) # convert from 10^-6 SI to 10^-8kgm^-3

  mtm <- dat |>
    select(depth_mcd, MS) |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::mtm(xmax = 3, pl = 2) |>
    as_tibble()

  f100 <- dat |>
    select(depth_mcd, MS) |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::taner(flow = 0, fhigh = 0.9, xmax = 3) |>
    as_tibble()

  f405 <- dat |>
    select(depth_mcd, MS) |>
    astrochron::linterp(genplot = FALSE) |> # this seems to get rid of the main outliers as well
    astrochron::taner(flow = 0, fhigh = 0.4, xmax = 1) |>
    as_tibble()

  dat |>
    ggplot(aes(x = depth_mcd, y = MS)) +
    ## annotate("rect", xmin = 285.9, xmax = 286.5, ymin = -Inf, ymax = Inf,
    ##          fill = "yellow", alpha = .6) + # the K/Pg boundary
    geom_line(colour = "darkblue") +
    geom_line(aes(y = MS + 5), data = f100, colour = "skyblue") +
    geom_line(aes(y = MS + 7), data = f405, colour = "black") +
    coord_cartesian(xlim = c(285, 350), expand = FALSE) +
    labs(x = "Depth (mbsf)", y = MS ~ "(10"^{-8} ~ "kgm"^{-3} * ")",
         title = "ODP Leg 207 Site 1258B")


  ## rmcd <- pangaear::pg_data("10.1594/pangaea.666132")[[1]]$data

  ## # add rmcd depth
  ## dat <- dat |>
  ##   ## astrochron::tune(controlPts = rmcd, genplot = FALSE)
  ##   mutate(rmcd = approx(x = rmcd$`Depth comp [mcd]`,
  ##                        y = rmcd$`Depth comp r [rmcd]`,
  ##                        xout = dat$`Depth comp [mcd]`)$y)

  # add age model. This links raw mcd and armcd scale to 100 kyr maxima
  # agem <- pangaear::pg_data("10.1594/PANGAEA.666282")
  # but it's a PDF :S

#+end_src

#+RESULTS:
[[file:imgs/207-1258B_MS_Husson-fig4.png]]

*** SOME get raw data from [cite:@Husson2011], they've extended this record!
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 15:21]
:END:
:LOGBOOK:
- State "SOME"       from              [2023-08-31 Thu 15:21]
:END:

** ODP Leg 122 Site 762C
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 14:24]
:END:
grayscale log from [cite:@Husson2011,Thibault2012]
Ma_{405}8 until Ma_{408}17 and then on to Ca_{405}4
~69 Ma to ~77.5 Ma?

these were sent to me by Nicolas Thibault upon request, also cite [cite:@Thibault2012]
reproduce [cite:@Husson2011] figure 3 and 4

#+begin_src R :results output graphics file :file imgs/122-762B_grayscale_Husson-fig4.png :width 900 :height 500
  ODP122_762C_gs <- readxl::read_excel("dat/Thibault2012/pal06092-mmc4.xls",
                                       range = "A1:H7995",
                                       guess_max = 2000)

  dat <- ODP122_762C_gs |>
    rename(depth_ambsf = ambsf, gray = `grey level (0-255)`,
           depth_mbsf = mbsf,
           core = `ODP Site 762C Cores`,
           section = Section,
           remarks = Remarks,
           kyr100 = `100 kyr cycles`,
           kyr405 = `405 kyr cycles`) |>
    mutate(leg = 122, site = 762, hole = "C", .before = core) |>
    mutate(smooth = slider::slide_dbl(gray, mean, .before = 7, .after = 7))

  f100 <- dat |>
    select(depth_ambsf, gray) |>
    astrochron::linterp(genplot = FALSE) |> # TODO: take care of gaps!
    astrochron::taner(flow = 0, fhigh = 1)

  f405 <- dat |>
    select(depth_ambsf, gray) |>
    astrochron::linterp(genplot = FALSE) |> # TODO: take care of gaps!
    astrochron::taner(flow = 0, fhigh = 0.25) # or is it 0.4?

  dat |>
    ## astrochron::linterp(genplot = FALSE) |>
    ggplot(aes(x = depth_ambsf, y = gray)) +
    annotate("rect", xmin = 555.8, xmax = 556.3, ymin = -Inf, ymax = Inf,
             fill = "yellow", alpha = .6) + # the K/Pg boundary
    ## geom_line(alpha = .2, colour = "darkblue") +
    geom_line(aes(y = smooth), colour = "darkblue") +
    geom_line(aes(y = gray - 90), data = f100, colour = "skyblue") +
    geom_line(aes(y = gray - 100), data = f405, colour = "black") +
    geom_text(aes(label = kyr100, y = 50)) +
    geom_text(aes(label = kyr405, y = 40)) +
    ## coord_cartesian(xlim = c(552, 588), expand = FALSE) +
    scale_y_reverse() +
    labs(title = "ODP122 762C grayscale from photo")
#+end_src

#+RESULTS:
[[file:imgs/122-762B_grayscale_Husson-fig4.png]]

** Bottaccione == Gubbio?
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 16:09]
:END:
d13C and d18O data from [cite:@Sabatino2018]
~ 72.1 Ma to 84.2 Ma (a little more, these are the ages of the Campanian/Maastrichtian and Santonian/Campanian boundaries)
about 12 405 kyr minima

ah, slightly too old? -> can stitch w/ 1210B!

#+begin_src R :results output graphics file :file imgs/Bottaccione_d13C_Sabatino2018.png :width 900 :height 500
  Bottaccione <- readxl::read_excel("dat/Sabatino2018/1-s2.0-S0031018216309336-mmc1.xlsx",
                     range = "A2:C658") |>
    rename(depth = `Sample (m)`,
           d13C_VPDB = `δ13C`,
           d18O_VPDB = `δ18O`)

  Bottaccione |>
    ggplot(aes(x = depth, y = d13C_VPDB)) +
    geom_line() +
    labs(title = "Bottaccione d13C and d18O")
#+end_src

#+RESULTS:
[[file:imgs/Bottaccione_d13C_Sabatino2018.png]]

** Furlo
:PROPERTIES:
:CREATED:  [2023-09-05 Tue 16:09]
:END:
[cite:@Batenburg2016]
color reflectance, carbon/oxygen isotopes from Furlo https://doi.pangaea.de/10.1594/PANGAEA.864715
something like 90 Ma to 96 Ma
straight through the Bonarelli level OAE-2

** Jordanian Levant Platform
:PROPERTIES:
:CREATED:  [2023-09-05 Tue 16:06]
:END:
TOC, d13C, d18O
90.86 Ma to 96.24 Ma
[cite:@Wendler2014]
https://doi.pangaea.de/10.1594/PANGAEA.834794

* NEXT COMMENT figure out how to group by contiguous sections
:PROPERTIES:
:CREATED:  [2023-08-31 Thu 15:17]
:END:
currently linterp does just that
I want to select adjacent areas, group by them, then ignore split-apply-combine for each spectral analysis etc.
* References
:PROPERTIES:
:UNNUMBERED: t
:END:
\printbibliography[heading=none]
